import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
	Container,
	Typography,
	LinearProgress,
	Card as AppleCard,
	Tabs,
	Tab,
	Box,
	CircularProgress,
	Table,
	TableBody,
	TableCell,
	TableHead,
	TableRow,
	IconButton,
	Dialog,
	DialogTitle,
	DialogContent,
	DialogActions,
	TextField,
	Collapse,
	Alert,
	Pagination,
	Fade,
	MenuItem,
	Button,
	Drawer,
	Accordion,
	AccordionSummary,
	AccordionDetails,
} from '@mui/material';
import { styled, GlobalStyles } from '@mui/system';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import DownloadIcon from '@mui/icons-material/Download';
import CheckIcon from '@mui/icons-material/Check';
import ReplayIcon from '@mui/icons-material/Replay';
import RefreshIcon from '@mui/icons-material/Refresh';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import Visibility from '@mui/icons-material/Visibility';
import VisibilityOff from '@mui/icons-material/VisibilityOff';
import HistoryIcon from '@mui/icons-material/History';
import WarningAmberIcon from '@mui/icons-material/WarningAmber';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import { TransitionGroup, CSSTransition } from 'react-transition-group';
import axios from 'axios';
import { useAuth } from '../contexts/AuthContext';
import StatusChip from './StatusChip';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

// Стили компонентов
const AppleTextField = styled(TextField)({
	'& .MuiOutlinedInput-root': {
		borderRadius: '12px',
		backgroundColor: '#F5F5F7',
		'& fieldset': { borderColor: '#D1D1D6' },
		'&:hover fieldset': { borderColor: '#0071E3' },
		'&.Mui-focused fieldset': { borderColor: '#0071E3' },
	},
	'& .MuiInputLabel-root': { color: '#6E6E73' },
	'& .MuiInputLabel-root.Mui-focused': { color: '#0071E3' },
});

const AppleTable = styled(Table)({
	borderCollapse: 'separate',
	borderSpacing: '0 8px',
});

const PlanTable = styled(Table)({
	borderRadius: '16px',
	overflow: 'hidden',
	backgroundColor: '#FFFFFF',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	marginBottom: '16px',
});

const AppleButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#0071E3',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#0066CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const GreenButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: 'green',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#2EBB4A', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const CancelButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#D1D1D6',
	color: '#1D1D1F',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#C7C7CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

// Глобальные стили для анимации аккордеонов
const animationStyles = (
	<GlobalStyles
		styles={{
			'.accordion-enter': {
				opacity: 0,
				transform: 'translateY(20px)',
			},
			'.accordion-enter-active': {
				opacity: 1,
				transform: 'translateY(0)',
				transition: 'opacity 300ms ease, transform 300ms ease',
			},
			'.accordion-exit': {
				opacity: 1,
				transform: 'translateY(0)',
			},
			'.accordion-exit-active': {
				opacity: 0,
				transform: 'translateY(20px)',
				transition: 'opacity 300ms ease, transform 300ms ease',
			},
		}}
	/>
);

// Регулярные выражения для проверки ФИО
const namePartRegex = /^[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?$/;
const fullNameRegex = /^[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?\s[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?\s[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?$/;

function ManagerDashboard() {
	const { user, csrfToken, isAuthenticated } = useAuth();
	const navigate = useNavigate();
	const [value, setValue] = useState(0);
	const [publications, setPublications] = useState([]);
	const [plans, setPlans] = useState([]);
	const [statistics, setStatistics] = useState([]);
	const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());
	const [currentPagePublications, setCurrentPagePublications] = useState(1);
	const [currentPagePlans, setCurrentPagePlans] = useState(1);
	const [dateFilterRange, setDateFilterRange] = useState({ start: '', end: '' });
	const [totalPagesPublications, setTotalPagesPublications] = useState(1);
	const [totalPagesPlans, setTotalPagesPlans] = useState(1);
	const [searchQuery, setSearchQuery] = useState('');
	const [statusFilter, setStatusFilter] = useState('needs_review');
	const [loadingInitial, setLoadingInitial] = useState(true);
	const [loadingStatistics, setLoadingStatistics] = useState(false);
	const [openEditDialog, setOpenEditDialog] = useState(false);
	const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
	const [publicationToDelete, setPublicationToDelete] = useState(null);
	const [editPublication, setEditPublication] = useState(null);
	const [editTitle, setEditTitle] = useState('');
	const [editAuthors, setEditAuthors] = useState('');
	const [editYear, setEditYear] = useState('');
	const [editType, setEditType] = useState('article');
	const [editStatus, setEditStatus] = useState('needs_review');
	const [editFile, setEditFile] = useState(null);
	const [error, setError] = useState('');
	const [success, setSuccess] = useState('');
	const [openError, setOpenError] = useState(false);
	const [openSuccess, setOpenSuccess] = useState(false);
	const [newLastName, setNewLastName] = useState('');
	const [newFirstName, setNewFirstName] = useState('');
	const [newMiddleName, setNewMiddleName] = useState('');
	const [newUsername, setNewUsername] = useState('');
	const [newPassword, setNewPassword] = useState('');
	const [showPassword, setShowPassword] = useState(false);
	const [openReturnDialog, setOpenReturnDialog] = useState(false);
	const [selectedPlan, setSelectedPlan] = useState(null);
	const [selectedPublication, setSelectedPublication] = useState(null);
	const [returnComment, setReturnComment] = useState('');
	const [lastNameError, setLastNameError] = useState('');
	const [firstNameError, setFirstNameError] = useState('');
	const [middleNameError, setMiddleNameError] = useState('');
	const [openHistoryDrawer, setOpenHistoryDrawer] = useState(false);
	const [openPlanHistoryDrawer, setOpenPlanHistoryDrawer] = useState(false);
	const [publicationsTransitionKey, setPublicationsTransitionKey] = useState(0);
	const [plansTransitionKey, setPlansTransitionKey] = useState(0);
	const [pubActionHistory, setPubActionHistory] = useState([]);
	const [pubHistoryPage, setPubHistoryPage] = useState(1);
	const [totalPubHistoryPages, setTotalPubHistoryPages] = useState(1);
	const [pubHistoryTransitionKey, setPubHistoryTransitionKey] = useState(0);
	const [planActionHistory, setPlanActionHistory] = useState([]);
	const [planHistoryPage, setPlanHistoryPage] = useState(1);
	const [totalPlanHistoryPages, setTotalPlanHistoryPages] = useState(1);
	const [planHistoryTransitionKey, setPlanHistoryTransitionKey] = useState(0);
	// Новое состояние для поиска по ФИО
	const [nameSearchQuery, setNameSearchQuery] = useState('');
	const [publicationTypes, setPublicationTypes] = useState([]);
	const [newTypeName, setNewTypeName] = useState('');
	const [newTypeDisplayName, setNewTypeDisplayName] = useState('');
	const [editingType, setEditingType] = useState(null);
	const [editTypeName, setEditTypeName] = useState('');
	const [editTypeDisplayName, setEditTypeDisplayName] = useState('');
	const [openEditTypeDialog, setOpenEditTypeDialog] = useState(false);

	// Функция сортировки и фильтрации статистики
	const sortAndFilterStatistics = (stats, query) => {
		if (!query.trim()) return stats;

		const normalizedQuery = query.trim().toLowerCase();

		return [...stats]
			.filter((user) =>
				user.full_name.toLowerCase().includes(normalizedQuery)
			)
			.sort((a, b) => {
				const aName = a.full_name.toLowerCase();
				const bName = b.full_name.toLowerCase();

				const aStartsWith = aName.startsWith(normalizedQuery);
				const bStartsWith = bName.startsWith(normalizedQuery);
				if (aStartsWith && !bStartsWith) return -1;
				if (!aStartsWith && bStartsWith) return 1;

				const aIndex = aName.indexOf(normalizedQuery);
				const bIndex = bName.indexOf(normalizedQuery);
				if (aIndex !== bIndex) return aIndex - bIndex;

				return aName.localeCompare(bName);
			});
	};

	// Эффект для автоматического закрытия уведомлений
	useEffect(() => {
		let errorTimer, successTimer;
		if (openError) errorTimer = setTimeout(() => setOpenError(false), 3000);
		if (openSuccess) successTimer = setTimeout(() => setOpenSuccess(false), 3000);
		return () => {
			if (errorTimer) clearTimeout(errorTimer);
			if (successTimer) clearTimeout(successTimer);
		};
	}, [openError, openSuccess]);

	// Валидация ФИО
	const validateNamePart = (value, fieldName) => {
		if (!value.trim()) return `${fieldName} обязательно для заполнения.`;
		if (!namePartRegex.test(value))
			return `${fieldName} должно начинаться с заглавной буквы, содержать только кириллицу и быть длиной не менее 2 символов.`;
		return '';
	};

	const validateFullName = (lastName, firstName, middleName) => {
		const fullName = `${lastName} ${firstName} ${middleName}`;
		if (!fullNameRegex.test(fullName))
			return 'ФИО должно быть в формате "Иванов Иван Иванович" (три слова с заглавной буквы, разделённые пробелами).';
		return '';
	};

	// Обработчики изменения полей ФИО
	const handleLastNameChange = (e) => {
		const value = e.target.value;
		setNewLastName(value);
		setLastNameError(validateNamePart(value, 'Фамилия'));
	};

	const handleFirstNameChange = (e) => {
		const value = e.target.value;
		setNewFirstName(value);
		setFirstNameError(validateNamePart(value, 'Имя'));
	};

	const handleMiddleNameChange = (e) => {
		const value = e.target.value;
		setNewMiddleName(value);
		setMiddleNameError(validateNamePart(value, 'Отчество'));
	};

	const fetchStatistics = async (year) => {
		setLoadingStatistics(true);
		try {
			const response = await axios.get('http://localhost:5000/admin_api/admin/statistics', {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: { year },
			});
			setStatistics(response.data);
		} catch (err) {
			console.error('Ошибка загрузки статистики:', err);
			setError('Не удалось загрузить статистику. Попробуйте позже.');
			setOpenError(true);
		} finally {
			setLoadingStatistics(false);
		}
	};

	const fetchPlanActionHistory = async (page, startDate = '', endDate = '') => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/plan-action-history`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: {
					page,
					per_page: 10,
					start_date: startDate || undefined,
					end_date: endDate || undefined,
				},
			});
			setPlanActionHistory(response.data.history);
			setTotalPlanHistoryPages(response.data.pages);
			setPlanHistoryTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки истории действий с планами:', err);
			setError('Не удалось загрузить историю действий с планами.');
			setOpenError(true);
		}
	};

	const fetchPublications = async (page) => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/publications`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: {
					page,
					per_page: 10,
					search: searchQuery,
					status: ['needs_review', 'returned_for_revision', 'published'].join(','),
					sort_status: statusFilter,
				},
			});
			setPublications(response.data.publications);
			setTotalPagesPublications(response.data.pages);
			setPublicationsTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки публикаций:', err);
			setError('Не удалось загрузить публикации. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const fetchPublicationTypes = async () => {
		try {
			const response = await axios.get('http://localhost:5000/admin_api/admin/publication-types', {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setPublicationTypes(response.data);
		} catch (err) {
			setError('Не удалось загрузить типы публикаций.');
			setOpenError(true);
		}
	};

	const handleAddType = async () => {
		if (!newTypeName.trim() || !newTypeDisplayName.trim()) {
			setError('Оба поля обязательны.');
			setOpenError(true);
			return;
		}
		try {
			const response = await axios.post('http://localhost:5000/admin_api/admin/publication-types', {
				name: newTypeName,
				display_name: newTypeDisplayName,
			}, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setPublicationTypes([...publicationTypes, response.data.type]);
			setNewTypeName('');
			setNewTypeDisplayName('');
			setSuccess('Тип добавлен!');
			setOpenSuccess(true);
		} catch (err) {
			setError(err.response?.data?.error || 'Не удалось добавить тип.');
			setOpenError(true);
		}
	};

	const handleEditType = (type) => {
		setEditingType(type);
		setEditTypeName(type.name);
		setEditTypeDisplayName(type.display_name);
		setOpenEditTypeDialog(true);
	};

	const handleUpdateType = async () => {
		if (!editTypeName.trim() || !editTypeDisplayName.trim()) {
			setError('Оба поля обязательны.');
			setOpenError(true);
			return;
		}
		try {
			const response = await axios.put(`http://localhost:5000/admin_api/admin/publication-types/${editingType.id}`, {
				name: editTypeName,
				display_name: editTypeDisplayName,
			}, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setPublicationTypes(publicationTypes.map(t => t.id === editingType.id ? response.data.type : t));
			setOpenEditTypeDialog(false);
			setSuccess('Тип обновлен!');
			setOpenSuccess(true);
		} catch (err) {
			setError(err.response?.data?.error || 'Не удалось обновить тип.');
			setOpenError(true);
		}
	};

	const handleDeleteType = async (typeId) => {
		if (!window.confirm('Вы уверены, что хотите удалить этот тип?')) return;
		try {
			await axios.delete(`http://localhost:5000/admin_api/admin/publication-types/${typeId}`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setPublicationTypes(publicationTypes.filter(t => t.id !== typeId));
			setSuccess('Тип удален!');
			setOpenSuccess(true);
		} catch (err) {
			setError(err.response?.data?.error || 'Не удалось удалить тип.');
			setOpenError(true);
		}
	};

	// Загрузка типов при монтировании
	useEffect(() => {
		fetchPublicationTypes();
	}, []);

	const fetchPlans = async (page) => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/plans/needs-review?page=${page}&per_page=10`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setPlans(response.data.plans);
			setTotalPagesPlans(response.data.pages);
			setPlansTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки планов:', err);
			setError('Не удалось загрузить планы. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const fetchPubActionHistory = async (page, startDate = '', endDate = '') => {
		try {
			const response = await axios.get('http://localhost:5000/admin_api/admin/publication-action-history', {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: {
					page,
					per_page: 10,
					start_date: startDate || undefined,
					end_date: endDate || undefined,
				},
			});
			setPubActionHistory(response.data.history);
			setTotalPubHistoryPages(response.data.pages);
			setPubHistoryTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки истории действий с публикациями:', err);
			setError('Не удалось загрузить историю действий с публикациями.');
			setOpenError(true);
		}
	};

	// Инициализация данных
	useEffect(() => {
		if (!isAuthenticated || user.role !== 'manager') navigate('/login');
		setLoadingInitial(true);
		Promise.all([
			fetchPublications(currentPagePublications),
			fetchPlans(currentPagePlans),
			fetchPubActionHistory(pubHistoryPage, dateFilterRange.start, dateFilterRange.end),
			fetchPlanActionHistory(planHistoryPage, dateFilterRange.start, dateFilterRange.end),
		]).finally(() => setLoadingInitial(false));
	}, [isAuthenticated, user, navigate]);

	// Обновление истории публикаций
	useEffect(() => {
		fetchPubActionHistory(pubHistoryPage, dateFilterRange.start, dateFilterRange.end);
	}, [pubHistoryPage, dateFilterRange.start, dateFilterRange.end]);

	// Обновление публикаций
	useEffect(() => {
		fetchPublications(currentPagePublications);
	}, [currentPagePublications, searchQuery, statusFilter]);

	// Обновление планов
	useEffect(() => {
		fetchPlans(currentPagePlans);
	}, [currentPagePlans]);

	// Загрузка статистики
	useEffect(() => {
		if (value === 1) {
			fetchStatistics(selectedYear);
		}
	}, [value, selectedYear]);

	// Обработчики
	const handleTabChange = (event, newValue) => setValue(newValue);

	const handleSearchChange = (e) => {
		setSearchQuery(e.target.value);
		setCurrentPagePublications(1);
	};

	const handleOpenPlanHistoryDrawer = () => {
		setOpenPlanHistoryDrawer(true);
		fetchPlanActionHistory(planHistoryPage);
	};

	const handleClosePlanHistoryDrawer = () => setOpenPlanHistoryDrawer(false);

	const handlePlanHistoryPageChange = (event, value) => {
		setPlanHistoryPage(value);
		fetchPlanActionHistory(value, dateFilterRange.start, dateFilterRange.end);
	};

	const handleStatusFilterChange = (e) => {
		setStatusFilter(e.target.value);
		setCurrentPagePublications(1);
	};

	const handlePageChangePublications = (event, value) => setCurrentPagePublications(value);

	const handlePageChangePlans = (event, value) => setCurrentPagePlans(value);

	const handleHistoryPageChange = (event, value) => {
		setPubHistoryPage(value);
		fetchPubActionHistory(value, dateFilterRange.start, dateFilterRange.end);
	};

	const handleDownload = async (fileUrl, fileName) => {
		if (!fileUrl || typeof fileUrl !== 'string' || fileUrl.trim() === '') {
			setError('Некорректный URL файла. Обратитесь к администратору.');
			setOpenError(true);
			return;
		}
		const normalizedFileUrl = fileUrl.startsWith('/') ? fileUrl : `/${fileUrl}`;
		const fullUrl = `http://localhost:5000${normalizedFileUrl}`;
		try {
			const response = await axios.get(fullUrl, {
				responseType: 'blob',
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			const blob = new Blob([response.data]);
			const url = window.URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.href = url;
			link.download = fileName || normalizedFileUrl.split('/').pop();
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			window.URL.revokeObjectURL(url);
		} catch (err) {
			setError(err.response ? `Ошибка сервера: ${err.response.status}` : 'Не удалось скачать файл.');
			setOpenError(true);
		}
	};

	const handleEditClick = (publication) => {
		setEditPublication(publication);
		setEditTitle(publication.title);
		setEditAuthors(publication.authors);
		setEditYear(publication.year);
		setEditType(publication.type);
		setEditStatus(publication.status);
		setEditFile(null);
		setOpenEditDialog(true);
	};

	const handleEditCancel = () => {
		setOpenEditDialog(false);
		setEditPublication(null);
		setEditTitle('');
		setEditAuthors('');
		setEditYear('');
		setEditType('article');
		setEditStatus('needs_review');
		setEditFile(null);
		setError('');
		setSuccess('');
	};

	const handleEditSubmit = async (event) => {
		event.preventDefault();
		if (!editTitle.trim() || !editAuthors.trim() || !editYear || editYear < 1900 || editYear > new Date().getFullYear()) {
			setError('Проверьте поля: название, авторы и год должны быть заполнены корректно.');
			setOpenError(true);
			return;
		}
		const formData = new FormData();
		formData.append('title', editTitle);
		formData.append('authors', editAuthors);
		formData.append('year', editYear);
		formData.append('type', editType);
		formData.append('status', editStatus);
		if (editFile) formData.append('file', editFile);

		try {
			await axios.put(`http://localhost:5000/admin_api/admin/publications/${editPublication.id}`, formData, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken, 'Content-Type': 'multipart/form-data' },
			});
			setSuccess('Публикация успешно обновлена!');
			setOpenSuccess(true);
			fetchPublications(currentPagePublications);
			fetchPubActionHistory(pubHistoryPage);
			handleEditCancel();
		} catch (err) {
			setError('Не удалось обновить публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleDeletePlanClick = (publication) => {
		setPublicationToDelete(publication);
		setOpenDeleteDialog(true);
	};

	const handleDeletePlanConfirm = async () => {
		if (publicationToDelete) {
			try {
				await axios.delete(`http://localhost:5000/admin_api/admin/publications/${publicationToDelete.id}`, {
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				});
				setSuccess('Публикация успешно удалена!');
				setOpenSuccess(true);
				fetchPublications(currentPagePublications);
				fetchPubActionHistory(pubHistoryPage);
				setOpenDeleteDialog(false);
				setPublicationToDelete(null);
			} catch (err) {
				setError('Не удалось удалить публикацию. Попробуйте позже.');
				setOpenError(true);
			}
		}
	};

	const handleApprovePlan = async (plan) => {
		try {
			await axios.post(`http://localhost:5000/admin_api/admin/plans/${plan.id}/approve`, {}, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setSuccess('План утверждён!');
			setOpenSuccess(true);
			fetchPlans(currentPagePlans);
			fetchPlanActionHistory(planHistoryPage);
		} catch (err) {
			setError('Не удалось утвердить план. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleOpenReturnDialog = (plan) => {
		setSelectedPlan(plan);
		setReturnComment('');
		setOpenReturnDialog(true);
	};

	const handleReturnForRevision = async () => {
		if (!returnComment.trim()) {
			setError('Комментарий обязателен.');
			setOpenError(true);
			return;
		}
		try {
			await axios.post(
				`http://localhost:5000/admin_api/admin/plans/${selectedPlan.id}/return-for-revision`,
				{ comment: returnComment },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('План возвращён на доработку!');
			setOpenSuccess(true);
			fetchPlans(currentPagePlans);
			fetchPlanActionHistory(planHistoryPage);
			setOpenReturnDialog(false);
		} catch (err) {
			setError('Не удалось вернуть план. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleApprovePublication = async (pub) => {
		try {
			await axios.put(
				`http://localhost:5000/admin_api/admin/publications/${pub.id}`,
				{ status: 'published' },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('Публикация утверждена!');
			setOpenSuccess(true);
			fetchPublications(currentPagePublications);
			fetchPubActionHistory(pubHistoryPage);
		} catch (err) {
			setError('Не удалось утвердить публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleReturnPublicationForRevision = async (pubId, comment) => {
		try {
			await axios.put(
				`http://localhost:5000/admin_api/admin/publications/${pubId}`,
				{ status: 'returned_for_revision', return_comment: comment },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('Публикация возвращена на доработку!');
			setOpenSuccess(true);
			fetchPublications(currentPagePublications);
			fetchPubActionHistory(pubHistoryPage);
			setOpenReturnDialog(false);
		} catch (err) {
			setError('Не удалось вернуть публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleOpenHistoryDrawer = () => {
		setOpenHistoryDrawer(true);
		fetchPubActionHistory(pubHistoryPage);
	};

	const handleCloseHistoryDrawer = () => setOpenHistoryDrawer(false);

	const UserStatisticsChart = ({ user, publicationTypes }) => {
		// Шаг 1: Безопасная проверка данных
		const safeUser = user || { plan: {}, actual: {}, username: '' };
		const plan = safeUser.plan || {};
		const actual = safeUser.actual || {};

		// Шаг 2: Проверка наличия плана
		const hasPlan = Object.values(plan).some((value) => value > 0);

		// Если плана нет, показываем сообщение
		if (!hasPlan) {
			return (
				<Box sx={{ mt: 2, textAlign: 'center' }}>
					<Typography sx={{ color: '#6E6E73' }}>
						У пользователя не создан или не утверждён план на этот год.
					</Typography>
				</Box>
			);
		}

		// Шаг 3: Определяем типы, присутствующие в плане
		const planTypes = Object.keys(plan).filter((type) => plan[type] > 0);

		// Шаг 4: Формируем данные для диаграммы и текстового блока
		const data = [
			{
				name: 'Итог',
				План: planTypes.reduce((sum, type) => sum + (plan[type] || 0), 0),
				Факт: planTypes.reduce((sum, type) => sum + (actual[type] || 0), 0),
				planDetails: planTypes.reduce((obj, type) => {
					const typeRecord = publicationTypes.find((t) => t.name === type);
					obj[typeRecord ? typeRecord.display_name : type] = plan[type] || 0;
					return obj;
				}, {}),
				actualDetails: planTypes.reduce((obj, type) => {
					const typeRecord = publicationTypes.find((t) => t.name === type);
					obj[typeRecord ? typeRecord.display_name : type] = actual[type] || 0;
					return obj;
				}, {}),
			},
		];

		// Шаг 5: Вычисляем прогресс выполнения плана
		const totalPlan = data[0].План;
		const totalActual = data[0].Факт;
		const progress = totalPlan > 0 ? (totalActual / totalPlan) * 100 : 0;

		return (
			<Box
				sx={{
					mt: 2,
					height: 200,
					display: 'flex',
					gap: 2,
					alignItems: 'center',
				}}
			>
				{/* Контейнер для диаграммы */}
				<Box sx={{ width: '40%', height: '100%', minWidth: 200 }}>
					<ResponsiveContainer width="100%" height="100%">
						<BarChart
							data={data}
							margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
						>
							<CartesianGrid strokeDasharray="3 3" />
							<XAxis dataKey="name" />
							<YAxis allowDecimals={false} />
							<Legend />
							<Bar dataKey="План" fill="#0071E3" barSize={20} />
							<Bar dataKey="Факт" fill="#00A94F" barSize={20} />
						</BarChart>
					</ResponsiveContainer>
				</Box>

				{/* Контейнер для прогресса и текстового блока */}
				<Box sx={{ width: '60%' }}>
					<Typography sx={{ mb: 1, color: '#1D1D1F' }}>
						Прогресс выполнения:
					</Typography>
					<Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
						<LinearProgress
							variant="determinate"
							value={Math.min(progress, 100)}
							sx={{
								height: 8,
								borderRadius: 4,
								flexGrow: 1,
								backgroundColor: '#E5E5EA',
								'& .MuiLinearProgress-bar': {
									backgroundColor: progress > 100 ? '#FF9500' : '#34C759',
								},
							}}
						/>
						<Typography
							variant="body2"
							sx={{
								minWidth: '50px',
								textAlign: 'right',
								color: progress > 100 ? '#FF9500' : '#1D1D1F',
							}}
						>
							{Math.round(progress)}%
						</Typography>
					</Box>

					<Box
						sx={{
							display: 'flex',
							gap: 4,
							backgroundColor: '#FFFFFF',
							border: '1px solid #D1D1D6',
							borderRadius: '8px',
							p: 2,
							boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
							transform: 'translateY(-2px)',
						}}
					>
						<Box sx={{ flex: 1 }}>
							<Typography sx={{ fontWeight: 600, color: '#0071E3', mb: 1 }}>
								План
							</Typography>
							{Object.entries(data[0].planDetails).map(([key, value]) => (
								<Typography key={key} sx={{ color: '#1D1D1F' }}>
									{key}: {value}
								</Typography>
							))}
						</Box>
						<Box sx={{ flex: 1 }}>
							<Typography sx={{ fontWeight: 600, color: '#00A94F', mb: 1 }}>
								Факт
							</Typography>
							{Object.entries(data[0].actualDetails).map(([key, value]) => (
								<Typography key={key} sx={{ color: '#1D1D1F' }}>
									{key}: {value}
								</Typography>
							))}
						</Box>
					</Box>
				</Box>
			</Box>
		);
	};


	return (
		<>
			{animationStyles}
			<Container maxWidth="lg" sx={{ mt: 8, mb: 4 }}>
				<AppleCard elevation={4} sx={{ p: 4, borderRadius: '16px', backgroundColor: '#FFFFFF' }}>
					<Typography variant="h4" sx={{ color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
						Панель управляющего
					</Typography>
					<Tabs
						value={value}
						onChange={handleTabChange}
						centered
						sx={{
							mb: 4,
							'& .MuiTab-root': { color: '#6E6E73', fontWeight: 600 },
							'& .MuiTab-root.Mui-selected': { color: '#0071E3' },
							'& .MuiTabs-indicator': { backgroundColor: '#0071E3' },
						}}
					>
						<Tab label="Работы на проверке" />
						<Tab label="Статистика по кафедре" />
						<Tab label="Регистрация пользователей" />
						<Tab label="Работа с планами" />
						<Tab label="Управление типами" />
					</Tabs>

					{loadingInitial ? (
						<Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
							<CircularProgress sx={{ color: '#0071E3' }} />
						</Box>
					) : (
						<>
							{value === 0 && (
								<>
									<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
										Работы на проверке
									</Typography>
									<AppleCard sx={{ mt: 2, mb: 2, p: 2, backgroundColor: '#F5F5F7', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
										<AppleTextField
											fullWidth
											label="Поиск по названию, авторам или году"
											value={searchQuery}
											onChange={handleSearchChange}
											margin="normal"
											variant="outlined"
										/>
										<Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 2 }}>
											<AppleTextField
												select
												label="Фильтр по статусу"
												value={statusFilter}
												onChange={handleStatusFilterChange}
												margin="normal"
												variant="outlined"
												sx={{ width: '200px' }}
											>
												<MenuItem value="needs_review">На проверке</MenuItem>
												<MenuItem value="returned_for_revision">Отправлено на доработку</MenuItem>
												<MenuItem value="published">Опубликовано</MenuItem>
											</AppleTextField>
											<AppleButton startIcon={<HistoryIcon />} onClick={handleOpenHistoryDrawer} sx={{ height: 'fit-content', marginTop: '6px' }}>
												Показать историю
											</AppleButton>
										</Box>
									</AppleCard>
									<AppleTable sx={{ mt: 2, boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
										<TableHead>
											<TableRow sx={{ backgroundColor: '#0071E3' }}>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', borderRadius: '12px 0 0 0' }}>ID</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Название</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Авторы</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Год</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Тип</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Статус</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Пользователь</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', textAlign: 'center', borderRadius: '0 12px 0 0' }}>
													Действия
												</TableCell>
											</TableRow>
										</TableHead>
										<Fade in={true} timeout={500} key={publicationsTransitionKey}>
											<TableBody>
												{publications.length > 0 ? (
													publications.map((pub) => (
														<TableRow
															key={pub.id}
															sx={{ '&:hover': { backgroundColor: '#F5F5F7', transition: 'background-color 0.3s ease' } }}
														>
															<TableCell sx={{ color: '#1D1D1F' }}>{pub.id}</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>
																<Typography
																	sx={{
																		color: '#0071E3',
																		textDecoration: 'underline',
																		cursor: 'pointer',
																		'&:hover': { textDecoration: 'none' },
																	}}
																	onClick={() => navigate(`/publication/${pub.id}`)}
																>
																	{pub.title}
																</Typography>
															</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>{pub.authors}</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>{pub.year}</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>
																{publicationTypes.find(t => t.name === pub.type.name)?.display_name || 'Неизвестный тип'}
															</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>
																<StatusChip status={pub.status} role={user.role} />
															</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>{pub.user?.full_name || 'Не указан'}</TableCell>
															<TableCell sx={{ textAlign: 'center' }}>
																<Box sx={{ display: 'flex', justifyContent: 'center', gap: 1 }}>
																	{pub.file_url && pub.file_url.trim() !== '' && (
																		<IconButton
																			aria-label="download"
																			onClick={() => handleDownload(pub.file_url, pub.file_url.split('/').pop())}
																			sx={{
																				color: '#0071E3',
																				borderRadius: '8px',
																				'&:hover': { color: '#FFFFFF', backgroundColor: '#0071E3', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)' },
																			}}
																		>
																			<DownloadIcon />
																		</IconButton>
																	)}
																</Box>
															</TableCell>
														</TableRow>
													))
												) : (
													<TableRow>
														<TableCell colSpan={8} sx={{ textAlign: 'center', color: '#6E6E73' }}>
															Нет публикаций с указанными статусами.
														</TableCell>
													</TableRow>
												)}
											</TableBody>
										</Fade>
									</AppleTable>
									<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
										<Pagination
											count={totalPagesPublications}
											page={currentPagePublications}
											onChange={handlePageChangePublications}
											color="primary"
											sx={{
												'& .MuiPaginationItem-root': {
													borderRadius: 20,
													transition: 'all 0.3s ease',
													'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
													'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
												},
											}}
										/>
									</Box>
									<Drawer
										anchor="right"
										open={openHistoryDrawer}
										onClose={handleCloseHistoryDrawer}
										sx={{
											'& .MuiDrawer-paper': {
												width: 600,
												backgroundColor: '#FFFFFF',
												boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
												borderRadius: '16px 0 0 16px',
											},
										}}
									>
										<Box sx={{ p: 2, pr: 4 }}>
											<Typography variant="h6" sx={{ color: '#1D1D1F', fontWeight: 600, mb: 5 }}>
												История действий с публикациями
											</Typography>
											<Box sx={{ display: 'flex', gap: 2, mt: 2, mb: 2 }}>
												<AppleTextField
													label="Дата начала"
													type="date"
													value={dateFilterRange.start}
													onChange={(e) => {
														setDateFilterRange((prev) => ({ ...prev, start: e.target.value }));
														setPubHistoryPage(1);
													}}
													InputLabelProps={{ shrink: true }}
													sx={{ width: '200px' }}
												/>
												<AppleTextField
													label="Дата окончания"
													type="date"
													value={dateFilterRange.end}
													onChange={(e) => {
														setDateFilterRange((prev) => ({ ...prev, end: e.target.value }));
														setPubHistoryPage(1);
													}}
													InputLabelProps={{ shrink: true }}
													sx={{ width: '200px' }}
												/>
											</Box>
											{pubActionHistory.length > 0 ? (
												<>
													<AppleTable
														sx={{
															mt: 2,
															overflowX: 'auto',
															minWidth: '100%',
															backgroundColor: '#F5F5F7',
															boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
															borderRadius: '8px',
														}}
													>
														<TableHead>
															<TableRow sx={{ backgroundColor: '#0071E3', borderRadius: '8px 8px 0 0' }}>
																<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '200px', borderTopLeftRadius: '8px' }}>
																	Название
																</TableCell>
																<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '120px' }}>
																	Действие
																</TableCell>
																<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '140px', borderTopRightRadius: '8px' }}>
																	Время
																</TableCell>
															</TableRow>
														</TableHead>
														<Fade in={true} timeout={500} key={pubHistoryTransitionKey}>
															<TableBody>
																{pubActionHistory.map((action) => (
																	<TableRow key={`${action.id}-${action.timestamp}`}>
																		<TableCell sx={{ minWidth: '200px', whiteSpace: 'normal', wordWrap: 'break-word' }}>
																			<Typography
																				sx={{
																					color: '#0071E3',
																					textDecoration: 'underline',
																					cursor: 'pointer',
																					'&:hover': { textDecoration: 'none' },
																				}}
																				onClick={() => {
																					handleCloseHistoryDrawer();
																					navigate(`/publication/${action.id}`);
																				}}
																			>
																				{action.title}
																			</Typography>
																		</TableCell>
																		<TableCell sx={{ minWidth: '120px' }}>
																			{action.action_type === 'approved' ? 'Утверждено' : 'Возвращено на доработку'}
																		</TableCell>
																		<TableCell sx={{ minWidth: '140px' }}>
																			{new Date(action.timestamp).toLocaleString('ru-RU')}
																		</TableCell>
																	</TableRow>
																))}
															</TableBody>
														</Fade>
													</AppleTable>
													<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
														<Pagination
															count={totalPubHistoryPages}
															page={pubHistoryPage}
															onChange={handleHistoryPageChange}
															color="primary"
															sx={{
																'& .MuiPaginationItem-root': {
																	borderRadius: 20,
																	'&:hover': { backgroundColor: 'grey.100' },
																	'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
																},
															}}
														/>
													</Box>
												</>
											) : (
												<Typography sx={{ mt: 2, color: '#6E6E73' }}>
													Нет записей в истории действий с публикациями.
												</Typography>
											)}
										</Box>
									</Drawer>
								</>
							)}

							{value === 1 && (
								<Box>
									<Typography
										variant="h5"
										gutterBottom
										sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}
									>
										Статистика по кафедре
									</Typography>
									<Box sx={{ display: 'flex', justifyContent: 'center', gap: 2, mb: 4 }}>
										<AppleTextField
											label="Год"
											type="number"
											value={selectedYear}
											onChange={(e) => {
												const value = e.target.value;
												if (value === '') {
													setSelectedYear('');
													return;
												}
												const numValue = parseInt(value, 10);
												if (!isNaN(numValue) && numValue >= 1900 && numValue <= new Date().getFullYear() + 1) {
													setSelectedYear(numValue);
												}
											}}
											onBlur={() => {
												if (!selectedYear || selectedYear < 1900 || selectedYear > new Date().getFullYear() + 1) {
													setSelectedYear(new Date().getFullYear());
												}
											}}
											InputProps={{
												inputProps: { min: 1900, max: new Date().getFullYear() + 1 },
											}}
											sx={{
												width: 200,
												'& .MuiOutlinedInput-root': {
													height: '40px',
													padding: '0 14px',
													'& input': { padding: '12px 0' },
												},
											}}
										/>
										<AppleTextField
											label="Поиск по ФИО"
											value={nameSearchQuery}
											onChange={(e) => setNameSearchQuery(e.target.value)}
											sx={{
												width: 300,
												'& .MuiOutlinedInput-root': {
													height: '40px',
													padding: '0 14px',
													'& input': { padding: '12px 0' },
												},
												'& .MuiInputLabel-outlined': {
													transform: 'translate(14px, 9px) scale(1)',
												},
												'& .MuiInputLabel-outlined.Mui-focused': {
													transform: 'translate(14px, -6px) scale(0.75)',
												},
												'& .MuiInputLabel-outlined.MuiFormLabel-filled': {
													transform: 'translate(14px, -6px) scale(0.75)',
												},
											}}
											variant="outlined"
											placeholder="Введите ФИО"
										/>
									</Box>
									{loadingStatistics ? (
										<Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
											<CircularProgress sx={{ color: '#0071E3' }} />
										</Box>
									) : statistics.length > 0 ? (
										<TransitionGroup>
											{sortAndFilterStatistics(statistics, nameSearchQuery).map((user) => (
												<CSSTransition key={user.user_id} timeout={300} classNames="accordion">
													<Accordion
														defaultExpanded={false}
														sx={{
															mb: 2,
															borderRadius: '16px',
															boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
															'&:before': { display: 'none' },
														}}
													>
														<AccordionSummary
															expandIcon={<ExpandMoreIcon sx={{ color: '#0071E3' }} />}
															sx={{
																backgroundColor: '#F5F5F7',
																borderRadius: '16px',
																'& .MuiAccordionSummary-content': { alignItems: 'center' },
															}}
														>
															<Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
																<Typography variant="h6" sx={{ color: '#1D1D1F', fontWeight: 600 }}>
																	{user.full_name || 'Пользователь не указан'}
																</Typography>
																<Typography variant="h6" sx={{ color: '#6E6E73', fontWeight: 400 }}>
																	({user.username || 'логин отсутствует'})
																</Typography>
															</Box>
														</AccordionSummary>
														<AccordionDetails sx={{ backgroundColor: '#FFFFFF', borderRadius: '0 0 16px 16px' }}>
															<UserStatisticsChart user={user} publicationTypes={publicationTypes} />
														</AccordionDetails>
													</Accordion>
												</CSSTransition>
											))}
										</TransitionGroup>
									) : (
										<Typography sx={{ textAlign: 'center', color: '#6E6E73', mt: 2 }}>
											Нет данных для выбранного года.
										</Typography>
									)}
								</Box>
							)}

							{value === 2 && (
								<>
									<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
										Регистрация нового пользователя
									</Typography>
									<AppleCard sx={{ maxWidth: 'none', mx: 'auto', mt: 2, p: 4 }}>
										<form onSubmit={(e) => e.preventDefault()}>
											<AppleTextField
												fullWidth
												label="Фамилия"
												value={newLastName}
												onChange={handleLastNameChange}
												margin="normal"
												variant="outlined"
												autoComplete="family-name"
												error={!!lastNameError}
												helperText={lastNameError}
											/>
											<AppleTextField
												fullWidth
												label="Имя"
												value={newFirstName}
												onChange={handleFirstNameChange}
												margin="normal"
												variant="outlined"
												autoComplete="given-name"
												error={!!firstNameError}
												helperText={firstNameError}
											/>
											<AppleTextField
												fullWidth
												label="Отчество"
												value={newMiddleName}
												onChange={handleMiddleNameChange}
												margin="normal"
												variant="outlined"
												autoComplete="additional-name"
												error={!!middleNameError}
												helperText={middleNameError}
											/>
											<AppleTextField
												fullWidth
												label="Логин"
												value={newUsername}
												onChange={(e) => setNewUsername(e.target.value)}
												margin="normal"
												variant="outlined"
												autoComplete="username"
											/>
											<AppleTextField
												fullWidth
												label="Пароль"
												type={showPassword ? 'text' : 'password'}
												value={newPassword}
												onChange={(e) => setNewPassword(e.target.value)}
												margin="normal"
												variant="outlined"
												autoComplete="new-password"
												InputProps={{
													endAdornment: (
														<IconButton onClick={() => setShowPassword(!showPassword)}>
															{showPassword ? <VisibilityOff /> : <Visibility />}
														</IconButton>
													),
												}}
											/>
											<Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
												<AppleButton
													startIcon={<RefreshIcon />}
													onClick={async () => {
														const lastNameErr = validateNamePart(newLastName, 'Фамилия');
														const firstNameErr = validateNamePart(newFirstName, 'Имя');
														const middleNameErr = validateNamePart(newMiddleName, 'Отчество');
														const fullNameErr = validateFullName(newLastName, newFirstName, newMiddleName);

														if (lastNameErr || firstNameErr || middleNameErr || fullNameErr) {
															setLastNameError(lastNameErr);
															setFirstNameError(firstNameErr);
															setMiddleNameError(middleNameErr);
															if (fullNameErr) {
																setError(fullNameErr);
																setOpenError(true);
															}
															return;
														}

														const generateUsername = async () => {
															const transliterate = (text) => {
																const ruToEn = {
																	а: 'a', б: 'b', в: 'v', г: 'g', д: 'd',
																	е: 'e', ё: 'e', ж: 'zh', з: 'z', и: 'i',
																	й: 'y', к: 'k', л: 'l', м: 'm', н: 'n',
																	о: 'o', п: 'p', р: 'r', с: 's', т: 't',
																	у: 'u', ф: 'f', х: 'kh', ц: 'ts', ч: 'ch',
																	ш: 'sh', щ: 'sch', ъ: '', ы: 'y', ь: '',
																	э: 'e', ю: 'yu', я: 'ya'
																};
																return text.toLowerCase().split('').map(char => ruToEn[char] || char).join('');
															};
															const capitalizeFirstLetter = (string) =>
																string ? string.charAt(0).toUpperCase() + string.slice(1) : '';
															const baseUsername = `${capitalizeFirstLetter(transliterate(newLastName))}${capitalizeFirstLetter(transliterate(newFirstName[0]))}${capitalizeFirstLetter(transliterate(newMiddleName[0]))}`;
															let generatedUsername = baseUsername;
															let suffix = 1;

															while (true) {
																try {
																	const response = await axios.post(
																		'http://localhost:5000/admin_api/admin/check-username',
																		{ username: generatedUsername },
																		{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
																	);
																	if (!response.data.exists) break;
																	generatedUsername = `${baseUsername}${suffix}`;
																	suffix++;
																} catch (err) {
																	setError('Ошибка проверки логина.');
																	setOpenError(true);
																	return null;
																}
															}
															return generatedUsername;
														};

														const generatedUsername = await generateUsername();
														if (!generatedUsername) return;

														try {
															const response = await axios.get('http://localhost:5000/admin_api/admin/generate-password', {
																withCredentials: true,
																headers: { 'X-CSRFToken': csrfToken },
															});
															setNewUsername(generatedUsername);
															setNewPassword(response.data.password);
															setSuccess('Логин и пароль успешно сгенерированы.');
															setOpenSuccess(true);
														} catch (err) {
															setError('Ошибка генерации пароля.');
															setOpenError(true);
														}
													}}
												>
													Сгенерировать логин и пароль
												</AppleButton>
												<AppleButton
													startIcon={<ContentCopyIcon />}
													onClick={() => {
														navigator.clipboard.writeText(`Логин: ${newUsername}\nПароль: ${newPassword}`);
														setSuccess('Данные скопированы в буфер обмена!');
														setOpenSuccess(true);
													}}
												>
													Скопировать в буфер обмена
												</AppleButton>
												<AppleButton
													type="submit"
													onClick={async () => {
														const lastNameErr = validateNamePart(newLastName, 'Фамилия');
														const firstNameErr = validateNamePart(newFirstName, 'Имя');
														const middleNameErr = validateNamePart(newMiddleName, 'Отчество');
														const fullNameErr = validateFullName(newLastName, newFirstName, newMiddleName);

														if (lastNameErr || firstNameErr || middleNameErr || fullNameErr) {
															setLastNameError(lastNameErr);
															setFirstNameError(firstNameErr);
															setMiddleNameError(middleNameErr);
															if (fullNameErr) {
																setError(fullNameErr);
																setOpenError(true);
															}
															return;
														}

														if (!newUsername.trim() || !newPassword.trim()) {
															setError('Логин и пароль обязательны.');
															setOpenError(true);
															return;
														}

														try {
															await axios.post(
																'http://localhost:5000/admin_api/admin/register',
																{
																	username: newUsername,
																	password: newPassword,
																	last_name: newLastName,
																	first_name: newFirstName,
																	middle_name: newMiddleName,
																},
																{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
															);
															setSuccess('Пользователь успешно зарегистрирован!');
															setOpenSuccess(true);
															setNewLastName('');
															setNewFirstName('');
															setNewMiddleName('');
															setNewUsername('');
															setNewPassword('');
															setLastNameError('');
															setFirstNameError('');
															setMiddleNameError('');
														} catch (err) {
															setError(err.response?.data?.error || 'Не удалось зарегистрировать пользователя.');
															setOpenError(true);
														}
													}}
												>
													Создать
												</AppleButton>
											</Box>
											<Collapse in={openError}>
												{error && (
													<Alert
														severity="error"
														sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#FFF1F0', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
														onClose={() => setOpenError(false)}
													>
														{error}
													</Alert>
												)}
											</Collapse>
											<Collapse in={openSuccess}>
												{success && (
													<Alert
														severity="success"
														sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#E7F8E7', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
														onClose={() => setOpenSuccess(false)}
													>
														{success}
													</Alert>
												)}
											</Collapse>
										</form>
									</AppleCard>
								</>
							)}

							{value === 3 && (
								<Box sx={{ mt: 4 }}>
									<Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', mb: 2, position: 'relative' }}>
										<Typography variant="h5" sx={{ color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
											Работа с планами
										</Typography>
										<AppleButton
											startIcon={<HistoryIcon />}
											onClick={handleOpenPlanHistoryDrawer}
											sx={{ position: 'absolute', right: 16 }}
										>
											Показать историю
										</AppleButton>
									</Box>
									{plans.length > 0 ? (
										plans.map((plan) => {
											const entriesByType = plan.entries.reduce((acc, entry) => {
												const type = entry.type || 'unknown';
												if (!acc[type]) {
													acc[type] = { count: 0, type };
												}
												acc[type].count += 1;
												return acc;
											}, {});
											const groupedEntries = Object.values(entriesByType);

											return (
												<Accordion
													key={plan.id}
													sx={{ mb: 2, borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}
												>
													<AccordionSummary expandIcon={<ExpandMoreIcon />}>
														<Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
															<Box>
																<Typography variant="h6" sx={{ color: '#1D1D1F', whiteSpace: 'nowrap' }}>
																	План на {plan.year} год
																</Typography>
																<Typography variant="body2" sx={{ color: '#6E6E73', mt: 0.5 }}>
																	{plan.user && plan.user.full_name
																		? `${plan.user.full_name} (${plan.user.username || 'логин отсутствует'})`
																		: 'Пользователь не указан'}
																</Typography>
															</Box>
															<StatusChip status={plan.status} role={user.role} />
														</Box>
													</AccordionSummary>
													<AccordionDetails>
														<PlanTable>
															<TableHead>
																<TableRow>
																	<TableCell>Планируемое количество</TableCell>
																	<TableCell>Тип</TableCell>
																</TableRow>
															</TableHead>
															<Fade in={true} timeout={500} key={plansTransitionKey}>
																<TableBody>
																	{groupedEntries.length > 0 ? (
																		groupedEntries.map((group, index) => (
																			<TableRow key={index}>
																				<TableCell sx={{ padding: '16px' }}>{group.count}</TableCell>
																				<TableCell sx={{ color: '#1D1D1F' }}>
																					{publicationTypes.find((t) => t.name === group.type.name)?.display_name || 'Не указано'}
																				</TableCell>
																			</TableRow>
																		))
																	) : (
																		<TableRow>
																			<TableCell colSpan={2} sx={{ textAlign: 'center', color: '#6E6E73' }}>
																				Нет записей в плане.
																			</TableCell>
																		</TableRow>
																	)}
																</TableBody>
															</Fade>
														</PlanTable>
														{plan.return_comment && (
															<Typography
																sx={{ mt: 2, color: '#000000', fontWeight: 600, display: 'flex', alignItems: 'center', gap: 1 }}
															>
																<WarningAmberIcon sx={{ color: '#FF3B30' }} />
																Комментарий при возврате: {plan.return_comment}
															</Typography>
														)}
														{plan.status === 'needs_review' && (
															<Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
																<GreenButton startIcon={<CheckIcon />} onClick={() => handleApprovePlan(plan)}>
																	Утвердить
																</GreenButton>
																<AppleButton startIcon={<ReplayIcon />} onClick={() => handleOpenReturnDialog(plan)}>
																	На доработку
																</AppleButton>
															</Box>
														)}
													</AccordionDetails>
												</Accordion>
											);
										})
									) : (
										<Typography sx={{ textAlign: 'center', color: '#6E6E73', mt: 2 }}>
											Нет планов для проверки.
										</Typography>
									)}
									<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
										<Pagination
											count={totalPagesPlans}
											page={currentPagePlans}
											onChange={handlePageChangePlans}
											color="primary"
											sx={{
												'& .MuiPaginationItem-root': {
													borderRadius: 20,
													'&:hover': { backgroundColor: 'grey.100' },
													'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
												},
											}}
										/>
									</Box>
									<Drawer
										anchor="right"
										open={openPlanHistoryDrawer}
										onClose={handleClosePlanHistoryDrawer}
										sx={{
											'& .MuiDrawer-paper': {
												width: 600,
												backgroundColor: '#FFFFFF',
												boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
												borderRadius: '16px 0 0 16px',
											},
										}}
									>
										<Box sx={{ p: 2, pr: 4 }}>
											<Typography variant="h6" sx={{ color: '#1D1D1F', fontWeight: 600, mb: 5 }}>
												История действий с планами
											</Typography>
											<Box sx={{ display: 'flex', gap: 2, mt: 2, mb: 2 }}>
												<AppleTextField
													label="Дата начала"
													type="date"
													value={dateFilterRange.start}
													onChange={(e) => {
														setDateFilterRange((prev) => ({ ...prev, start: e.target.value }));
														setPlanHistoryPage(1);
													}}
													InputLabelProps={{ shrink: true }}
													sx={{ width: '200px' }}
												/>
												<AppleTextField
													label="Дата окончания"
													type="date"
													value={dateFilterRange.end}
													onChange={(e) => {
														setDateFilterRange((prev) => ({ ...prev, end: e.target.value }));
														setPlanHistoryPage(1);
													}}
													InputLabelProps={{ shrink: true }}
													sx={{ width: '200px' }}
												/>
											</Box>
											{planActionHistory.length > 0 ? (
												<>
													<AppleTable
														sx={{
															mt: 2,
															backgroundColor: '#F5F5F7',
															boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
															borderRadius: '8px',
														}}
													>
														<TableHead>
															<TableRow sx={{ backgroundColor: '#0071E3', borderRadius: '8px 8px 0 0' }}>
																<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '150px', borderTopLeftRadius: '8px' }}>
																	План
																</TableCell>
																<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '150px' }}>
																	Пользователь
																</TableCell>
																<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '120px' }}>
																	Действие
																</TableCell>
																<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '140px', borderTopRightRadius: '8px' }}>
																	Время
																</TableCell>
															</TableRow>
														</TableHead>
														<Fade in={true} timeout={500} key={planHistoryTransitionKey}>
															<TableBody>
																{planActionHistory.map((action) => (
																	<TableRow key={action.id}>
																		<TableCell sx={{ minWidth: '150px', whiteSpace: 'nowrap' }}>
																			<Typography
																				sx={{
																					color: '#0071E3',
																					textDecoration: 'underline',
																					cursor: 'pointer',
																					'&:hover': { textDecoration: 'none' },
																				}}
																				onClick={() => {
																					if (action.id) {
																						handleClosePlanHistoryDrawer();
																						// navigate(`/plan/${action.id}`); // Раскомментируйте, если есть страница плана
																					} else {
																						setError('ID плана отсутствует в записи истории.');
																						setOpenError(true);
																					}
																				}}
																			>
																				План на {action.year} год
																			</Typography>
																		</TableCell>
																		<TableCell sx={{ minWidth: '150px', whiteSpace: 'normal', wordWrap: 'break-word' }}>
																			{action.user_full_name}
																		</TableCell>
																		<TableCell sx={{ minWidth: '120px' }}>
																			{action.action_type === 'approved' ? 'Утверждён' : 'Возвращён на доработку'}
																		</TableCell>
																		<TableCell sx={{ minWidth: '140px' }}>
																			{new Date(action.timestamp).toLocaleString('ru-RU')}
																		</TableCell>
																	</TableRow>
																))}
															</TableBody>
														</Fade>
													</AppleTable>
													<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
														<Pagination
															count={totalPlanHistoryPages}
															page={planHistoryPage}
															onChange={handlePlanHistoryPageChange}
															color="primary"
															sx={{
																'& .MuiPaginationItem-root': {
																	borderRadius: 20,
																	'&:hover': { backgroundColor: 'grey.100' },
																	'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
																},
															}}
														/>
													</Box>
												</>
											) : (
												<Typography sx={{ mt: 2, color: '#6E6E73' }}>
													Нет записей в истории действий с планами.
												</Typography>
											)}
										</Box>
									</Drawer>
								</Box>
							)}
							{value === 4 && (
								<Box sx={{ mt: 4 }}>
									<Typography variant="h5" gutterBottom sx={{ color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
										Управление типами публикаций
									</Typography>
									<Box sx={{ display: 'flex', gap: 2, mb: 4 }}>
										<AppleTextField
											label="Название (англ.)"
											value={newTypeName}
											onChange={(e) => setNewTypeName(e.target.value)}
											sx={{ flex: 1 }}
										/>
										<AppleTextField
											label="Отображаемое название"
											value={newTypeDisplayName}
											onChange={(e) => setNewTypeDisplayName(e.target.value)}
											sx={{ flex: 1 }}
										/>
										<AppleButton onClick={handleAddType}>Добавить тип</AppleButton>
									</Box>
									<AppleTable>
										<TableHead>
											<TableRow>
												<TableCell>Название (англ.)</TableCell>
												<TableCell>Отображаемое название</TableCell>
												<TableCell>Действия</TableCell>
											</TableRow>
										</TableHead>
										<TableBody>
											{publicationTypes.map((type) => (
												<TableRow key={type.id}>
													<TableCell>{type.name}</TableCell>
													<TableCell>{type.display_name}</TableCell>
													<TableCell>
														<IconButton onClick={() => handleEditType(type)}>
															<EditIcon />
														</IconButton>
														<IconButton onClick={() => handleDeleteType(type.id)}>
															<DeleteIcon />
														</IconButton>
													</TableCell>
												</TableRow>
											))}
										</TableBody>
									</AppleTable>
								</Box>
							)}
						</>
					)}
				</AppleCard>

				{/* Диалог редактирования публикации */}
				<Dialog
					open={openEditDialog}
					onClose={handleEditCancel}
					PaperProps={{
						sx: { borderRadius: '16px', p: 2, backgroundColor: '#FFFFFF', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' },
					}}
				>
					<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600 }}>Редактировать публикацию</DialogTitle>
					<DialogContent>
						<form onSubmit={handleEditSubmit}>
							<AppleTextField
								fullWidth
								label="Название"
								value={editTitle}
								onChange={(e) => setEditTitle(e.target.value)}
								margin="normal"
								variant="outlined"
								autoComplete="off"
							/>
							<AppleTextField
								fullWidth
								label="Авторы"
								value={editAuthors}
								onChange={(e) => setEditAuthors(e.target.value)}
								margin="normal"
								variant="outlined"
								autoComplete="off"
							/>
							<AppleTextField
								fullWidth
								label="Год"
								type="number"
								value={editYear}
								onChange={(e) => setEditYear(e.target.value)}
								margin="normal"
								variant="outlined"
								inputProps={{ min: 1900, max: new Date().getFullYear() }}
							/>
							<AppleTextField
								select
								fullWidth
								label="Тип"
								value={editType}
								onChange={(e) => setEditType(e.target.value)}
								margin="normal"
								variant="outlined"
							>
								<MenuItem value="article">Статья</MenuItem>
								<MenuItem value="monograph">Монография</MenuItem>
								<MenuItem value="conference">Доклад/конференция</MenuItem>
							</AppleTextField>
							<AppleTextField
								select
								fullWidth
								label="Статус"
								value={editStatus}
								onChange={(e) => setEditStatus(e.target.value)}
								margin="normal"
								variant="outlined"
							>
								<MenuItem value="draft">Черновик</MenuItem>
								<MenuItem value="needs_review">На проверке</MenuItem>
								<MenuItem value="returned_for_revision">Возвращено на доработку</MenuItem>
								<MenuItem value="published">Опубликовано</MenuItem>
							</AppleTextField>
							<Button
								component="label"
								sx={{
									mt: 2,
									borderRadius: '12px',
									backgroundColor: '#F5F5F7',
									color: '#0071E3',
									textTransform: 'none',
									padding: '8px 16px',
									boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
									'&:hover': { backgroundColor: '#E8ECEF' },
								}}
							>
								Загрузить новый файл
								<input
									type="file"
									hidden
									onChange={(e) => setEditFile(e.target.files[0])}
								/>
							</Button>
							{editFile && (
								<Typography sx={{ mt: 1, color: '#6E6E73' }}>
									Выбран файл: {editFile.name}
								</Typography>
							)}
							<Collapse in={openError}>
								{error && (
									<Alert
										severity="error"
										sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#FFF1F0', color: '#1D1D1F' }}
										onClose={() => setOpenError(false)}
									>
										{error}
									</Alert>
								)}
							</Collapse>
						</form>
					</DialogContent>
					<DialogActions sx={{ p: 2 }}>
						<CancelButton onClick={handleEditCancel}>Отмена</CancelButton>
						<AppleButton type="submit" onClick={handleEditSubmit}>
							Сохранить
						</AppleButton>
					</DialogActions>
				</Dialog>

				{/* Диалог удаления публикации */}
				<Dialog
					open={openDeleteDialog}
					onClose={() => setOpenDeleteDialog(false)}
					PaperProps={{
						sx: { borderRadius: '16px', p: 2, backgroundColor: '#FFFFFF', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' },
					}}
				>
					<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600 }}>Удалить публикацию</DialogTitle>
					<DialogContent>
						<Typography sx={{ color: '#1D1D1F' }}>
							Вы уверены, что хотите удалить публикацию "{publicationToDelete?.title || 'Не указано'}"? Это действие нельзя отменить.
						</Typography>
					</DialogContent>
					<DialogActions sx={{ p: 2 }}>
						<CancelButton onClick={() => setOpenDeleteDialog(false)}>Отмена</CancelButton>
						<AppleButton
							sx={{ backgroundColor: '#FF3B30', '&:hover': { backgroundColor: '#E6392E' } }}
							onClick={handleDeletePlanConfirm}
						>
							Удалить
						</AppleButton>
					</DialogActions>
				</Dialog>


				<Dialog open={openEditTypeDialog} onClose={() => setOpenEditTypeDialog(false)}>
					<DialogTitle>Редактировать тип публикации</DialogTitle>
					<DialogContent>
						<AppleTextField
							label="Название (англ.)"
							value={editTypeName}
							onChange={(e) => setEditTypeName(e.target.value)}
							fullWidth
							margin="normal"
						/>
						<AppleTextField
							label="Отображаемое название"
							value={editTypeDisplayName}
							onChange={(e) => setEditTypeDisplayName(e.target.value)}
							fullWidth
							margin="normal"
						/>
					</DialogContent>
					<DialogActions>
						<Button onClick={() => setOpenEditTypeDialog(false)}>Отмена</Button>
						<Button onClick={handleUpdateType}>Сохранить</Button>
					</DialogActions>
				</Dialog>

				{/* Диалог возврата плана на доработку */}
				<Dialog
					open={openReturnDialog}
					onClose={() => setOpenReturnDialog(false)}
					PaperProps={{
						sx: { borderRadius: '16px', p: 2, backgroundColor: '#FFFFFF', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' },
					}}
				>
					<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600 }}>
						Возврат плана на доработку
					</DialogTitle>
					<DialogContent>
						<Typography sx={{ color: '#1D1D1F', mb: 2 }}>
							Укажите причину возврата плана на доработку.
						</Typography>
						<AppleTextField
							fullWidth
							label="Комментарий"
							value={returnComment}
							onChange={(e) => setReturnComment(e.target.value)}
							margin="normal"
							variant="outlined"
							multiline
							rows={4}
						/>
						<Collapse in={openError}>
							{error && (
								<Alert
									severity="error"
									sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#FFF1F0', color: '#1D1D1F' }}
									onClose={() => setOpenError(false)}
								>
									{error}
								</Alert>
							)}
						</Collapse>
					</DialogContent>
					<DialogActions sx={{ p: 2 }}>
						<CancelButton onClick={() => setOpenReturnDialog(false)}>Отмена</CancelButton>
						<AppleButton onClick={handleReturnForRevision}>Отправить</AppleButton>
					</DialogActions>
				</Dialog>

				{/* Уведомления */}
				<Collapse in={openSuccess}>
					{success && (
						<Alert
							severity="success"
							sx={{
								position: 'fixed',
								top: 16,
								left: '50%',
								transform: 'translateX(-50%)',
								width: 'fit-content',
								maxWidth: '90%',
								borderRadius: '12px',
								backgroundColor: '#E7F8E7',
								color: '#1D1D1F',
								boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
								zIndex: 1500,
							}}
							onClose={() => setOpenSuccess(false)}
						>
							{success}
						</Alert>
					)}
				</Collapse>
			</Container>
		</>
	);
}

export default ManagerDashboard;

D:\publication-system\backend\app\routes.py
from flask import Blueprint, jsonify, request, make_response, current_app, send_file
from .extensions import db, login_manager, csrf
from .models import User, Publication, Comment, Plan, PlanEntry, PublicationActionHistory, PublicationType
from .utils import allowed_file
from flask_login import login_user, current_user, logout_user, login_required
from werkzeug.utils import secure_filename
from flask_wtf.csrf import generate_csrf
import os
from .analytics import get_publications_by_year
import bibtexparser
from reportlab.platypus import SimpleDocTemplate, Paragraph
from reportlab.lib.pagesizes import letter
from bibtexparser.bibdatabase import BibDatabase
from bibtexparser.bwriter import BibTexWriter
import logging
from datetime import datetime, UTC
from werkzeug.security import generate_password_hash, check_password_hash

bp = Blueprint('api', __name__, url_prefix='/api')

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

@bp.route('/uploads/<path:filename>')
def download_file(filename):
    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
    logger.debug(f"Serving file from {file_path}")
    if not os.path.exists(file_path):
        logger.error(f"File not found: {file_path}")
        return jsonify({'error': 'Файл не найден'}), 404
    response = send_file(file_path, as_attachment=True)
    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

@bp.route('/publications/<int:pub_id>', methods=['GET'])
@login_required
def get_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)

    if publication.user_id != current_user.id and current_user.role not in ['admin', 'manager']:
        return jsonify({"error": "У вас нет прав для просмотра этой публикации."}), 403

    comments = Comment.query.filter_by(publication_id=pub_id, parent_id=None).order_by(Comment.created_at.asc()).all()
    
    def build_comment_tree(comment):
        return {
            'id': comment.id,
            'content': comment.content,
            'user': {'username': comment.user.username, 'full_name': comment.user.full_name, 'role': comment.user.role},
            'created_at': comment.created_at.isoformat(),
            'replies': [build_comment_tree(reply) for reply in comment.replies]
        }
    
    return jsonify({
        'id': publication.id,
        'title': publication.title,
        'authors': publication.authors,
        'year': publication.year,
        'type': publication.type.name if publication.type else 'Неизвестный тип',  # Используем name из PublicationType
        'status': publication.status,
        'file_url': publication.file_url if publication.file_url else None,
        'user': {
            'id': publication.user.id if publication.user else None,
            'full_name': publication.user.full_name if publication.user else None},
        'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
        'published_at': publication.published_at.isoformat() if publication.published_at else None,
        'returned_for_revision': publication.returned_for_revision,
        'comments': [build_comment_tree(comment) for comment in comments]
    }), 200

@bp.route('/publications/<int:pub_id>/comments', methods=['POST'])
@login_required
def add_comment(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    data = request.get_json()
    content = data.get('content')
    parent_id = data.get('parent_id')

    if not content:
        return jsonify({'error': 'Комментарий не может быть пустым'}), 400

    comment = Comment(
        content=content,
        user_id=current_user.id,
        publication_id=pub_id,
        parent_id=parent_id if parent_id else None
    )
    db.session.add(comment)
    db.session.commit()

    return jsonify({
        'message': 'Комментарий добавлен',
        'comment': {
            'id': comment.id,
            'content': comment.content,
            'user': {'username': current_user.username, 'full_name': current_user.full_name, 'role': current_user.role},
            'created_at': comment.created_at.isoformat(),
            'replies': []
        }
    }), 201

@bp.route('/publications/<int:pub_id>/submit-for-review', methods=['POST'])
@login_required
def submit_for_review(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    
    if publication.user_id != current_user.id:
        logger.warning(f"Несанкционированная попытка отправить публикацию {pub_id} на проверку пользователем {current_user.id}")
        return jsonify({'error': 'У вас нет прав на отправку этой публикации на проверку'}), 403

    if publication.status not in ['draft', 'returned_for_revision']:
        logger.debug(f"Публикация {pub_id} со статусом {publication.status} не может быть отправлена на проверку")
        return jsonify({'error': 'Публикация уже отправлена на проверку или опубликована'}), 400

    if not publication.file_url:
        logger.debug(f"Попытка отправить публикацию {pub_id} без файла")
        return jsonify({'error': 'Нельзя отправить на проверку публикацию без прикреплённого файла'}), 400

    publication.status = 'needs_review'
    publication.updated_at = datetime.utcnow()
    publication.returned_for_revision = False

    try:
        db.session.commit()
        logger.debug(f"Публикация {pub_id} успешно отправлена на проверку пользователем {current_user.id}")
        return jsonify({'message': 'Публикация отправлена на проверку'}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка отправки на проверку публикации {pub_id}: {str(e)}")
        return jsonify({'error': 'Ошибка при отправке на проверку. Попробуйте позже.'}), 500

@bp.route('/publications/<int:pub_id>/publish', methods=['POST'])
@login_required
def publish_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    if current_user.role not in ['admin', 'manager']:
        return jsonify({"error": "У вас нет прав для публикации этой работы."}), 403
    if publication.status != 'needs_review':
        return jsonify({"error": "Публикация не находится на стадии проверки."}), 400
    if not publication.file_url:
        return jsonify({"error": "Нельзя опубликовать работу без прикреплённого файла."}), 400

    publication.status = 'published'
    publication.published_at = datetime.utcnow()
    publication.returned_for_revision = False

    # Добавление записи в историю
    action = PublicationActionHistory(
        publication_id=publication.id,
        user_id=current_user.id,
        action_type='approved',
        timestamp=publication.published_at,
        comment=None  # Комментарий можно добавить, если он передаётся в запросе
    )
    db.session.add(action)

    try:
        db.session.commit()
        logger.debug(f"Публикация {pub_id} успешно опубликована пользователем {current_user.id}")
        return jsonify({
            'message': 'Публикация успешно опубликована',
            'publication': {
                'id': publication.id,
                'title': publication.title,
                'status': publication.status,
                'published_at': publication.published_at.isoformat()
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при публикации публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при публикации. Попробуйте позже."}), 500

@bp.route('/publications/<int:pub_id>/return-for-revision', methods=['POST'])
@login_required
def return_for_revision(pub_id):
    # Получаем публикацию или возвращаем 404, если она не найдена
    publication = Publication.query.get_or_404(pub_id)

    # Проверяем права пользователя
    if current_user.role not in ['admin', 'manager']:
        logger.warning(f"Несанкционированная попытка вернуть публикацию {pub_id} на доработку пользователем {current_user.id} с ролью {current_user.role}")
        return jsonify({"error": "У вас нет прав для возврата этой работы на доработку."}), 403

    # Проверяем статус публикации
    if publication.status != 'needs_review':
        return jsonify({"error": "Публикация не находится на стадии проверки."}), 400

    # Читаем комментарий из тела запроса
    data = request.get_json()
    comment = data.get('comment', '')

    # Проверяем, что комментарий не пустой
    if not comment.strip():
        return jsonify({"error": "Необходимо добавить комментарий перед возвратом на доработку."}), 400

    # Обновляем поля публикации
    publication.status = 'returned_for_revision'
    publication.returned_for_revision = True
    publication.published_at = None
    publication.returned_at = datetime.utcnow()
    publication.return_comment = comment  # Сохраняем комментарий в публикации

    # Создаем запись в истории действий без 'title'
    action = PublicationActionHistory(
        publication_id=publication.id,
        user_id=current_user.id,
        action_type='returned',
        timestamp=publication.returned_at,
        comment=comment  # Сохраняем комментарий в истории
    )
    db.session.add(action)

    try:
        # Фиксируем изменения в базе данных
        db.session.commit()
        logger.debug(f"Публикация {pub_id} возвращена на доработку пользователем {current_user.id}, returned_at: {publication.returned_at}")
        return jsonify({
            'message': 'Публикация отправлена на доработку',
            'publication': {
                'id': publication.id,
                'title': publication.title,
                'status': publication.status,
                'returned_for_revision': publication.returned_for_revision,
                'returned_at': publication.returned_at.isoformat() if publication.returned_at else None,
                'return_comment': publication.return_comment
            }
        }), 200
    except Exception as e:
        # Откатываем изменения в случае ошибки
        db.session.rollback()
        logger.error(f"Ошибка при возврате публикации {pub_id} на доработку: {str(e)}")
        return jsonify({"error": "Ошибка при возврате на доработку. Попробуйте позже."}), 500
@bp.route('/login', methods=['POST'])
@csrf.exempt
def login():
    logger.debug(f"Получен POST запрос для /login")
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    user = User.query.filter_by(username=username).first()
    if user and check_password_hash(user.password_hash, password):
        login_user(user, remember=True)
        return jsonify({
            'message': 'Успешная авторизация',
            'user': {
                'id': user.id,
                'username': user.username,
                'role': user.role,
                'last_name': user.last_name,
                'first_name': user.first_name,
                'middle_name': user.middle_name
            }
        }), 200
    return jsonify({'error': 'Неверное имя пользователя или пароль'}), 401

@bp.route('/csrf-token', methods=['GET'])
def get_csrf_token():
    logger.debug(f"Получен GET запрос для /api/csrf-token")
    token = generate_csrf()
    return jsonify({'csrf_token': token}), 200

@bp.route('/logout', methods=['POST'])
@login_required
def logout():
    logger.debug(f"Получен POST запрос для /logout")
    logout_user()
    response = jsonify({'message': 'Успешный выход'})
    response.set_cookie('session', '', expires=0)
    return response, 200

@bp.route('/user', methods=['GET', 'PUT'])
@login_required
def user():
    logger.debug(f"Получен {request.method} запрос для /user")
    logger.debug(f"Текущий пользователь: {current_user.id if current_user.is_authenticated else 'Не аутентифицирован'}")
    logger.debug(f"Куки сессии: {request.cookies.get('session')}")
    if request.method == 'GET':
        response_data = {
            'id': current_user.id,
            'username': current_user.username,
            'role': current_user.role,
            'last_name': current_user.last_name,
            'first_name': current_user.first_name,
            'middle_name': current_user.middle_name,
            'created_at': current_user.created_at.isoformat() if current_user.created_at else None
        }
        logger.debug(f"Ответ сервера для /api/user: {response_data}")
        return jsonify(response_data), 200
    elif request.method == 'PUT':
        data = request.get_json()
        current_user.last_name = data.get('last_name', current_user.last_name)
        current_user.first_name = data.get('first_name', current_user.first_name)
        current_user.middle_name = data.get('middle_name', current_user.middle_name)
        try:
            db.session.commit()
            return jsonify({
                'message': 'Данные пользователя успешно обновлены',
                'user': {
                    'id': current_user.id,
                    'username': current_user.username,
                    'role': current_user.role,
                    'last_name': current_user.last_name,
                    'first_name': current_user.first_name,
                    'middle_name': current_user.middle_name
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка обновления данных пользователя {current_user.id}: {str(e)}")
            return jsonify({"error": "Ошибка при обновлении данных. Попробуйте позже."}), 500

@bp.route('/user/password', methods=['PUT'])
@login_required
def change_password():
    logger.debug(f"Получен PUT запрос для /user/password")
    data = request.get_json()
    current_password = data.get('current_password')
    new_password = data.get('new_password')

    if not check_password_hash(current_user.password_hash, current_password):
        return jsonify({'error': 'Текущий пароль неверен'}), 401

    current_user.password_hash = generate_password_hash(new_password)
    try:
        db.session.commit()
        return jsonify({'message': 'Пароль успешно изменён'}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка изменения пароля для пользователя {current_user.id}: {str(e)}")
        return jsonify({"error": "Ошибка при изменении пароля. Попробуйте позже."}), 500

@bp.route('/public/publications', methods=['GET'])
def get_public_publications():
    logger.debug(f"Получен GET запрос для /api/public/publications")
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    pub_type = request.args.get('type', 'all')

    query = Publication.query.filter_by(status='published').order_by(
        db.func.coalesce(Publication.published_at, Publication.updated_at).desc()
    )

    if pub_type != 'all':
        type_ = PublicationType.query.filter_by(name=pub_type).first()
        if type_:
            query = query.filter(Publication.type_id == type_.id)
        else:
            return jsonify({'error': 'Недопустимый тип публикации'}), 400

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    publications = pagination.items

    response = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type.name if pub.type else 'Неизвестный тип',  # Используем name из PublicationType
        'status': pub.status,
        'file_url': pub.file_url,
        'updated_at': pub.updated_at.isoformat() if pub.updated_at else None,
        'published_at': pub.published_at.isoformat() if pub.published_at else None,
        'returned_for_revision': pub.returned_for_revision,
        'user': {
            'full_name': pub.user.full_name if pub.user else 'Не указан'
        } if pub.user else None
    } for pub in publications]

    return jsonify({
        'publications': response,
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/publications', methods=['GET'])
@login_required
def get_publications():
    logger.debug(f"Получен GET запрос для /publications")
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '').lower()
    pub_type = request.args.get('type', 'all')
    status = request.args.get('status', 'all')

    query = Publication.query.filter_by(user_id=current_user.id)

    if search:
        query = query.filter(
            db.or_(
                Publication.title.ilike(f'%{search}%'),
                Publication.authors.ilike(f'%{search}%'),
                db.cast(Publication.year, db.String).ilike(f'%{search}%')
            )
        )

    if pub_type != 'all':
        type_ = PublicationType.query.filter_by(name=pub_type).first()
        if type_:
            query = query.filter(Publication.type_id == type_.id)
        else:
            return jsonify({'error': 'Недопустимый тип публикации'}), 400

    if status != 'all':
        query = query.filter(Publication.status == status)

    query = query.order_by(Publication.updated_at.desc())

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    publications = pagination.items

    response = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type.name if pub.type else 'Неизвестный тип',  # Используем name из PublicationType
        'status': pub.status,
        'file_url': pub.file_url,
        'updated_at': pub.updated_at.isoformat() if pub.updated_at else None,
        'returned_for_revision': pub.returned_for_revision,
    } for pub in publications]

    return jsonify({
        'publications': response,
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/publications/<int:pub_id>', methods=['PUT', 'DELETE'])
@login_required
def manage_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    if publication.user_id != current_user.id:
        return jsonify({'error': 'У вас нет прав на управление этой публикацией'}), 403

    if publication.status == 'needs_review':
        return jsonify({'error': 'Нельзя редактировать публикацию, пока она на проверке'}), 403

    if request.method == 'PUT':
        if request.content_type == 'application/json':
            data = request.get_json()
        elif 'file' in request.files or request.content_type.startswith('multipart/form-data'):
            data = request.form
        else:
            return jsonify({"error": "Неподдерживаемый формат данных. Используйте application/json или multipart/form-data."}), 415

        old_status = publication.status

        if 'file' in request.files:
            file = request.files['file']
            if file and allowed_file(file.filename):
                if publication.file_url:
                    old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                    if os.path.exists(old_file_path):
                        os.remove(old_file_path)
                filename = secure_filename(file.filename)
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                if os.path.exists(file_path):
                    base, extension = os.path.splitext(filename)
                    counter = 1
                    while os.path.exists(file_path):
                        filename = f"{base}_{counter}{extension}"
                        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                        counter += 1
                file.save(file_path)
                publication.file_url = f"/uploads/{filename}"

        publication.title = data.get('title', publication.title)
        publication.authors = data.get('authors', publication.authors)
        publication.year = data.get('year', publication.year)
        type_name = data.get('type', publication.type.name if publication.type else None)
        if type_name:
            type_ = PublicationType.query.filter_by(name=type_name).first()
            if type_:
                publication.type_id = type_.id
            else:
                return jsonify({'error': 'Недопустимый тип публикации'}), 400
        new_status = data.get('status', publication.status)

        if new_status == 'published' and not publication.file_url:
            return jsonify({'error': 'Нельзя опубликовать работу без прикреплённого файла.'}), 400

        publication.status = new_status

        if publication.status == 'published' and old_status != 'published':
            publication.published_at = datetime.utcnow()

        try:
            db.session.commit()
            return jsonify({
                'message': 'Публикация успешно обновлена',
                'publication': {
                    'id': publication.id,
                    'title': publication.title,
                    'authors': publication.authors,
                    'year': publication.year,
                    'type': publication.type.name if publication.type else 'Неизвестный тип',  # Используем name
                    'status': publication.status,
                    'file_url': publication.file_url,
                    'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
                    'published_at': publication.published_at.isoformat() if publication.published_at else None,
                    'returned_for_revision': publication.returned_for_revision,
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка обновления публикации {pub_id}: {str(e)}")
            return jsonify({"error": "Ошибка при обновлении публикации. Попробуйте позже."}), 500

    elif request.method == 'DELETE':
        # Логика удаления остается без изменений
        try:
            if publication.file_url:
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                if os.path.exists(file_path):
                    os.remove(file_path)
            db.session.delete(publication)
            db.session.commit()
            return jsonify({'message': 'Публикация успешно удалена'}), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка удаления публикации {pub_id}: {str(e)}")
            return jsonify({"error": "Ошибка при удалении публикации. Попробуйте позже."}), 500
@bp.route('/publications/upload-file', methods=['POST'])
@login_required
def upload_file():
    logger.debug(f"Получен POST запрос для /publications/upload-file")
    if 'file' not in request.files:
        return jsonify({'error': 'Файл не предоставлен'}), 400

    file = request.files['file']
    if not file or not allowed_file(file.filename):
        return jsonify({'error': 'Недопустимый файл'}), 400

    title = request.form.get('title')
    authors = request.form.get('authors')
    year = request.form.get('year')
    type_name = request.form.get('type', 'article')  # Имя типа из формы
    
    if not title or not authors or not year:
        return jsonify({'error': 'Название, авторы и год обязательны'}), 400

    try:
        year = int(year)
        if year < 1900 or year > datetime.now().year:
            return jsonify({'error': 'Недопустимый год'}), 400
    except ValueError:
        return jsonify({'error': 'Год должен быть числом'}), 400

    type_ = PublicationType.query.filter_by(name=type_name).first()
    if not type_:
        return jsonify({'error': 'Недопустимый тип публикации'}), 400

    filename = secure_filename(file.filename)
    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
    if os.path.exists(file_path):
        base, extension = os.path.splitext(filename)
        counter = 1
        while os.path.exists(file_path):
            filename = f"{base}_{counter}{extension}"
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
            counter += 1
    file.save(file_path)

    publication = Publication(
        title=title,
        authors=authors,
        year=year,
        type_id=type_.id,  # Используем type_id вместо type
        status='draft',
        file_url=f"/uploads/{filename}",
        user_id=current_user.id,
        returned_for_revision=False,
    )

    db.session.add(publication)
    db.session.commit()

    return jsonify({
        'message': 'Публикация успешно загружена',
        'publication': {
            'id': publication.id,
            'title': publication.title,
            'authors': publication.authors,
            'year': publication.year,
            'type': type_.name,  # Возвращаем имя типа
            'status': publication.status,
            'file_url': publication.file_url,
            'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
            'returned_for_revision': publication.returned_for_revision,
        }
    }), 200

@bp.route('/publications/upload-bibtex', methods=['POST'])
@login_required
def upload_bibtex():
    logger.debug(f"Получен POST запрос для /publications/upload-bibtex")
    if 'file' not in request.files:
        return jsonify({'error': 'BibTeX файл не предоставлен'}), 400

    file = request.files['file']
    if file and file.filename.endswith('.bib'):
        try:
            content = file.read().decode('utf-8')
            bib_database = bibtexparser.loads(content)
            publications_added = 0

            for entry in bib_database.entries:
                title = entry.get('title', 'Без названия')
                authors = entry.get('author', 'Неизвестный автор')
                year = entry.get('year', datetime.now().year)
                try:
                    year = int(year)
                except (ValueError, TypeError):
                    year = datetime.now().year
                type_name = entry.get('entrytype', 'article')
                
                type_ = PublicationType.query.filter_by(name=type_name).first()
                if not type_:
                    continue  # Пропускаем, если тип не найден

                publication = Publication(
                    title=title,
                    authors=authors,
                    year=year,
                    type_id=type_.id,  # Используем type_id
                    status='draft',
                    user_id=current_user.id,
                    returned_for_revision=False,
                )
                db.session.add(publication)
                publications_added += 1

            db.session.commit()
            return jsonify({'message': f'Обработано {publications_added} публикаций'}), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка обработки BibTeX: {str(e)}")
            return jsonify({'error': 'Ошибка при обработке BibTeX файла'}), 500
    return jsonify({'error': 'Недопустимый файл. Ожидается .bib'}), 400

@bp.route('/publications/<int:pub_id>/attach-file', methods=['POST'])
@login_required
def attach_file(pub_id):
    logger.debug(f"Получен POST запрос для /publications/{pub_id}/attach-file")
    publication = Publication.query.get_or_404(pub_id)
    if publication.user_id != current_user.id:
        return jsonify({'error': 'У вас нет прав на изменение этой публикации'}), 403

    if publication.status == 'needs_review':
        return jsonify({'error': 'Нельзя редактировать публикацию, пока она на проверке'}), 403

    if 'file' not in request.files:
        return jsonify({'error': 'Файл не предоставлен'}), 400

    file = request.files['file']
    if file and allowed_file(file.filename):
        if publication.file_url:
            old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
            if os.path.exists(old_file_path):
                os.remove(old_file_path)
        filename = secure_filename(file.filename)
        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
        if os.path.exists(file_path):
            base, extension = os.path.splitext(filename)
            counter = 1
            while os.path.exists(file_path):
                filename = f"{base}_{counter}{extension}"
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                counter += 1
        file.save(file_path)
        publication.file_url = f"/uploads/{filename}"

        try:
            db.session.commit()
            return jsonify({
                'message': 'Файл успешно прикреплен',
                'publication': {
                    'id': publication.id,
                    'title': publication.title,
                    'authors': publication.authors,
                    'year': publication.year,
                    'type': publication.type,
                    'status': publication.status,
                    'file_url': publication.file_url,
                    'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
                    'returned_for_revision': publication.returned_for_revision,
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка прикрепления файла к публикации {pub_id}: {str(e)}")
            return jsonify({"error": "Ошибка при прикреплении файла. Попробуйте позже."}), 500
    return jsonify({'error': 'Недопустимый файл'}), 400

@bp.route('/publications/export-bibtex', methods=['GET'])
@login_required
def export_bibtex():
    logger.debug(f"Получен GET запрос для /publications/export-bibtex")
    try:
        logger.debug("Начинаем запрос публикаций для текущего пользователя")
        publications = Publication.query.filter_by(user_id=current_user.id).all()
        logger.debug(f"Найдено публикаций: {len(publications)}")

        bib_db = BibDatabase()
        bib_db.entries = [{
            'ENTRYTYPE': pub.type.name if pub.type else 'article',
            'ID': f'pub{pub.id}',
            'title': pub.title or 'Без названия',
            'author': pub.authors or 'Неизвестный автор',
            'year': str(pub.year) if pub.year else str(datetime.now().year)
        } for pub in publications]

        writer = BibTexWriter()
        if not callable(writer.write):
            raise AttributeError("Метод write в BibTexWriter не является callable. Проверьте версию bibtexparser.")

        bibtex_str = writer.write(bib_db)
        
        response = make_response(bibtex_str)
        response.headers['Content-Disposition'] = 'attachment; filename=publications.bib'
        response.headers['Content-Type'] = 'application/x-bibtex'
        logger.debug("BibTeX успешно сгенерирован и отправлен")
        return response
    except ImportError as e:
        logger.error(f"Ошибка импорта bibtexparser: {str(e)}")
        return jsonify({'error': 'Ошибка импорта библиотеки bibtexparser. Установите или обновите bibtexparser (>=1.4.0).'}), 500
    except AttributeError as e:
        logger.error(f"Ошибка атрибута в bibtexparser: {str(e)}")
        return jsonify({'error': 'Ошибка в библиотеке bibtexparser. Проверьте установку и версию.'}), 500
    except Exception as e:
        logger.error(f"Ошибка экспорта BibTeX: {str(e)}")
        return jsonify({'error': f'Внутренняя ошибка сервера при экспорте BibTeX: {str(e)}'}), 500

@bp.route('/analytics/yearly', methods=['GET'])
@login_required
def get_analytics_yearly():
    logger.debug(f"Получен GET запрос для /analytics/yearly")
    analytics = get_publications_by_year(current_user.id)
    return jsonify([{
        'year': year,
        'count': count
    } for year, count in analytics]), 200

@bp.route('/plans', methods=['GET'])
@login_required
def get_plans():
    logger.debug(f"Получен GET запрос для /plans")
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    plans = Plan.query.filter_by(user_id=current_user.id).order_by(Plan.year.desc()).paginate(page=page, per_page=per_page)
    return jsonify({
        'plans': [plan.to_dict() for plan in plans.items],
        'total': plans.total,
        'pages': plans.pages,
        'current_page': plans.page
    })

@bp.route('/plans', methods=['POST'])
@login_required
def create_plan():
    data = request.get_json()
    if not data.get('year') or not data.get('fillType') or 'entries' not in data:
        return jsonify({'error': 'Отсутствуют обязательные поля'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Недопустимый год'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Недопустимый тип заполнения'}), 400

    existing_approved_plan = Plan.query.filter_by(
        user_id=current_user.id,
        year=data['year'],
        status='approved'
    ).first()
    if existing_approved_plan:
        return jsonify({'error': f'У вас уже есть утверждённый план на {data["year"]} год.'}), 403

    plan = Plan(
        year=data['year'],
        fillType=data['fillType'],
        user_id=current_user.id,
        status='draft'
    )
    db.session.add(plan)

    for entry_data in data['entries']:
        type_name = entry_data.get('type')
        type_ = PublicationType.query.filter_by(name=type_name).first() if type_name else None
        if type_name and not type_:
            db.session.rollback()
            return jsonify({'error': f'Недопустимый тип публикации: {type_name}'}), 400

        entry = PlanEntry(
            title=entry_data.get('title'),
            type_id=type_.id if type_ else None,  # Используем type_id
            publication_id=entry_data.get('publication_id'),
            status=entry_data.get('status', 'planned'),
            isPostApproval=False,
            plan=plan
        )
        if entry.publication_id:
            publication = Publication.query.filter_by(id=entry.publication_id, user_id=current_user.id, status='published').first()
            if not publication:
                db.session.rollback()
                return jsonify({'error': f'Публикация с ID {entry.publication_id} не найдена или не опубликована'}), 404
        db.session.add(entry)

    db.session.commit()
    return jsonify({'message': f'План создан с ID {plan.id}', 'plan': plan.to_dict()}), 201

@bp.route('/plans/<int:plan_id>', methods=['PUT'])
@login_required
def update_plan(plan_id):
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'План не найден или доступ запрещён'}), 404
    
    if plan.status not in ['draft', 'returned', 'approved']:
        return jsonify({'error': 'Нельзя редактировать план на проверке'}), 403

    data = request.get_json()
    if not all(k in data for k in ('year', 'fillType', 'entries')):
        return jsonify({'error': 'Отсутствуют обязательные поля'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Недопустимый год'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Недопустимый тип заполнения'}), 400

    if plan.status == 'approved':
        existing_entries = {entry.id: entry for entry in plan.entries}
        new_entries = []
        for entry_data in data['entries']:
            entry_id = entry_data.get('id')
            type_name = entry_data.get('type')
            type_ = PublicationType.query.filter_by(name=type_name).first() if type_name else None
            if type_name and not type_:
                db.session.rollback()
                return jsonify({'error': f'Недопустимый тип публикации: {type_name}'}), 400

            if entry_id and entry_id in existing_entries:
                entry = existing_entries[entry_id]
                entry.title = entry_data.get('title', entry.title)
                entry.type_id = type_.id if type_ else None  # Используем type_id
                entry.publication_id = entry_data.get('publication_id', entry.publication_id)
                entry.status = entry_data.get('status', entry.status)
                if entry.publication_id:
                    publication = Publication.query.filter_by(id=entry.publication_id, user_id=current_user.id, status='published').first()
                    if not publication:
                        db.session.rollback()
                        return jsonify({'error': f'Публикация с ID {entry.publication_id} не найдена или не опубликована'}), 404
            else:
                new_entry = PlanEntry(
                    title=entry_data.get('title', ''),
                    type_id=type_.id if type_ else None,  # Используем type_id
                    publication_id=entry_data.get('publication_id'),
                    status=entry_data.get('status', 'planned'),
                    isPostApproval=True,
                    plan=plan
                )
                if new_entry.publication_id:
                    publication = Publication.query.filter_by(id=new_entry.publication_id, user_id=current_user.id, status='published').first()
                    if not publication:
                        db.session.rollback()
                        return jsonify({'error': f'Публикация с ID {new_entry.publication_id} не найдена или не опубликована'}), 404
                new_entries.append(new_entry)
                db.session.add(new_entry)
    else:
        plan.year = data['year']
        plan.fillType = data['fillType']
        PlanEntry.query.filter_by(plan_id=plan.id).delete()
        for entry_data in data['entries']:
            type_name = entry_data.get('type')
            type_ = PublicationType.query.filter_by(name=type_name).first() if type_name else None
            if type_name and not type_:
                db.session.rollback()
                return jsonify({'error': f'Недопустимый тип публикации: {type_name}'}), 400

            entry = PlanEntry(
                title=entry_data.get('title'),
                type_id=type_.id if type_ else None,  # Используем type_id
                publication_id=entry_data.get('publication_id'),
                status=entry_data.get('status', 'planned'),
                isPostApproval=False,
                plan=plan
            )
            if entry.publication_id:
                publication = Publication.query.filter_by(id=entry.publication_id, user_id=current_user.id, status='published').first()
                if not publication:
                    db.session.rollback()
                    return jsonify({'error': f'Публикация с ID {entry.publication_id} не найдена или не опубликована'}), 404
            db.session.add(entry)

    db.session.commit()
    return jsonify({'message': 'План успешно обновлён', 'plan': plan.to_dict()}), 200

@bp.route('/plans/<int:plan_id>', methods=['DELETE'])
@login_required
def delete_plan(plan_id):
    logger.debug(f"Получен DELETE запрос для /plans/{plan_id}")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'Cannot delete plan that is under review or approved'}), 403

    db.session.delete(plan)
    db.session.commit()
    return jsonify({'message': 'Plan deleted successfully'}), 200

@bp.route('/plans/<int:plan_id>/submit-for-review', methods=['POST'])
@login_required
def submit_plan_for_review(plan_id):
    logger.debug(f"Получен POST запрос для /plans/{plan_id}/submit-for-review")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'План уже отправлен на проверку или утверждён'}), 400
    
    if not all(entry.title and entry.title.strip() for entry in plan.entries):
        return jsonify({'error': 'Все записи плана должны иметь заполненные заголовки'}), 400

    plan.status = 'needs_review'
    db.session.commit()
    return jsonify({'message': 'План отправлен на проверку', 'plan': plan.to_dict()}), 200

@bp.route('/publication-types', methods=['GET'])
@login_required
def get_publication_types():
    """
    Эндпоинт для получения списка типов публикаций.
    Доступен для всех аутентифицированных пользователей.
    """
    # Логируем запрос
    logger.debug(f"Получен GET запрос для /api/publication-types от пользователя {current_user.id}")
    
    try:
        # Запрашиваем все типы публикаций из таблицы PublicationType
        types = PublicationType.query.all()
        
        # Формируем ответ в виде списка словарей
        response = [{
            'id': type_.id,
            'name': type_.name,
            'display_name': type_.display_name
        } for type_ in types]
        
        # Логируем успешное выполнение
        logger.debug(f"Возвращено {len(response)} типов публикаций")
        
        # Возвращаем JSON-ответ
        return jsonify(response), 200
    
    except Exception as e:
        # Логируем ошибку
        logger.error(f"Ошибка получения типов публикаций: {str(e)}")
        # Возвращаем сообщение об ошибке
        return jsonify({'error': 'Ошибка при получении типов публикаций. Попробуйте позже.'}), 500

@bp.route('/plans/<int:plan_id>/entries/<int:entry_id>/link', methods=['POST'])
@login_required
def link_publication_to_plan_entry(plan_id, entry_id):
    logger.debug(f"Получен POST запрос для /plans/{plan_id}/entries/{entry_id}/link")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    entry = PlanEntry.query.filter_by(id=entry_id, plan_id=plan_id).first()
    if not entry:
        return jsonify({'error': 'Entry not found'}), 404
    
    if plan.status != 'approved':
        return jsonify({'error': 'Can only link publications to approved plans'}), 403
    
    if entry.publication_id:
        return jsonify({'error': 'Entry already linked to a publication'}), 400

    data = request.get_json()
    publication_id = data.get('publication_id')
    if not publication_id:
        return jsonify({'error': 'Publication ID is required'}), 400

    publication = Publication.query.filter_by(id=publication_id, user_id=current_user.id, status='published').first()
    if not publication:
        return jsonify({'error': f'Publication with ID {publication_id} not found or not published'}), 404

    existing_link = PlanEntry.query.filter_by(publication_id=publication_id).first()
    if existing_link:
        return jsonify({'error': f'Publication with ID {publication_id} is already linked to another plan entry'}), 400

    entry.publication_id = publication_id
    entry.status = 'completed'
    db.session.commit()
    return jsonify({'message': 'Publication linked successfully', 'entry': entry.to_dict()}), 200

@bp.route('/plans/<int:plan_id>/entries/<int:entry_id>/unlink', methods=['POST'])
@login_required
def unlink_publication_from_plan_entry(plan_id, entry_id):
    logger.debug(f"Получен POST запрос для /plans/{plan_id}/entries/{entry_id}/unlink")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    entry = PlanEntry.query.filter_by(id=entry_id, plan_id=plan_id).first()
    if not entry:
        return jsonify({'error': 'Entry not found'}), 404
    
    if plan.status != 'approved':
        return jsonify({'error': 'Can only unlink publications from approved plans'}), 403
    
    if not entry.publication_id:
        return jsonify({'error': 'No publication linked to this entry'}), 400

    entry.publication_id = None
    entry.status = 'planned'
    db.session.commit()
    return jsonify({'message': 'Publication unlinked successfully', 'entry': entry.to_dict()}), 200


		D:\publication-system\backend\app\api.py
		from flask import Blueprint, jsonify, request, send_file
from werkzeug.utils import secure_filename
from flask_login import login_required, current_user
from flask import current_app
from app.extensions import db
from app.models import Publication, User, Plan, PlanEntry, PlanActionHistory, PublicationActionHistory, PublicationType
import os
import logging
from io import BytesIO
import bibtexparser
from datetime import datetime
from sqlalchemy import or_


bp = Blueprint('admin_api', __name__, url_prefix='/admin_api')
logger = logging.getLogger(__name__)

def admin_or_manager_required(f):
    @login_required
    def wrapper(*args, **kwargs):
        if current_user.role not in ['admin', 'manager']:
            logger.warning(f"Unauthorized access attempt by user {current_user.id} with role {current_user.role}")
            return jsonify({"error": "Доступ запрещён. Требуется роль администратора или управляющего."}), 403
        return f(*args, **kwargs)
    wrapper.__name__ = f.__name__
    return wrapper

def admin_required(f):
    @login_required
    def wrapper(*args, **kwargs):
        if current_user.role != 'admin':
            logger.warning(f"Unauthorized access attempt by user {current_user.id} with role {current_user.role}")
            return jsonify({"error": "Доступ запрещён. Требуется роль администратора."}), 403
        return f(*args, **kwargs)
    wrapper.__name__ = f.__name__
    return wrapper

@bp.route('/admin/users', methods=['GET'])
@admin_required
def get_users():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)

    query = User.query
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (User.username.ilike(search_pattern)) |
            (User.last_name.ilike(search_pattern)) |
            (User.first_name.ilike(search_pattern)) |
            (User.middle_name.ilike(search_pattern))
        )

    paginated_users = query.paginate(page=page, per_page=per_page, error_out=False)
    users = [{
        'id': user.id,
        'username': user.username,
        'role': user.role,
        'last_name': user.last_name,
        'first_name': user.first_name,
        'middle_name': user.middle_name,
        'full_name': user.full_name,
    } for user in paginated_users.items]

    return jsonify({
        'users': users,
        'pages': paginated_users.pages,
        'total': paginated_users.total
    }), 200

@bp.route('/admin/users/<int:user_id>', methods=['PUT'])
@admin_required
def update_user(user_id):
    user = User.query.get_or_404(user_id)
    data = request.get_json()

    user.username = data.get('username', user.username)
    user.role = data.get('role', user.role)
    user.last_name = data.get('last_name', user.last_name)
    user.first_name = data.get('first_name', user.first_name)
    user.middle_name = data.get('middle_name', user.middle_name)

    if 'new_password' in data and data['new_password']:
        user.set_password(data['new_password'])

    try:
        db.session.commit()
        return jsonify({
            'message': 'Пользователь успешно обновлён',
            'user': {
                'id': user.id,
                'username': user.username,
                'role': user.role,
                'last_name': user.last_name,
                'first_name': user.first_name,
                'middle_name': user.middle_name
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при обновлении пользователя {user_id}: {str(e)}")
        return jsonify({"error": "Ошибка при обновлении пользователя. Попробуйте позже."}), 500

@bp.route('/admin/users/<int:user_id>', methods=['DELETE'])
@admin_required
def delete_user(user_id):
    user = User.query.get_or_404(user_id)

    if user.id == current_user.id:
        return jsonify({"error": "Нельзя удалить самого себя."}), 400

    try:
        db.session.delete(user)
        db.session.commit()
        return jsonify({"message": "Пользователь успешно удалён."}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при удалении пользователя {user_id}: {str(e)}")
        return jsonify({"error": "Ошибка при удалении пользователя. Попробуйте позже."}), 500

@bp.route('/admin/publications', methods=['GET'])
@admin_or_manager_required
def get_publications():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)
    pub_type = request.args.get('type', 'all', type=str)
    status = request.args.get('status', 'all', type=str)
    sort_status = request.args.get('sort_status', None, type=str)
    sort_by = request.args.get('sort_by', 'updated_at', type=str)
    sort_order = request.args.get('sort_order', 'desc', type=str)

    query = Publication.query

    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (Publication.title.ilike(search_pattern)) |
            (Publication.authors.ilike(search_pattern)) |
            (db.cast(Publication.year, db.String).ilike(search_pattern))
        )

    if pub_type != 'all':
        type_ = PublicationType.query.filter_by(name=pub_type).first()
        if type_:
            query = query.filter_by(type_id=type_.id)
        else:
            return jsonify({'error': 'Invalid publication type'}), 400

    valid_statuses = ['draft', 'needs_review', 'returned_for_revision', 'published']
    if status != 'all':
        status_list = status.split(',')
        filtered_statuses = [s for s in status_list if s in valid_statuses]
        if not filtered_statuses:
            return jsonify({"error": "Указаны недопустимые статусы"}), 400
        query = query.filter(Publication.status.in_(filtered_statuses))
    else:
        filtered_statuses = valid_statuses

    if current_user.role == 'manager':
        allowed_statuses = ['needs_review', 'returned_for_revision', 'published']
        query = query.filter(Publication.status.in_(allowed_statuses))
        filtered_statuses = allowed_statuses

    valid_sort_fields = ['id', 'title', 'year', 'updated_at', 'published_at']
    if sort_by not in valid_sort_fields:
        sort_by = 'updated_at'
    sort_column = getattr(Publication, sort_by)

    if sort_order == 'desc':
        sort_column = sort_column.desc()
    else:
        sort_column = sort_column.asc()

    if sort_status and sort_status in filtered_statuses:
        sort_case = db.case(
            {sort_status: 0},
            value=Publication.status,
            else_=1
        ).label('status_priority')
        query = query.order_by(sort_case, sort_column)
    else:
        query = query.order_by(sort_column)

    try:
        paginated_publications = query.paginate(page=page, per_page=per_page, error_out=False)
    except Exception as e:
        logger.error(f"Ошибка пагинации: {str(e)}")
        return jsonify({"error": "Ошибка сервера при загрузке публикаций"}), 500

    publications = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': {
            'id': pub.type.id,
            'name': pub.type.name,
            'display_name': pub.type.display_name
        } if pub.type else None,
        'status': pub.status,
        'file_url': pub.file_url,
        'user': {
            'id': pub.user.id if pub.user else None,
            'full_name': pub.user.full_name if pub.user else None
        },
        'returned_for_revision': pub.returned_for_revision,
        'published_at': pub.published_at.isoformat() if pub.published_at else None,
        'updated_at': pub.updated_at.isoformat() if pub.updated_at else None
    } for pub in paginated_publications.items]

    return jsonify({
        'publications': publications,
        'pages': paginated_publications.pages,
        'total': paginated_publications.total
    }), 200
@bp.route('/admin/publications/<int:pub_id>', methods=['PUT'])
@admin_or_manager_required
def update_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)

    if 'file' in request.files:
        file = request.files['file']
        if file and allowed_file(file.filename):
            if publication.file_url:
                old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                if os.path.exists(old_file_path):
                    os.remove(old_file_path)
            filename = secure_filename(file.filename)
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
            if os.path.exists(file_path):
                base, extension = os.path.splitext(filename)
                counter = 1
                while os.path.exists(file_path):
                    filename = f"{base}_{counter}{extension}"
                    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                    counter += 1
            try:
                file.save(file_path)
                publication.file_url = f"/uploads/{filename}"
            except Exception as e:
                logger.error(f"Ошибка при сохранении файла: {str(e)}")
                return jsonify({"error": "Ошибка при сохранении файла. Попробуйте снова."}), 500

    data = request.form if 'file' in request.files else request.get_json()
    publication.title = data.get('title', publication.title)
    publication.authors = data.get('authors', publication.authors)
    publication.year = int(data.get('year', publication.year))
    type_name = data.get('type')  # Ожидаем name типа
    if type_name:
        type_ = PublicationType.query.filter_by(name=type_name).first()
        if type_:
            publication.type_id = type_.id
        else:
            return jsonify({'error': 'Invalid publication type'}), 400
    new_status = data.get('status', publication.status)
    comment = data.get('return_comment', '')

    if new_status != publication.status:
        timestamp = datetime.utcnow()
        if new_status == 'published':
            publication.published_at = timestamp
            publication.returned_for_revision = False
            publication.returned_at = None
            publication.return_comment = None
            action_type = 'published'
        elif new_status == 'returned_for_revision':
            publication.returned_for_revision = True
            publication.returned_at = timestamp
            publication.return_comment = comment
            action_type = 'returned'
        else:
            action_type = new_status
            if publication.status in ['published', 'returned_for_revision']:
                publication.published_at = None
                publication.returned_at = None
                publication.return_comment = None
                publication.returned_for_revision = False

        action = PublicationActionHistory(
            publication_id=publication.id,
            user_id=current_user.id,
            action_type=action_type,
            timestamp=timestamp,
            comment=comment if comment.strip() else None
        )
        db.session.add(action)

    publication.status = new_status

    try:
        db.session.commit()
        logger.debug(f"Публикация {pub_id} обновлена пользователем {current_user.id}, новый статус: {new_status}")
        return jsonify({
            'message': 'Публикация успешно обновлена',
            'publication': publication.to_dict()
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при обновлении публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при обновлении публикации. Попробуйте позже."}), 500
@bp.route('/admin/publications/<int:pub_id>', methods=['DELETE'])
@admin_or_manager_required
def delete_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    try:
        if publication.file_url:
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
            if os.path.exists(file_path):
                os.remove(file_path)

        db.session.delete(publication)
        db.session.commit()
        return jsonify({"message": "Публикация успешно удалена."}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при удалении публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при удалении публикации. Попробуйте позже."}), 500

@bp.route('/admin/publications/needs-review', methods=['GET'])
@admin_or_manager_required
def get_needs_review_publications():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)

    query = Publication.query.filter_by(status='needs_review')
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (Publication.title.ilike(search_pattern)) |
            (Publication.authors.ilike(search_pattern)) |
            (Publication.year.ilike(search_pattern))
        )

    paginated_publications = query.paginate(page=page, per_page=per_page, error_out=False)

    publications = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'user': {
            'id': pub.user.id if pub.user else None,
            'full_name': pub.user.full_name if pub.user else None
        },
        'returned_for_revision': pub.returned_for_revision,
        'published_at': pub.published_at.isoformat() if pub.published_at else None
    } for pub in paginated_publications.items]

    return jsonify({
        'publications': publications,
        'pages': paginated_publications.pages,
        'total': paginated_publications.total
    }), 200 

@bp.route('/admin/register', methods=['POST'])
@admin_or_manager_required
def register():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    last_name = data.get('last_name')
    first_name = data.get('first_name')
    middle_name = data.get('middle_name')

    if not username or not password:
        return jsonify({"error": "Логин и пароль обязательны."}), 400

    existing_user = User.query.filter_by(username=username).first()
    if existing_user:
        return jsonify({"error": "Пользователь с таким логином уже существует."}), 400

    new_user = User(
        username=username,
        last_name=last_name,
        first_name=first_name,
        middle_name=middle_name,
    )
    new_user.set_password(password)

    try:
        db.session.add(new_user)
        db.session.commit()
        logger.debug(f"User registered successfully: {username}, response: {'Пользователь успешно зарегистрирован.'}")
        return jsonify({"message": "Пользователь успешно зарегистрирован."}), 201
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при регистрации пользователя {username}: {str(e)}")
        return jsonify({"error": "Ошибка при регистрации. Попробуйте позже."}), 500

@bp.route('/admin/check-username', methods=['POST'])
@admin_or_manager_required
def check_username():
    data = request.get_json()
    username = data.get('username')
    user = User.query.filter_by(username=username).first()
    return jsonify({'exists': user is not None})

@bp.route('/admin/generate-password', methods=['GET'])
@admin_or_manager_required
def generate_password():
    import secrets
    import string
    # Используем только буквы (строчные и заглавные) и цифры
    characters = string.ascii_letters + string.digits
    password = ''.join(secrets.choice(characters) for _ in range(12))
    return jsonify({'password': password})

@bp.route('/admin/plans', methods=['GET'])
@admin_or_manager_required
def get_all_plans():
    logger.debug(f"Получен GET запрос для /admin_api/admin/plans")
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    pagination = Plan.query.order_by(Plan.year.desc()).paginate(page=page, per_page=per_page)
    plans = pagination.items
    return jsonify({
        'plans': [plan.to_dict() for plan in plans],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/admin/plans/<int:plan_id>', methods=['PUT'])
@admin_required
def update_plan(plan_id):
    logger.debug(f"Получен PUT запрос для /admin_api/admin/plans/{plan_id}")
    plan = Plan.query.get_or_404(plan_id)
    data = request.get_json()
    if not all(k in data for k in ('year', 'expectedCount', 'fillType', 'user_id', 'entries')):
        return jsonify({'error': 'Missing required fields'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Invalid year'}), 400
    
    if not isinstance(data['expectedCount'], int) or data['expectedCount'] < 1:
        return jsonify({'error': 'Expected count must be at least 1'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Invalid fill type'}), 400

    plan.year = data['year']
    plan.expectedCount = data['expectedCount']
    plan.fillType = data['fillType']
    plan.user_id = data['user_id']

    PlanEntry.query.filter_by(plan_id=plan.id).delete()
    for entry_data in data['entries']:
        entry = PlanEntry(
            title=entry_data.get('title'),
            type=entry_data.get('type'),
            publication_id=entry_data.get('publication_id'),
            status=entry_data.get('status', 'planned'),
            plan=plan
        )
        if entry.publication_id:
            publication = Publication.query.filter_by(id=entry.publication_id, user_id=plan.user_id, status='published').first()
            if not publication:
                db.session.rollback()
                return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
        db.session.add(entry)

    db.session.commit()
    return jsonify({'message': 'Plan updated successfully', 'plan': plan.to_dict()}), 200

@bp.route('/admin/plans/<int:plan_id>', methods=['DELETE'])
@admin_required
def delete_plan(plan_id):
    logger.debug(f"Получен DELETE запрос для /admin_api/admin/plans/{plan_id}")
    plan = Plan.query.get_or_404(plan_id)
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'Cannot delete plan that is under review or approved'}), 403
    
    db.session.delete(plan)
    db.session.commit()
    return jsonify({'message': 'Plan deleted successfully'}), 200

@bp.route('/admin/plans/<int:plan_id>/approve', methods=['POST'])
@admin_or_manager_required
def approve_plan(plan_id):
    plan = Plan.query.get_or_404(plan_id)
    plan.status = 'approved'
    plan.approved_at = datetime.utcnow()
    # Не сбрасываем returned_at и return_comment

    # Добавляем запись в историю
    action = PlanActionHistory(
        plan_id=plan.id,
        action_type='approved',
        timestamp=plan.approved_at,
        user_id=current_user.id  # Кто утвердил
    )
    db.session.add(action)
    db.session.commit()
    return jsonify({"message": "План утверждён"}), 200
@bp.route('/admin/plans/<int:plan_id>/return-for-revision', methods=['POST'])
@admin_or_manager_required
def return_plan_for_revision(plan_id):
    plan = Plan.query.get_or_404(plan_id)
    data = request.get_json()
    comment = data.get('comment', '')
    plan.status = 'returned'
    plan.return_comment = comment
    plan.returned_at = datetime.utcnow()
    # Не сбрасываем approved_at

    # Добавляем запись в историю
    action = PlanActionHistory(
        plan_id=plan.id,
        action_type='returned',
        timestamp=plan.returned_at,
        comment=comment,
        user_id=current_user.id  # Кто вернул
    )
    db.session.add(action)
    db.session.commit()
    return jsonify({"message": "План возвращён на доработку"}), 200
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in {'pdf', 'docx'}

def get_publications_by_year(user_id):
    publications = Publication.query.filter_by(user_id=user_id).all()
    yearly_counts = {}
    for pub in publications:
        year = pub.year
        yearly_counts[year] = yearly_counts.get(year, 0) + 1
    return sorted(yearly_counts.items(), key=lambda x: x[0])


@bp.route('/admin/plan-action-history', methods=['GET'])
@admin_or_manager_required
def get_plan_action_history():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    start_date = request.args.get('start_date', type=str)
    end_date = request.args.get('end_date', type=str)

    # Базовый запрос к истории действий
    query = PlanActionHistory.query.join(Plan).filter(
        PlanActionHistory.action_type.in_(['approved', 'returned'])
    )

    # Фильтрация по датам
    if start_date:
        try:
            start_datetime = datetime.strptime(start_date, '%Y-%m-%d')
            query = query.filter(PlanActionHistory.timestamp >= start_datetime)
        except ValueError as e:
            logger.error(f"Некорректный формат start_date: {start_date}, ошибка: {str(e)}")
            return jsonify({"error": "Некорректный формат даты начала"}), 400

    if end_date:
        try:
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            query = query.filter(PlanActionHistory.timestamp <= end_datetime)
        except ValueError as e:
            logger.error(f"Некорректный формат end_date: {end_date}, ошибка: {str(e)}")
            return jsonify({"error": "Некорректный формат даты окончания"}), 400

    # Сортировка по убыванию (новые действия первыми)
    query = query.order_by(desc(PlanActionHistory.timestamp))

    # Пагинация
    paginated_actions = query.paginate(page=page, per_page=per_page, error_out=False)
    
    logger.debug(f"Найдено действий: {paginated_actions.total}")
    for action in paginated_actions.items:
        logger.debug(f"Действие ID={action.id}, план ID={action.plan_id}, тип={action.action_type}, время={action.timestamp}")

    # Формируем историю
    history = []
    for action in paginated_actions.items:
        history.append({
            'id': action.plan_id,  # ID плана
            'year': action.plan.year,
            'action_type': action.action_type,
            'timestamp': action.timestamp.isoformat(),
            'comment': action.comment,
            'user_full_name': action.plan.user.full_name if action.plan.user else "Не указан"
        })

    return jsonify({
        'history': history,
        'pages': paginated_actions.pages,
        'total': paginated_actions.total
    }), 200


@bp.route('admin/plans/needs-review', methods=['GET'])
@login_required
def get_needs_review_plans():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    
    # Запрос планов со статусом 'needs_review'
    plans_query = Plan.query.filter_by(status='needs_review')
    pagination = plans_query.paginate(page=page, per_page=per_page, error_out=False)
    
    plans = [plan.to_dict() for plan in pagination.items]
    
    return jsonify({
        'plans': plans,
        'pages': pagination.pages,
        'total': pagination.total
    })


from sqlalchemy import case, or_, desc, func

@bp.route('/admin/publication-action-history', methods=['GET'])
@admin_or_manager_required
def get_publication_action_history():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    start_date = request.args.get('start_date', type=str)
    end_date = request.args.get('end_date', type=str)

    query = PublicationActionHistory.query.join(Publication).filter(
        PublicationActionHistory.action_type.in_(['approved', 'returned'])
    )

    if start_date:
        try:
            start_datetime = datetime.strptime(start_date, '%Y-%m-%d')
            query = query.filter(PublicationActionHistory.timestamp >= start_datetime)
        except ValueError:
            return jsonify({"error": "Некорректный формат даты начала"}), 400

    if end_date:
        try:
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            query = query.filter(PublicationActionHistory.timestamp <= end_datetime)
        except ValueError:
            return jsonify({"error": "Некорректный формат даты окончания"}), 400

    query = query.order_by(db.desc(PublicationActionHistory.timestamp))
    paginated_actions = query.paginate(page=page, per_page=per_page, error_out=False)

    history = [{
        'id': action.publication_id,
        'title': action.publication.title,
        'action_type': action.action_type,
        'timestamp': action.timestamp.isoformat(),
        'comment': action.comment,
        'user_full_name': action.user.full_name if action.user else "Не указан"
    } for action in paginated_actions.items]

    return jsonify({
        'history': history,
        'pages': paginated_actions.pages,
        'total': paginated_actions.total
    }), 200

@bp.route('/admin/statistics', methods=['GET'])
@admin_or_manager_required
def get_statistics():
    year = request.args.get('year', type=int, default=datetime.utcnow().year)
    logger.debug(f"Получен GET запрос для /admin_api/admin/statistics?year={year}")

    try:
        # Получаем все типы публикаций из базы данных
        publication_types = PublicationType.query.all()
        type_names = [t.name for t in publication_types]

        # Получаем всех пользователей с ролью 'user'
        users = User.query.filter_by(role='user').all()
        result = []

        for user in users:
            # Инициализируем словари для плана и факта с динамическими типами
            plan_data = {type_name: 0 for type_name in type_names}
            actual_data = {type_name: 0 for type_name in type_names}

            # Находим утверждённый план пользователя за указанный год
            plan = Plan.query.filter_by(user_id=user.id, year=year, status='approved').first()

            if plan:
                # Подсчитываем записи плана по типам
                for entry in plan.entries:
                    if entry.type and entry.type.name in plan_data:
                        plan_data[entry.type.name] += 1

                # Подсчитываем привязанные опубликованные публикации
                entries_with_publications = (
                    db.session.query(PlanEntry.type_id, func.count().label('count'))
                    .join(Publication, PlanEntry.publication_id == Publication.id)
                    .join(PublicationType, PlanEntry.type_id == PublicationType.id)
                    .filter(
                        PlanEntry.plan_id == plan.id,
                        Publication.status == 'published'
                    )
                    .group_by(PlanEntry.type_id)
                    .all()
                )

                # Обновляем actual_data на основе типа публикации
                for type_id, count in entries_with_publications:
                    type_record = PublicationType.query.get(type_id)
                    if type_record and type_record.name in actual_data:
                        actual_data[type_record.name] = count

            # Формируем результат для пользователя
            result.append({
                'user_id': user.id,
                'full_name': user.full_name or user.username,
                'username': user.username,
                'plan': plan_data,
                'actual': actual_data
            })

        logger.debug(f"Возвращаем статистику: {result}")
        return jsonify(result), 200

    except Exception as e:
        logger.error(f"Ошибка в get_statistics: {str(e)}")
        return jsonify({"error": "Ошибка сервера при получении статистики. Попробуйте позже."}), 500
@bp.route('/admin/publication-types', methods=['GET'])
@admin_or_manager_required
def get_publication_types():
    types = PublicationType.query.all()
    return jsonify([{
        'id': t.id,
        'name': t.name,
        'display_name': t.display_name
    } for t in types]), 200

@bp.route('/admin/publication-types', methods=['POST'])
@admin_or_manager_required
def create_publication_type():
    data = request.get_json()
    name = data.get('name')
    display_name = data.get('display_name')
    if not name or not display_name:
        return jsonify({'error': 'Name and display_name are required'}), 400
    if PublicationType.query.filter_by(name=name).first():
        return jsonify({'error': 'Type with this name already exists'}), 400
    new_type = PublicationType(name=name, display_name=display_name)
    db.session.add(new_type)
    db.session.commit()
    return jsonify({
        'message': 'Type created',
        'type': {'id': new_type.id, 'name': new_type.name, 'display_name': new_type.display_name}
    }), 201

@bp.route('/admin/publication-types/<int:type_id>', methods=['PUT'])
@admin_or_manager_required
def update_publication_type(type_id):
    type_ = PublicationType.query.get_or_404(type_id)
    data = request.get_json()
    name = data.get('name')
    display_name = data.get('display_name')
    if name and name != type_.name and PublicationType.query.filter_by(name=name).first():
        return jsonify({'error': 'Type with this name already exists'}), 400
    type_.name = name or type_.name
    type_.display_name = display_name or type_.display_name
    db.session.commit()
    return jsonify({
        'message': 'Type updated',
        'type': {'id': type_.id, 'name': type_.name, 'display_name': type_.display_name}
    }), 200

@bp.route('/admin/publication-types/<int:type_id>', methods=['DELETE'])
@admin_or_manager_required
def delete_publication_type(type_id):
    type_ = PublicationType.query.get_or_404(type_id)
    if Publication.query.filter_by(type_id=type_id).first() or PlanEntry.query.filter_by(type_id=type_id).first():
        return jsonify({'error': 'Cannot delete type that is in use'}), 400
    db.session.delete(type_)
    db.session.commit()
    return jsonify({'message': 'Type deleted'}), 200

		
Скидываю файлы заного, упустил еще один 
D:\publication-system\backend\app\routes.py

from flask import Blueprint, jsonify, request, make_response, current_app, send_file
from .extensions import db, login_manager, csrf
from .models import User, Publication, Comment, Plan, PlanEntry
from .utils import allowed_file
from flask_login import login_user, current_user, logout_user, login_required
from werkzeug.utils import secure_filename
from flask_wtf.csrf import generate_csrf
import os
from .analytics import get_publications_by_year
import bibtexparser
from reportlab.platypus import SimpleDocTemplate, Paragraph
from reportlab.lib.pagesizes import letter
from bibtexparser.bibdatabase import BibDatabase
from bibtexparser.bwriter import BibTexWriter
import logging
from datetime import datetime, UTC
from werkzeug.security import generate_password_hash, check_password_hash

bp = Blueprint('api', __name__, url_prefix='/api')

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

@bp.route('/uploads/<path:filename>')
def download_file(filename):
    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
    logger.debug(f"Serving file from {file_path}")
    if not os.path.exists(file_path):
        logger.error(f"File not found: {file_path}")
        return jsonify({'error': 'Файл не найден'}), 404
    response = send_file(file_path, as_attachment=True)
    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

@bp.route('/publications/<int:pub_id>', methods=['GET'])
@login_required
def get_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)

    if publication.user_id != current_user.id and current_user.role not in ['admin', 'manager']:
        logger.warning(f"Unauthorized access attempt to publication {pub_id} by user {current_user.id} with role {current_user.role}")
        return jsonify({"error": "У вас нет прав для просмотра этой публикации."}), 403

    comments = Comment.query.filter_by(publication_id=pub_id, parent_id=None).order_by(Comment.created_at.asc()).all()
    
    def build_comment_tree(comment):
        return {
            'id': comment.id,
            'content': comment.content,
            'user': {'username': comment.user.username, 'full_name': comment.user.full_name, 'role': comment.user.role},
            'created_at': comment.created_at.isoformat(),
            'replies': [build_comment_tree(reply) for reply in comment.replies]
        }
    
    return jsonify({
        'id': publication.id,
        'title': publication.title,
        'authors': publication.authors,
        'year': publication.year,
        'type': publication.type,
        'status': publication.status,
        'file_url': publication.file_url if publication.file_url else None,
        'user': {
            'id': publication.user.id if publication.user else None,
            'full_name': publication.user.full_name if publication.user else None},
        'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
        'published_at': publication.published_at.isoformat() if publication.published_at else None,
        'returned_for_revision': publication.returned_for_revision,
        'comments': [build_comment_tree(comment) for comment in comments]
    }), 200

@bp.route('/publications/<int:pub_id>/comments', methods=['POST'])
@login_required
def add_comment(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    data = request.get_json()
    content = data.get('content')
    parent_id = data.get('parent_id')

    if not content:
        return jsonify({'error': 'Комментарий не может быть пустым'}), 400

    comment = Comment(
        content=content,
        user_id=current_user.id,
        publication_id=pub_id,
        parent_id=parent_id if parent_id else None
    )
    db.session.add(comment)
    db.session.commit()

    return jsonify({
        'message': 'Комментарий добавлен',
        'comment': {
            'id': comment.id,
            'content': comment.content,
            'user': {'username': current_user.username, 'full_name': current_user.full_name, 'role': current_user.role},
            'created_at': comment.created_at.isoformat(),
            'replies': []
        }
    }), 201

@bp.route('/publications/<int:pub_id>/submit-for-review', methods=['POST'])
@login_required
def submit_for_review(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    
    if publication.user_id != current_user.id:
        logger.warning(f"Несанкционированная попытка отправить публикацию {pub_id} на проверку пользователем {current_user.id}")
        return jsonify({'error': 'У вас нет прав на отправку этой публикации на проверку'}), 403

    if publication.status not in ['draft', 'returned_for_revision']:
        logger.debug(f"Публикация {pub_id} со статусом {publication.status} не может быть отправлена на проверку")
        return jsonify({'error': 'Публикация уже отправлена на проверку или опубликована'}), 400

    if not publication.file_url:
        logger.debug(f"Попытка отправить публикацию {pub_id} без файла")
        return jsonify({'error': 'Нельзя отправить на проверку публикацию без прикреплённого файла'}), 400

    publication.status = 'needs_review'
    publication.updated_at = datetime.utcnow()
    publication.returned_for_revision = False

    try:
        db.session.commit()
        logger.debug(f"Публикация {pub_id} успешно отправлена на проверку пользователем {current_user.id}")
        return jsonify({'message': 'Публикация отправлена на проверку'}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка отправки на проверку публикации {pub_id}: {str(e)}")
        return jsonify({'error': 'Ошибка при отправке на проверку. Попробуйте позже.'}), 500

@bp.route('/publications/<int:pub_id>/publish', methods=['POST'])
@login_required
def publish_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)

    if current_user.role not in ['admin', 'manager']:
        logger.warning(f"Несанкционированная попытка опубликовать публикацию {pub_id} пользователем {current_user.id} с ролью {current_user.role}")
        return jsonify({"error": "У вас нет прав для публикации этой работы."}), 403

    if publication.status != 'needs_review':
        return jsonify({"error": "Публикация не находится на стадии проверки."}), 400

    if not publication.file_url:
        return jsonify({"error": "Нельзя опубликовать работу без прикреплённого файла."}), 400

    publication.status = 'published'
    publication.published_at = datetime.utcnow()
    publication.returned_for_revision = False

    try:
        db.session.commit()
        logger.debug(f"Публикация {pub_id} успешно опубликована пользователем {current_user.id}")
        return jsonify({
            'message': 'Публикация успешно опубликована',
            'publication': {
                'id': publication.id,
                'title': publication.title,
                'status': publication.status,
                'published_at': publication.published_at.isoformat()
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при публикации публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при публикации. Попробуйте позже."}), 500

@bp.route('/publications/<int:pub_id>/return-for-revision', methods=['POST'])
@login_required
def return_for_revision(pub_id):
    publication = Publication.query.get_or_404(pub_id)

    if current_user.role not in ['admin', 'manager']:
        logger.warning(f"Несанкционированная попытка вернуть публикацию {pub_id} на доработку пользователем {current_user.id} с ролью {current_user.role}")
        return jsonify({"error": "У вас нет прав для возврата этой работы на доработку."}), 403

    if publication.status != 'needs_review':
        return jsonify({"error": "Публикация не находится на стадии проверки."}), 400

    comments = Comment.query.filter_by(publication_id=pub_id).all()
    has_reviewer_comment = any(
        comment.user.role in ['admin', 'manager'] or any(reply.user.role in ['admin', 'manager'] for reply in comment.replies)
        for comment in comments
    )
    if not has_reviewer_comment:
        return jsonify({"error": "Необходимо добавить комментарий перед возвратом на доработку."}), 400

    # Исправляем статус на 'returned_for_revision'
    publication.status = 'returned_for_revision'
    publication.returned_for_revision = True
    publication.published_at = None

    try:
        db.session.commit()
        logger.debug(f"Публикация {pub_id} возвращена на доработку пользователем {current_user.id}")
        return jsonify({
            'message': 'Публикация отправлена на доработку',
            'publication': {
                'id': publication.id,
                'title': publication.title,
                'status': publication.status,
                'returned_for_revision': publication.returned_for_revision
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при возврате публикации {pub_id} на доработку: {str(e)}")
        return jsonify({"error": "Ошибка при возврате на доработку. Попробуйте позже."}), 500
@bp.route('/login', methods=['POST'])
@csrf.exempt
def login():
    logger.debug(f"Получен POST запрос для /login")
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    user = User.query.filter_by(username=username).first()
    if user and check_password_hash(user.password_hash, password):
        login_user(user, remember=True)
        return jsonify({
            'message': 'Успешная авторизация',
            'user': {
                'id': user.id,
                'username': user.username,
                'role': user.role,
                'last_name': user.last_name,
                'first_name': user.first_name,
                'middle_name': user.middle_name
            }
        }), 200
    return jsonify({'error': 'Неверное имя пользователя или пароль'}), 401

@bp.route('/csrf-token', methods=['GET'])
def get_csrf_token():
    logger.debug(f"Получен GET запрос для /api/csrf-token")
    token = generate_csrf()
    return jsonify({'csrf_token': token}), 200

@bp.route('/logout', methods=['POST'])
@login_required
def logout():
    logger.debug(f"Получен POST запрос для /logout")
    logout_user()
    response = jsonify({'message': 'Успешный выход'})
    response.set_cookie('session', '', expires=0)
    return response, 200

@bp.route('/user', methods=['GET', 'PUT'])
@login_required
def user():
    logger.debug(f"Получен {request.method} запрос для /user")
    logger.debug(f"Текущий пользователь: {current_user.id if current_user.is_authenticated else 'Не аутентифицирован'}")
    logger.debug(f"Куки сессии: {request.cookies.get('session')}")
    if request.method == 'GET':
        response_data = {
            'id': current_user.id,
            'username': current_user.username,
            'role': current_user.role,
            'last_name': current_user.last_name,
            'first_name': current_user.first_name,
            'middle_name': current_user.middle_name,
            'created_at': current_user.created_at.isoformat() if current_user.created_at else None
        }
        logger.debug(f"Ответ сервера для /api/user: {response_data}")
        return jsonify(response_data), 200
    elif request.method == 'PUT':
        data = request.get_json()
        current_user.last_name = data.get('last_name', current_user.last_name)
        current_user.first_name = data.get('first_name', current_user.first_name)
        current_user.middle_name = data.get('middle_name', current_user.middle_name)
        try:
            db.session.commit()
            return jsonify({
                'message': 'Данные пользователя успешно обновлены',
                'user': {
                    'id': current_user.id,
                    'username': current_user.username,
                    'role': current_user.role,
                    'last_name': current_user.last_name,
                    'first_name': current_user.first_name,
                    'middle_name': current_user.middle_name
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка обновления данных пользователя {current_user.id}: {str(e)}")
            return jsonify({"error": "Ошибка при обновлении данных. Попробуйте позже."}), 500

@bp.route('/user/password', methods=['PUT'])
@login_required
def change_password():
    logger.debug(f"Получен PUT запрос для /user/password")
    data = request.get_json()
    current_password = data.get('current_password')
    new_password = data.get('new_password')

    if not check_password_hash(current_user.password_hash, current_password):
        return jsonify({'error': 'Текущий пароль неверен'}), 401

    current_user.password_hash = generate_password_hash(new_password)
    try:
        db.session.commit()
        return jsonify({'message': 'Пароль успешно изменён'}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка изменения пароля для пользователя {current_user.id}: {str(e)}")
        return jsonify({"error": "Ошибка при изменении пароля. Попробуйте позже."}), 500

@bp.route('/public/publications', methods=['GET'])
def get_public_publications():
    logger.debug(f"Получен GET запрос для /api/public/publications")
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)

    query = Publication.query.filter_by(status='published').order_by(
        db.func.coalesce(Publication.published_at, Publication.updated_at).desc()
    )

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    publications = pagination.items

    logger.debug(f"Returning {len(publications)} published publications, sorted by published_at/updated_at: {[pub.published_at.isoformat() if pub.published_at else pub.updated_at.isoformat() for pub in publications]}")
    logger.debug(f"Total published publications: {pagination.total}, pages: {pagination.pages}, current page: {pagination.page}")

    response = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'updated_at': pub.updated_at.isoformat() if pub.updated_at else None,
        'published_at': pub.published_at.isoformat() if pub.published_at else None,
        'returned_for_revision': pub.returned_for_revision,
        'user': {
            'full_name': pub.user.full_name if pub.user else 'Не указан'
        } if pub.user else None
    } for pub in publications]

    return jsonify({
        'publications': response,
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/publications', methods=['GET'])
@login_required
def get_publications():
    logger.debug(f"Получен GET запрос для /publications")
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '').lower()
    pub_type = request.args.get('type', 'all')
    status = request.args.get('status', 'all')

    query = Publication.query.filter_by(user_id=current_user.id)

    total_records_before_filters = query.count()
    logger.debug(f"Total records before filters: {total_records_before_filters}")

    if search:
        query = query.filter(
            db.or_(
                Publication.title.ilike(f'%{search}%'),
                Publication.authors.ilike(f'%{search}%'),
                db.cast(Publication.year, db.String).ilike(f'%{search}%')
            )
        )

    total_records_after_search = query.count()
    logger.debug(f"Total records after search: {total_records_after_search}")

    if pub_type != 'all':
        query = query.filter(Publication.type == pub_type)

    total_records_after_type = query.count()
    logger.debug(f"Total records after type filter: {total_records_after_type}")

    if status != 'all':
        query = query.filter(Publication.status == status)

    total_records_after_status = query.count()
    logger.debug(f"Total records after status filter: {total_records_after_status}")

    query = query.order_by(Publication.updated_at.desc())

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    publications = pagination.items

    logger.debug(f"Publications on page {page}: {len(publications)}")

    response = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'updated_at': pub.updated_at.isoformat() if pub.updated_at else None,
        'returned_for_revision': pub.returned_for_revision,
    } for pub in publications]

    return jsonify({
        'publications': response,
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/publications/<int:pub_id>', methods=['PUT', 'DELETE'])
@login_required
def manage_publication(pub_id):
    logger.debug(f"Получен {request.method} запрос для /publications/{pub_id}")
    publication = Publication.query.get_or_404(pub_id)
    if publication.user_id != current_user.id:
        return jsonify({'error': 'У вас нет прав на управление этой публикацией'}), 403

    if publication.status == 'needs_review':
        return jsonify({'error': 'Нельзя редактировать публикацию, пока она на проверке'}), 403

    if request.method == 'PUT':
        if request.content_type == 'application/json':
            data = request.get_json()
        elif 'file' in request.files or request.content_type.startswith('multipart/form-data'):
            data = request.form
        else:
            return jsonify({"error": "Неподдерживаемый формат данных. Используйте application/json или multipart/form-data."}), 415

        old_status = publication.status

        if 'file' in request.files:
            file = request.files['file']
            if file and allowed_file(file.filename):
                if publication.file_url:
                    old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                    if os.path.exists(old_file_path):
                        os.remove(old_file_path)
                filename = secure_filename(file.filename)
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                if os.path.exists(file_path):
                    base, extension = os.path.splitext(filename)
                    counter = 1
                    while os.path.exists(file_path):
                        filename = f"{base}_{counter}{extension}"
                        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                        counter += 1
                file.save(file_path)
                publication.file_url = f"/uploads/{filename}"

        publication.title = data.get('title', publication.title)
        publication.authors = data.get('authors', publication.authors)
        publication.year = data.get('year', publication.year)
        publication.type = data.get('type', publication.type)
        new_status = data.get('status', publication.status)

        if new_status == 'published' and not publication.file_url:
            return jsonify({'error': 'Нельзя опубликовать работу без прикреплённого файла.'}), 400

        publication.status = new_status

        if publication.status == 'published' and old_status != 'published':
            publication.published_at = datetime.utcnow()

        try:
            db.session.commit()
            return jsonify({
                'message': 'Публикация успешно обновлена',
                'publication': {
                    'id': publication.id,
                    'title': publication.title,
                    'authors': publication.authors,
                    'year': publication.year,
                    'type': publication.type,
                    'status': publication.status,
                    'file_url': publication.file_url,
                    'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
                    'published_at': publication.published_at.isoformat() if publication.published_at else None,
                    'returned_for_revision': publication.returned_for_revision,
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка обновления публикации {pub_id}: {str(e)}")
            return jsonify({"error": "Ошибка при обновлении публикации. Попробуйте позже."}), 500

    elif request.method == 'DELETE':
        try:
            if publication.file_url:
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                if os.path.exists(file_path):
                    os.remove(file_path)
            db.session.delete(publication)
            db.session.commit()
            return jsonify({'message': 'Публикация успешно удалена'}), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка удаления публикации {pub_id}: {str(e)}")
            return jsonify({"error": "Ошибка при удалении публикации. Попробуйте позже."}), 500

@bp.route('/publications/upload-file', methods=['POST'])
@login_required
def upload_file():
    logger.debug(f"Получен POST запрос для /publications/upload-file")
    if 'file' not in request.files:
        return jsonify({'error': 'Файл не предоставлен'}), 400

    file = request.files['file']
    if not file or not allowed_file(file.filename):
        return jsonify({'error': 'Недопустимый файл'}), 400

    title = request.form.get('title')
    authors = request.form.get('authors')
    year = request.form.get('year')
    type = request.form.get('type', 'article')
    
    if not title or not authors or not year:
        return jsonify({'error': 'Название, авторы и год обязательны'}), 400

    try:
        year = int(year)
        if year < 1900 or year > datetime.now().year:
            return jsonify({'error': 'Недопустимый год'}), 400
    except ValueError:
        return jsonify({'error': 'Год должен быть числом'}), 400

    filename = secure_filename(file.filename)
    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
    if os.path.exists(file_path):
        base, extension = os.path.splitext(filename)
        counter = 1
        while os.path.exists(file_path):
            filename = f"{base}_{counter}{extension}"
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
            counter += 1
    file.save(file_path)

    publication = Publication(
        title=title,
        authors=authors,
        year=year,
        type=type,
        status='draft',
        file_url=f"/uploads/{filename}",
        user_id=current_user.id,
        returned_for_revision=False,
    )

    db.session.add(publication)
    db.session.commit()

    return jsonify({
        'message': 'Публикация успешно загружена',
        'publication': {
            'id': publication.id,
            'title': publication.title,
            'authors': publication.authors,
            'year': publication.year,
            'type': publication.type,
            'status': publication.status,
            'file_url': publication.file_url,
            'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
            'returned_for_revision': publication.returned_for_revision,
        }
    }), 200

@bp.route('/publications/upload-bibtex', methods=['POST'])
@login_required
def upload_bibtex():
    logger.debug(f"Получен POST запрос для /publications/upload-bibtex")
    if 'file' not in request.files:
        return jsonify({'error': 'BibTeX файл не предоставлен'}), 400

    file = request.files['file']
    if file and file.filename.endswith('.bib'):
        try:
            content = file.read().decode('utf-8')
            bib_database = bibtexparser.loads(content)
            publications_added = 0

            for entry in bib_database.entries:
                title = entry.get('title', 'Без названия')
                authors = entry.get('author', 'Неизвестный автор')
                year = entry.get('year', datetime.now().year)
                try:
                    year = int(year)
                except (ValueError, TypeError):
                    year = datetime.now().year
                type = entry.get('entrytype', 'article')

                publication = Publication(
                    title=title,
                    authors=authors,
                    year=year,
                    type=type,
                    status='draft',
                    user_id=current_user.id,
                    returned_for_revision=False,
                )
                db.session.add(publication)
                publications_added += 1

            db.session.commit()
            return jsonify({'message': f'Обработано {publications_added} публикаций'}), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка обработки BibTeX: {str(e)}")
            return jsonify({'error': 'Ошибка при обработке BibTeX файла'}), 500
    return jsonify({'error': 'Недопустимый файл. Ожидается .bib'}), 400

@bp.route('/publications/<int:pub_id>/attach-file', methods=['POST'])
@login_required
def attach_file(pub_id):
    logger.debug(f"Получен POST запрос для /publications/{pub_id}/attach-file")
    publication = Publication.query.get_or_404(pub_id)
    if publication.user_id != current_user.id:
        return jsonify({'error': 'У вас нет прав на изменение этой публикации'}), 403

    if publication.status == 'needs_review':
        return jsonify({'error': 'Нельзя редактировать публикацию, пока она на проверке'}), 403

    if 'file' not in request.files:
        return jsonify({'error': 'Файл не предоставлен'}), 400

    file = request.files['file']
    if file and allowed_file(file.filename):
        if publication.file_url:
            old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
            if os.path.exists(old_file_path):
                os.remove(old_file_path)
        filename = secure_filename(file.filename)
        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
        if os.path.exists(file_path):
            base, extension = os.path.splitext(filename)
            counter = 1
            while os.path.exists(file_path):
                filename = f"{base}_{counter}{extension}"
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                counter += 1
        file.save(file_path)
        publication.file_url = f"/uploads/{filename}"

        try:
            db.session.commit()
            return jsonify({
                'message': 'Файл успешно прикреплен',
                'publication': {
                    'id': publication.id,
                    'title': publication.title,
                    'authors': publication.authors,
                    'year': publication.year,
                    'type': publication.type,
                    'status': publication.status,
                    'file_url': publication.file_url,
                    'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
                    'returned_for_revision': publication.returned_for_revision,
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка прикрепления файла к публикации {pub_id}: {str(e)}")
            return jsonify({"error": "Ошибка при прикреплении файла. Попробуйте позже."}), 500
    return jsonify({'error': 'Недопустимый файл'}), 400

@bp.route('/publications/export-bibtex', methods=['GET'])
@login_required
def export_bibtex():
    logger.debug(f"Получен GET запрос для /publications/export-bibtex")
    try:
        logger.debug("Начинаем запрос публикаций для текущего пользователя")
        publications = Publication.query.filter_by(user_id=current_user.id).all()
        logger.debug(f"Найдено публикаций: {len(publications)}")

        bib_db = BibDatabase()
        bib_db.entries = [{
            'ENTRYTYPE': pub.type or 'article',
            'ID': f'pub{pub.id}',
            'title': pub.title or 'Без названия',
            'author': pub.authors or 'Неизвестный автор',
            'year': str(pub.year) if pub.year else str(datetime.now().year)
        } for pub in publications]

        writer = BibTexWriter()
        if not callable(writer.write):
            raise AttributeError("Метод write в BibTexWriter не является callable. Проверьте версию bibtexparser.")

        bibtex_str = writer.write(bib_db)
        
        response = make_response(bibtex_str)
        response.headers['Content-Disposition'] = 'attachment; filename=publications.bib'
        response.headers['Content-Type'] = 'application/x-bibtex'
        logger.debug("BibTeX успешно сгенерирован и отправлен")
        return response
    except ImportError as e:
        logger.error(f"Ошибка импорта bibtexparser: {str(e)}")
        return jsonify({'error': 'Ошибка импорта библиотеки bibtexparser. Установите или обновите bibtexparser (>=1.4.0).'}), 500
    except AttributeError as e:
        logger.error(f"Ошибка атрибута в bibtexparser: {str(e)}")
        return jsonify({'error': 'Ошибка в библиотеке bibtexparser. Проверьте установку и версию.'}), 500
    except Exception as e:
        logger.error(f"Ошибка экспорта BibTeX: {str(e)}")
        return jsonify({'error': f'Внутренняя ошибка сервера при экспорте BibTeX: {str(e)}'}), 500

@bp.route('/analytics/yearly', methods=['GET'])
@login_required
def get_analytics_yearly():
    logger.debug(f"Получен GET запрос для /analytics/yearly")
    analytics = get_publications_by_year(current_user.id)
    return jsonify([{
        'year': year,
        'count': count
    } for year, count in analytics]), 200

@bp.route('/plans', methods=['GET'])
@login_required
def get_plans():
    logger.debug(f"Получен GET запрос для /plans")
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    plans = Plan.query.filter_by(user_id=current_user.id).order_by(Plan.year.desc()).paginate(page=page, per_page=per_page)
    return jsonify({
        'plans': [plan.to_dict() for plan in plans.items],
        'total': plans.total,
        'pages': plans.pages,
        'current_page': plans.page
    })

@bp.route('/plans', methods=['POST'])
@login_required
def create_plan():
    logger.debug(f"Получен POST запрос для /plans")
    data = request.get_json()
    if not data.get('year') or not data.get('fillType') or 'entries' not in data:
        return jsonify({'error': 'Missing required fields'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Invalid year'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Invalid fill type'}), 400

    # Проверка на существующий утверждённый план
    existing_approved_plan = Plan.query.filter_by(
        user_id=current_user.id,
        year=data['year'],
        status='approved'
    ).first()
    if existing_approved_plan:
        return jsonify({
            'error': f'У вас уже есть утверждённый план на {data["year"]} год. Создание нового плана невозможно.'
        }), 403

    plan = Plan(
        year=data['year'],
        fillType=data['fillType'],
        user_id=current_user.id,
        status='draft'
    )
    db.session.add(plan)

    for entry_data in data['entries']:
        entry = PlanEntry(
            title=entry_data.get('title'),
            type=entry_data.get('type'),
            publication_id=entry_data.get('publication_id'),
            status=entry_data.get('status', 'planned'),
            isPostApproval=False,
            plan=plan
        )
        if entry.publication_id:
            publication = Publication.query.filter_by(id=entry.publication_id, user_id=current_user.id, status='published').first()
            if not publication:
                db.session.rollback()
                return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
        db.session.add(entry)

    db.session.commit()
    return jsonify({'message': f'Plan created with ID {plan.id}', 'plan': plan.to_dict()}), 201

@bp.route('/plans/<int:plan_id>', methods=['PUT'])
@login_required
def update_plan(plan_id):
    logger.debug(f"Получен PUT запрос для /plans/{plan_id}")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    if plan.status not in ['draft', 'returned', 'approved']:
        return jsonify({'error': 'Cannot edit plan that is under review'}), 403

    data = request.get_json()
    if not all(k in data for k in ('year', 'fillType', 'entries')):
        return jsonify({'error': 'Missing required fields'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Invalid year'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Invalid fill type'}), 400

    if plan.status == 'approved':
        existing_entries = {entry.id: entry for entry in plan.entries}
        new_entries = []
        for entry_data in data['entries']:
            entry_id = entry_data.get('id')
            if entry_id and entry_id in existing_entries:
                entry = existing_entries[entry_id]
                entry.title = entry_data.get('title', entry.title)
                entry.type = entry_data.get('type', entry.type)
                entry.publication_id = entry_data.get('publication_id', entry.publication_id)
                entry.status = entry_data.get('status', entry.status)
                if entry.publication_id:
                    publication = Publication.query.filter_by(id=entry.publication_id, user_id=current_user.id, status='published').first()
                    if not publication:
                        db.session.rollback()
                        return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
            else:
                new_entry = PlanEntry(
                    title=entry_data.get('title', ''),
                    type=entry_data.get('type', 'article'),
                    publication_id=entry_data.get('publication_id'),
                    status=entry_data.get('status', 'planned'),
                    isPostApproval=True,
                    plan=plan
                )
                if new_entry.publication_id:
                    publication = Publication.query.filter_by(id=new_entry.publication_id, user_id=current_user.id, status='published').first()
                    if not publication:
                        db.session.rollback()
                        return jsonify({'error': f'Publication with ID {new_entry.publication_id} not found or not published'}), 404
                new_entries.append(new_entry)
                db.session.add(new_entry)
    else:
        plan.year = data['year']
        plan.fillType = data['fillType']
        PlanEntry.query.filter_by(plan_id=plan.id).delete()
        for entry_data in data['entries']:
            entry = PlanEntry(
                title=entry_data.get('title'),
                type=entry_data.get('type'),
                publication_id=entry_data.get('publication_id'),
                status=entry_data.get('status', 'planned'),
                isPostApproval=False,
                plan=plan
            )
            if entry.publication_id:
                publication = Publication.query.filter_by(id=entry.publication_id, user_id=current_user.id, status='published').first()
                if not publication:
                    db.session.rollback()
                    return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
            db.session.add(entry)

    db.session.commit()
    return jsonify({'message': 'Plan updated successfully', 'plan': plan.to_dict()}), 200

@bp.route('/plans/<int:plan_id>', methods=['DELETE'])
@login_required
def delete_plan(plan_id):
    logger.debug(f"Получен DELETE запрос для /plans/{plan_id}")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'Cannot delete plan that is under review or approved'}), 403

    db.session.delete(plan)
    db.session.commit()
    return jsonify({'message': 'Plan deleted successfully'}), 200

@bp.route('/plans/<int:plan_id>/submit-for-review', methods=['POST'])
@login_required
def submit_plan_for_review(plan_id):
    logger.debug(f"Получен POST запрос для /plans/{plan_id}/submit-for-review")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'План уже отправлен на проверку или утверждён'}), 400
    
    if not all(entry.title and entry.title.strip() for entry in plan.entries):
        return jsonify({'error': 'Все записи плана должны иметь заполненные заголовки'}), 400

    plan.status = 'needs_review'
    db.session.commit()
    return jsonify({'message': 'План отправлен на проверку', 'plan': plan.to_dict()}), 200

@bp.route('/plans/<int:plan_id>/entries/<int:entry_id>/link', methods=['POST'])
@login_required
def link_publication_to_plan_entry(plan_id, entry_id):
    logger.debug(f"Получен POST запрос для /plans/{plan_id}/entries/{entry_id}/link")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    entry = PlanEntry.query.filter_by(id=entry_id, plan_id=plan_id).first()
    if not entry:
        return jsonify({'error': 'Entry not found'}), 404
    
    if plan.status != 'approved':
        return jsonify({'error': 'Can only link publications to approved plans'}), 403
    
    if entry.publication_id:
        return jsonify({'error': 'Entry already linked to a publication'}), 400

    data = request.get_json()
    publication_id = data.get('publication_id')
    if not publication_id:
        return jsonify({'error': 'Publication ID is required'}), 400

    publication = Publication.query.filter_by(id=publication_id, user_id=current_user.id, status='published').first()
    if not publication:
        return jsonify({'error': f'Publication with ID {publication_id} not found or not published'}), 404

    existing_link = PlanEntry.query.filter_by(publication_id=publication_id).first()
    if existing_link:
        return jsonify({'error': f'Publication with ID {publication_id} is already linked to another plan entry'}), 400

    entry.publication_id = publication_id
    entry.status = 'completed'
    db.session.commit()
    return jsonify({'message': 'Publication linked successfully', 'entry': entry.to_dict()}), 200

@bp.route('/plans/<int:plan_id>/entries/<int:entry_id>/unlink', methods=['POST'])
@login_required
def unlink_publication_from_plan_entry(plan_id, entry_id):
    logger.debug(f"Получен POST запрос для /plans/{plan_id}/entries/{entry_id}/unlink")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    entry = PlanEntry.query.filter_by(id=entry_id, plan_id=plan_id).first()
    if not entry:
        return jsonify({'error': 'Entry not found'}), 404
    
    if plan.status != 'approved':
        return jsonify({'error': 'Can only unlink publications from approved plans'}), 403
    
    if not entry.publication_id:
        return jsonify({'error': 'No publication linked to this entry'}), 400

    entry.publication_id = None
    entry.status = 'planned'
    db.session.commit()
    return jsonify({'message': 'Publication unlinked successfully', 'entry': entry.to_dict()}), 200

D:\publication-system\backend\app\api.py
from flask import Blueprint, jsonify, request, send_file
from werkzeug.utils import secure_filename
from flask_login import login_required, current_user
from flask import current_app
from app.extensions import db
from app.models import Publication, User, Plan, PlanEntry, PlanActionHistory, PublicationActionHistory
import os
import logging
from io import BytesIO
import bibtexparser
from datetime import datetime
from sqlalchemy import or_


bp = Blueprint('admin_api', __name__, url_prefix='/admin_api')
logger = logging.getLogger(__name__)

def admin_or_manager_required(f):
    @login_required
    def wrapper(*args, **kwargs):
        if current_user.role not in ['admin', 'manager']:
            logger.warning(f"Unauthorized access attempt by user {current_user.id} with role {current_user.role}")
            return jsonify({"error": "Доступ запрещён. Требуется роль администратора или управляющего."}), 403
        return f(*args, **kwargs)
    wrapper.__name__ = f.__name__
    return wrapper

def admin_required(f):
    @login_required
    def wrapper(*args, **kwargs):
        if current_user.role != 'admin':
            logger.warning(f"Unauthorized access attempt by user {current_user.id} with role {current_user.role}")
            return jsonify({"error": "Доступ запрещён. Требуется роль администратора."}), 403
        return f(*args, **kwargs)
    wrapper.__name__ = f.__name__
    return wrapper

@bp.route('/admin/users', methods=['GET'])
@admin_required
def get_users():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)

    query = User.query
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (User.username.ilike(search_pattern)) |
            (User.last_name.ilike(search_pattern)) |
            (User.first_name.ilike(search_pattern)) |
            (User.middle_name.ilike(search_pattern))
        )

    paginated_users = query.paginate(page=page, per_page=per_page, error_out=False)
    users = [{
        'id': user.id,
        'username': user.username,
        'role': user.role,
        'last_name': user.last_name,
        'first_name': user.first_name,
        'middle_name': user.middle_name,
        'full_name': user.full_name,
    } for user in paginated_users.items]

    return jsonify({
        'users': users,
        'pages': paginated_users.pages,
        'total': paginated_users.total
    }), 200

@bp.route('/admin/users/<int:user_id>', methods=['PUT'])
@admin_required
def update_user(user_id):
    user = User.query.get_or_404(user_id)
    data = request.get_json()

    user.username = data.get('username', user.username)
    user.role = data.get('role', user.role)
    user.last_name = data.get('last_name', user.last_name)
    user.first_name = data.get('first_name', user.first_name)
    user.middle_name = data.get('middle_name', user.middle_name)

    if 'new_password' in data and data['new_password']:
        user.set_password(data['new_password'])

    try:
        db.session.commit()
        return jsonify({
            'message': 'Пользователь успешно обновлён',
            'user': {
                'id': user.id,
                'username': user.username,
                'role': user.role,
                'last_name': user.last_name,
                'first_name': user.first_name,
                'middle_name': user.middle_name
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при обновлении пользователя {user_id}: {str(e)}")
        return jsonify({"error": "Ошибка при обновлении пользователя. Попробуйте позже."}), 500

@bp.route('/admin/users/<int:user_id>', methods=['DELETE'])
@admin_required
def delete_user(user_id):
    user = User.query.get_or_404(user_id)

    if user.id == current_user.id:
        return jsonify({"error": "Нельзя удалить самого себя."}), 400

    try:
        db.session.delete(user)
        db.session.commit()
        return jsonify({"message": "Пользователь успешно удалён."}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при удалении пользователя {user_id}: {str(e)}")
        return jsonify({"error": "Ошибка при удалении пользователя. Попробуйте позже."}), 500

@bp.route('/admin/publications', methods=['GET'])
@admin_or_manager_required
def get_publications():
    # Получаем параметры запроса
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)
    pub_type = request.args.get('type', 'all', type=str)
    status = request.args.get('status', 'all', type=str)
    sort_status = request.args.get('sort_status', None, type=str)
    sort_by = request.args.get('sort_by', 'updated_at', type=str)  # По умолчанию updated_at
    sort_order = request.args.get('sort_order', 'desc', type=str)  # По умолчанию desc

    # Логируем параметры для отладки
    logger.debug(f"Параметры запроса: page={page}, per_page={per_page}, search={search}, type={pub_type}, status={status}, sort_status={sort_status}, sort_by={sort_by}, sort_order={sort_order}")

    # Базовый запрос
    query = Publication.query

    # Применяем фильтр поиска
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (Publication.title.ilike(search_pattern)) |
            (Publication.authors.ilike(search_pattern)) |
            (db.cast(Publication.year, db.String).ilike(search_pattern))
        )

    # Фильтры по типу и статусу
    if pub_type != 'all':
        query = query.filter_by(type=pub_type)
    
    valid_statuses = ['draft', 'needs_review', 'returned_for_revision', 'published']
    if status != 'all':
        status_list = status.split(',')
        filtered_statuses = [s for s in status_list if s in valid_statuses]
        if not filtered_statuses:
            return jsonify({"error": "Указаны недопустимые статусы"}), 400
        query = query.filter(Publication.status.in_(filtered_statuses))
    else:
        filtered_statuses = valid_statuses

    # Ограничение для менеджеров
    if current_user.role == 'manager':
        allowed_statuses = ['needs_review', 'returned_for_revision', 'published']
        query = query.filter(Publication.status.in_(allowed_statuses))
        filtered_statuses = allowed_statuses

    # Определяем поле для сортировки
    valid_sort_fields = ['id', 'title', 'year', 'updated_at', 'published_at']
    if sort_by not in valid_sort_fields:
        sort_by = 'updated_at'  # По умолчанию
    sort_column = getattr(Publication, sort_by)

    # Определяем направление сортировки
    if sort_order == 'desc':
        sort_column = sort_column.desc()
    else:
        sort_column = sort_column.asc()

    # Применяем сортировку
    if sort_status and sort_status in filtered_statuses:
        sort_case = db.case(
            {sort_status: 0},
            value=Publication.status,
            else_=1
        ).label('status_priority')
        query = query.order_by(sort_case, sort_column)
    else:
        query = query.order_by(sort_column)

    # Пагинация
    try:
        paginated_publications = query.paginate(page=page, per_page=per_page, error_out=False)
    except Exception as e:
        logger.error(f"Ошибка пагинации: {str(e)}")
        return jsonify({"error": "Ошибка сервера при загрузке публикаций"}), 500

    # Формируем ответ
    publications = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'user': {
            'id': pub.user.id if pub.user else None,
            'full_name': pub.user.full_name if pub.user else None
        },
        'returned_for_revision': pub.returned_for_revision,
        'published_at': pub.published_at.isoformat() if pub.published_at else None,
        'updated_at': pub.updated_at.isoformat() if pub.updated_at else None  # Добавляем updated_at в ответ
    } for pub in paginated_publications.items]

    return jsonify({
        'publications': publications,
        'pages': paginated_publications.pages,
        'total': paginated_publications.total
    }), 200
@bp.route('/admin/publications/<int:pub_id>', methods=['PUT'])
@admin_or_manager_required
def update_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)

    # Обрабатываем загрузку файла, если есть
    if 'file' in request.files:
        file = request.files['file']
        if file and allowed_file(file.filename):
            if publication.file_url:
                old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                if os.path.exists(old_file_path):
                    os.remove(old_file_path)
            filename = secure_filename(file.filename)
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
            if os.path.exists(file_path):
                base, extension = os.path.splitext(filename)
                counter = 1
                while os.path.exists(file_path):
                    filename = f"{base}_{counter}{extension}"
                    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                    counter += 1
            try:
                file.save(file_path)
                publication.file_url = f"/uploads/{filename}"
            except Exception as e:
                logger.error(f"Ошибка при сохранении файла: {str(e)}")
                return jsonify({"error": "Ошибка при сохранении файла. Попробуйте снова."}), 500

    # Получаем данные
    data = request.form if 'file' in request.files else request.get_json()
    publication.title = data.get('title', publication.title)
    publication.authors = data.get('authors', publication.authors)
    publication.year = int(data.get('year', publication.year))
    publication.type = data.get('type', publication.type)
    new_status = data.get('status', publication.status)
    comment = data.get('return_comment', '')

    # Записываем действие в историю при смене статуса
    if new_status != publication.status:
        if new_status == 'published':
            publication.published_at = datetime.utcnow()
            publication.returned_for_revision = False
            publication.returned_at = None
            publication.return_comment = None
            action = PublicationActionHistory(
                publication_id=pub_id,
                action_type='approved',
                timestamp=publication.published_at,
                user_id=current_user.id
            )
            db.session.add(action)
        elif new_status == 'returned_for_revision':
            publication.returned_for_revision = True
            publication.returned_at = datetime.utcnow()
            publication.return_comment = comment
            action = PublicationActionHistory(
                publication_id=pub_id,
                action_type='returned',
                timestamp=publication.returned_at,
                comment=comment,
                user_id=current_user.id
            )
            db.session.add(action)
        elif new_status not in ['published', 'returned_for_revision'] and publication.status in ['published', 'returned_for_revision']:
            publication.published_at = None
            publication.returned_at = None
            publication.return_comment = None
            publication.returned_for_revision = False

    publication.status = new_status

    try:
        db.session.commit()
        return jsonify({
            'message': 'Публикация успешно обновлена',
            'publication': publication.to_dict()
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при обновлении публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при обновлении публикации. Попробуйте позже."}), 500
@bp.route('/admin/publications/<int:pub_id>', methods=['DELETE'])
@admin_or_manager_required
def delete_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    try:
        if publication.file_url:
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
            if os.path.exists(file_path):
                os.remove(file_path)

        db.session.delete(publication)
        db.session.commit()
        return jsonify({"message": "Публикация успешно удалена."}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при удалении публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при удалении публикации. Попробуйте позже."}), 500

@bp.route('/admin/publications/needs-review', methods=['GET'])
@admin_or_manager_required
def get_needs_review_publications():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)

    query = Publication.query.filter_by(status='needs_review')
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (Publication.title.ilike(search_pattern)) |
            (Publication.authors.ilike(search_pattern)) |
            (Publication.year.ilike(search_pattern))
        )

    paginated_publications = query.paginate(page=page, per_page=per_page, error_out=False)

    publications = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'user': {
            'id': pub.user.id if pub.user else None,
            'full_name': pub.user.full_name if pub.user else None
        },
        'returned_for_revision': pub.returned_for_revision,
        'published_at': pub.published_at.isoformat() if pub.published_at else None
    } for pub in paginated_publications.items]

    return jsonify({
        'publications': publications,
        'pages': paginated_publications.pages,
        'total': paginated_publications.total
    }), 200 

@bp.route('/admin/register', methods=['POST'])
@admin_or_manager_required
def register():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    last_name = data.get('last_name')
    first_name = data.get('first_name')
    middle_name = data.get('middle_name')

    if not username or not password:
        return jsonify({"error": "Логин и пароль обязательны."}), 400

    existing_user = User.query.filter_by(username=username).first()
    if existing_user:
        return jsonify({"error": "Пользователь с таким логином уже существует."}), 400

    new_user = User(
        username=username,
        last_name=last_name,
        first_name=first_name,
        middle_name=middle_name,
    )
    new_user.set_password(password)

    try:
        db.session.add(new_user)
        db.session.commit()
        logger.debug(f"User registered successfully: {username}, response: {'Пользователь успешно зарегистрирован.'}")
        return jsonify({"message": "Пользователь успешно зарегистрирован."}), 201
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при регистрации пользователя {username}: {str(e)}")
        return jsonify({"error": "Ошибка при регистрации. Попробуйте позже."}), 500

@bp.route('/admin/check-username', methods=['POST'])
@admin_or_manager_required
def check_username():
    data = request.get_json()
    username = data.get('username')
    user = User.query.filter_by(username=username).first()
    return jsonify({'exists': user is not None})

@bp.route('/admin/generate-password', methods=['GET'])
@admin_or_manager_required
def generate_password():
    import secrets
    import string
    # Используем только буквы (строчные и заглавные) и цифры
    characters = string.ascii_letters + string.digits
    password = ''.join(secrets.choice(characters) for _ in range(12))
    return jsonify({'password': password})

@bp.route('/admin/plans', methods=['GET'])
@admin_or_manager_required
def get_all_plans():
    logger.debug(f"Получен GET запрос для /admin_api/admin/plans")
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    pagination = Plan.query.order_by(Plan.year.desc()).paginate(page=page, per_page=per_page)
    plans = pagination.items
    return jsonify({
        'plans': [plan.to_dict() for plan in plans],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/admin/plans/<int:plan_id>', methods=['PUT'])
@admin_required
def update_plan(plan_id):
    logger.debug(f"Получен PUT запрос для /admin_api/admin/plans/{plan_id}")
    plan = Plan.query.get_or_404(plan_id)
    data = request.get_json()
    if not all(k in data for k in ('year', 'expectedCount', 'fillType', 'user_id', 'entries')):
        return jsonify({'error': 'Missing required fields'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Invalid year'}), 400
    
    if not isinstance(data['expectedCount'], int) or data['expectedCount'] < 1:
        return jsonify({'error': 'Expected count must be at least 1'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Invalid fill type'}), 400

    plan.year = data['year']
    plan.expectedCount = data['expectedCount']
    plan.fillType = data['fillType']
    plan.user_id = data['user_id']

    PlanEntry.query.filter_by(plan_id=plan.id).delete()
    for entry_data in data['entries']:
        entry = PlanEntry(
            title=entry_data.get('title'),
            type=entry_data.get('type'),
            publication_id=entry_data.get('publication_id'),
            status=entry_data.get('status', 'planned'),
            plan=plan
        )
        if entry.publication_id:
            publication = Publication.query.filter_by(id=entry.publication_id, user_id=plan.user_id, status='published').first()
            if not publication:
                db.session.rollback()
                return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
        db.session.add(entry)

    db.session.commit()
    return jsonify({'message': 'Plan updated successfully', 'plan': plan.to_dict()}), 200

@bp.route('/admin/plans/<int:plan_id>', methods=['DELETE'])
@admin_required
def delete_plan(plan_id):
    logger.debug(f"Получен DELETE запрос для /admin_api/admin/plans/{plan_id}")
    plan = Plan.query.get_or_404(plan_id)
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'Cannot delete plan that is under review or approved'}), 403
    
    db.session.delete(plan)
    db.session.commit()
    return jsonify({'message': 'Plan deleted successfully'}), 200

@bp.route('/admin/plans/<int:plan_id>/approve', methods=['POST'])
@admin_or_manager_required
def approve_plan(plan_id):
    plan = Plan.query.get_or_404(plan_id)
    plan.status = 'approved'
    plan.approved_at = datetime.utcnow()
    # Не сбрасываем returned_at и return_comment

    # Добавляем запись в историю
    action = PlanActionHistory(
        plan_id=plan.id,
        action_type='approved',
        timestamp=plan.approved_at,
        user_id=current_user.id  # Кто утвердил
    )
    db.session.add(action)
    db.session.commit()
    return jsonify({"message": "План утверждён"}), 200
@bp.route('/admin/plans/<int:plan_id>/return-for-revision', methods=['POST'])
@admin_or_manager_required
def return_plan_for_revision(plan_id):
    plan = Plan.query.get_or_404(plan_id)
    data = request.get_json()
    comment = data.get('comment', '')
    plan.status = 'returned'
    plan.return_comment = comment
    plan.returned_at = datetime.utcnow()
    # Не сбрасываем approved_at

    # Добавляем запись в историю
    action = PlanActionHistory(
        plan_id=plan.id,
        action_type='returned',
        timestamp=plan.returned_at,
        comment=comment,
        user_id=current_user.id  # Кто вернул
    )
    db.session.add(action)
    db.session.commit()
    return jsonify({"message": "План возвращён на доработку"}), 200
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in {'pdf', 'docx'}

def get_publications_by_year(user_id):
    publications = Publication.query.filter_by(user_id=user_id).all()
    yearly_counts = {}
    for pub in publications:
        year = pub.year
        yearly_counts[year] = yearly_counts.get(year, 0) + 1
    return sorted(yearly_counts.items(), key=lambda x: x[0])


@bp.route('/admin/plan-action-history', methods=['GET'])
@admin_or_manager_required
def get_plan_action_history():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    start_date = request.args.get('start_date', type=str)
    end_date = request.args.get('end_date', type=str)

    # Базовый запрос к истории действий
    query = PlanActionHistory.query.join(Plan).filter(
        PlanActionHistory.action_type.in_(['approved', 'returned'])
    )

    # Фильтрация по датам
    if start_date:
        try:
            start_datetime = datetime.strptime(start_date, '%Y-%m-%d')
            query = query.filter(PlanActionHistory.timestamp >= start_datetime)
        except ValueError as e:
            logger.error(f"Некорректный формат start_date: {start_date}, ошибка: {str(e)}")
            return jsonify({"error": "Некорректный формат даты начала"}), 400

    if end_date:
        try:
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            query = query.filter(PlanActionHistory.timestamp <= end_datetime)
        except ValueError as e:
            logger.error(f"Некорректный формат end_date: {end_date}, ошибка: {str(e)}")
            return jsonify({"error": "Некорректный формат даты окончания"}), 400

    # Сортировка по убыванию (новые действия первыми)
    query = query.order_by(desc(PlanActionHistory.timestamp))

    # Пагинация
    paginated_actions = query.paginate(page=page, per_page=per_page, error_out=False)
    
    logger.debug(f"Найдено действий: {paginated_actions.total}")
    for action in paginated_actions.items:
        logger.debug(f"Действие ID={action.id}, план ID={action.plan_id}, тип={action.action_type}, время={action.timestamp}")

    # Формируем историю
    history = []
    for action in paginated_actions.items:
        history.append({
            'id': action.plan_id,  # ID плана
            'year': action.plan.year,
            'action_type': action.action_type,
            'timestamp': action.timestamp.isoformat(),
            'comment': action.comment,
            'user_full_name': action.plan.user.full_name if action.plan.user else "Не указан"
        })

    return jsonify({
        'history': history,
        'pages': paginated_actions.pages,
        'total': paginated_actions.total
    }), 200


@bp.route('admin/plans/needs-review', methods=['GET'])
@login_required
def get_needs_review_plans():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    
    # Запрос планов со статусом 'needs_review'
    plans_query = Plan.query.filter_by(status='needs_review')
    pagination = plans_query.paginate(page=page, per_page=per_page, error_out=False)
    
    plans = [plan.to_dict() for plan in pagination.items]
    
    return jsonify({
        'plans': plans,
        'pages': pagination.pages,
        'total': pagination.total
    })


from sqlalchemy import case, or_, desc, func

@bp.route('/admin/publication-action-history', methods=['GET'])
@admin_or_manager_required
def get_publication_action_history():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    start_date = request.args.get('start_date', type=str)
    end_date = request.args.get('end_date', type=str)

    query = PublicationActionHistory.query.join(Publication).filter(
        PublicationActionHistory.action_type.in_(['approved', 'returned'])
    )

    if start_date:
        try:
            start_datetime = datetime.strptime(start_date, '%Y-%m-%d')
            query = query.filter(PublicationActionHistory.timestamp >= start_datetime)
        except ValueError:
            return jsonify({"error": "Некорректный формат даты начала"}), 400

    if end_date:
        try:
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            query = query.filter(PublicationActionHistory.timestamp <= end_datetime)
        except ValueError:
            return jsonify({"error": "Некорректный формат даты окончания"}), 400

    query = query.order_by(db.desc(PublicationActionHistory.timestamp))
    paginated_actions = query.paginate(page=page, per_page=per_page, error_out=False)

    history = [{
        'id': action.publication_id,
        'title': action.publication.title,
        'action_type': action.action_type,
        'timestamp': action.timestamp.isoformat(),
        'comment': action.comment,
        'user_full_name': action.user.full_name if action.user else "Не указан"
    } for action in paginated_actions.items]

    return jsonify({
        'history': history,
        'pages': paginated_actions.pages,
        'total': paginated_actions.total
    }), 200

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
	Container,
	Typography,
	Card as AppleCard,
	Tabs,
	Tab,
	Box,
	CircularProgress,
	Table,
	TableBody,
	TableCell,
	TableHead,
	TableRow,
	IconButton,
	Dialog,
	DialogTitle,
	DialogContent,
	DialogActions,
	TextField,
	Collapse,
	Alert,
	Pagination,
	Fade,
	MenuItem,
	Button,
	Drawer,
	Accordion,
	AccordionSummary,
	AccordionDetails,
} from '@mui/material';
import { styled } from '@mui/system';
import DeleteIcon from '@mui/icons-material/Delete';
import DownloadIcon from '@mui/icons-material/Download';
import CheckIcon from '@mui/icons-material/Check';
import ReplayIcon from '@mui/icons-material/Replay';
import RefreshIcon from '@mui/icons-material/Refresh';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import Visibility from '@mui/icons-material/Visibility';
import VisibilityOff from '@mui/icons-material/VisibilityOff';
import HistoryIcon from '@mui/icons-material/History';
import WarningAmberIcon from '@mui/icons-material/WarningAmber';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import axios from 'axios';
import { useAuth } from '../contexts/AuthContext';
import StatusChip from './StatusChip';

// Стили
const AppleTextField = styled(TextField)({
	'& .MuiOutlinedInput-root': {
		borderRadius: '12px',
		backgroundColor: '#F5F5F7',
		'& fieldset': { borderColor: '#D1D1D6' },
		'&:hover fieldset': { borderColor: '#0071E3' },
		'&.Mui-focused fieldset': { borderColor: '#0071E3' },
	},
	'& .MuiInputLabel-root': { color: '#6E6E73' },
	'& .MuiInputLabel-root.Mui-focused': { color: '#0071E3' },
});

const AppleTable = styled(Table)({
	borderCollapse: 'separate',
	borderSpacing: '0 8px',
});

const PlanTable = styled(Table)({
	borderRadius: '16px',
	overflow: 'hidden',
	backgroundColor: '#FFFFFF',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	marginBottom: '16px',
});

const AppleButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#0071E3',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#0066CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const GreenButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: 'green',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#2EBB4A', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const CancelButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#D1D1D6',
	color: '#1D1D1F',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#C7C7CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

// Регулярные выражения для проверки ФИО
const namePartRegex = /^[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?$/;
const fullNameRegex = /^[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?\s[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?\s[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?$/;

function ManagerDashboard() {
	const { user, csrfToken, isAuthenticated } = useAuth();
	const navigate = useNavigate();
	const [value, setValue] = useState(0);
	const [publications, setPublications] = useState([]);
	const [plans, setPlans] = useState([]);
	const [currentPagePublications, setCurrentPagePublications] = useState(1);
	const [currentPagePlans, setCurrentPagePlans] = useState(1);
	const [dateFilterRange, setDateFilterRange] = useState({ start: '', end: '' });
	const [totalPagesPublications, setTotalPagesPublications] = useState(1);
	const [totalPagesPlans, setTotalPagesPlans] = useState(1);
	const [searchQuery, setSearchQuery] = useState('');
	const [statusFilter, setStatusFilter] = useState('needs_review');
	const [loadingInitial, setLoadingInitial] = useState(true);
	const [openEditDialog, setOpenEditDialog] = useState(false);
	const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
	const [publicationToDelete, setPublicationToDelete] = useState(null);
	const [editPublication, setEditPublication] = useState(null);
	const [editTitle, setEditTitle] = useState('');
	const [editAuthors, setEditAuthors] = useState('');
	const [editYear, setEditYear] = useState('');
	const [editType, setEditType] = useState('article');
	const [editStatus, setEditStatus] = useState('needs_review');
	const [editFile, setEditFile] = useState(null);
	const [error, setError] = useState('');
	const [success, setSuccess] = useState('');
	const [openError, setOpenError] = useState(false);
	const [openSuccess, setOpenSuccess] = useState(false);
	const [newLastName, setNewLastName] = useState('');
	const [newFirstName, setNewFirstName] = useState('');
	const [newMiddleName, setNewMiddleName] = useState('');
	const [newUsername, setNewUsername] = useState('');
	const [newPassword, setNewPassword] = useState('');
	const [showPassword, setShowPassword] = useState(false);
	const [openReturnDialog, setOpenReturnDialog] = useState(false);
	const [selectedPlan, setSelectedPlan] = useState(null);
	const [returnComment, setReturnComment] = useState('');
	const [lastNameError, setLastNameError] = useState('');
	const [firstNameError, setFirstNameError] = useState('');
	const [middleNameError, setMiddleNameError] = useState('');
	const [openHistoryDrawer, setOpenHistoryDrawer] = useState(false);
	const [publicationsTransitionKey, setPublicationsTransitionKey] = useState(0);
	const [plansTransitionKey, setPlansTransitionKey] = useState(0);
	const [planActionHistory, setPlanActionHistory] = useState([]);
	const [planHistoryPage, setPlanHistoryPage] = useState(1);
	const [totalPlanHistoryPages, setTotalPlanHistoryPages] = useState(1);
	const [openPlanHistoryDrawer, setOpenPlanHistoryDrawer] = useState(false);
	const [planHistoryTransitionKey, setPlanHistoryTransitionKey] = useState(0);
	const [pubActionHistory, setPubActionHistory] = useState([]);
	const [pubHistoryPage, setPubHistoryPage] = useState(1);
	const [totalPubHistoryPages, setTotalPubHistoryPages] = useState(1);
	const [pubHistoryTransitionKey, setPubHistoryTransitionKey] = useState(0);
	const [selectedPublication, setSelectedPublication] = useState(null);

	// Эффект для автоматического закрытия уведомлений
	useEffect(() => {
		let errorTimer, successTimer;
		if (openError) errorTimer = setTimeout(() => setOpenError(false), 3000);
		if (openSuccess) successTimer = setTimeout(() => setOpenSuccess(false), 3000);
		return () => {
			if (errorTimer) clearTimeout(errorTimer);
			if (successTimer) clearTimeout(successTimer);
		};
	}, [openError, openSuccess]);

	// Валидация ФИО
	const validateNamePart = (value, fieldName) => {
		if (!value.trim()) return `${fieldName} обязательно для заполнения.`;
		if (!namePartRegex.test(value))
			return `${fieldName} должно начинаться с заглавной буквы, содержать только кириллицу и быть длиной не менее 2 символов.`;
		return '';
	};

	const validateFullName = (lastName, firstName, middleName) => {
		const fullName = `${lastName} ${firstName} ${middleName}`;
		if (!fullNameRegex.test(fullName))
			return 'ФИО должно быть в формате "Иванов Иван Иванович" (три слова с заглавной буквы, разделённые пробелами).';
		return '';
	};

	// Обработчики изменения полей ФИО
	const handleLastNameChange = (e) => {
		const value = e.target.value;
		setNewLastName(value);
		setLastNameError(validateNamePart(value, 'Фамилия'));
	};

	const handleFirstNameChange = (e) => {
		const value = e.target.value;
		setNewFirstName(value);
		setFirstNameError(validateNamePart(value, 'Имя'));
	};

	const handleMiddleNameChange = (e) => {
		const value = e.target.value;
		setNewMiddleName(value);
		setMiddleNameError(validateNamePart(value, 'Отчество'));
	};

	const fetchPlanActionHistory = async (page, startDate = '', endDate = '') => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/plan-action-history`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: {
					page,
					per_page: 10,
					start_date: startDate || undefined,
					end_date: endDate || undefined,
				},
			});
			setPlanActionHistory(response.data.history);
			setTotalPlanHistoryPages(response.data.pages);
			setPlanHistoryTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки истории действий с планами:', err);
			setError('Не удалось загрузить историю действий с планами.');
			setOpenError(true);
		}
	};

	const fetchPublications = async (page) => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/publications`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: {
					page,
					per_page: 10,
					search: searchQuery,
					status: ['needs_review', 'returned_for_revision', 'published'].join(','),
					sort_status: statusFilter,
				},
			});
			setPublications(response.data.publications);
			setTotalPagesPublications(response.data.pages);
			setPublicationsTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки публикаций:', err);
			setError('Не удалось загрузить публикации. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const fetchPlans = async (page) => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/plans/needs-review?page=${page}&per_page=10`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setPlans(response.data.plans);
			setTotalPagesPlans(response.data.pages);
			setPlansTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки планов:', err);
			setError('Не удалось загрузить планы. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const fetchPubActionHistory = async (page, startDate = '', endDate = '') => {
		try {
			const response = await axios.get('http://localhost:5000/admin_api/admin/publication-action-history', {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: {
					page,
					per_page: 10,
					start_date: startDate || undefined,
					end_date: endDate || undefined,
				},
			});
			setPubActionHistory(response.data.history);
			setTotalPubHistoryPages(response.data.pages);
			setPubHistoryTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки истории действий с публикациями:', err);
			setError('Не удалось загрузить историю действий с публикациями.');
			setOpenError(true);
		}
	};

	// Инициализация данных
	useEffect(() => {
		if (!isAuthenticated || user.role !== 'manager') navigate('/login');
		setLoadingInitial(true);
		Promise.all([
			fetchPublications(currentPagePublications),
			fetchPlans(currentPagePlans),
			fetchPubActionHistory(pubHistoryPage, dateFilterRange.start, dateFilterRange.end),
			fetchPlanActionHistory(planHistoryPage, dateFilterRange.start, dateFilterRange.end),
		]).finally(() => setLoadingInitial(false));
	}, [isAuthenticated, user, navigate]);

	// Обновление истории публикаций
	useEffect(() => {
		fetchPubActionHistory(pubHistoryPage, dateFilterRange.start, dateFilterRange.end);
	}, [pubHistoryPage, dateFilterRange.start, dateFilterRange.end]);

	// Обновление публикаций
	useEffect(() => {
		fetchPublications(currentPagePublications);
	}, [currentPagePublications, searchQuery, statusFilter]);

	// Обновление планов
	useEffect(() => {
		fetchPlans(currentPagePlans);
	}, [currentPagePlans]);

	// Обработчики
	const handleTabChange = (event, newValue) => setValue(newValue);

	const handleSearchChange = (e) => {
		setSearchQuery(e.target.value);
		setCurrentPagePublications(1);
	};

	const handleOpenPlanHistoryDrawer = () => {
		setOpenPlanHistoryDrawer(true);
		fetchPlanActionHistory(planHistoryPage);
	};

	const handleClosePlanHistoryDrawer = () => setOpenPlanHistoryDrawer(false);

	const handlePlanHistoryPageChange = (event, value) => {
		setPlanHistoryPage(value);
		fetchPlanActionHistory(value, dateFilterRange.start, dateFilterRange.end);
	};

	const handleStatusFilterChange = (e) => {
		setStatusFilter(e.target.value);
		setCurrentPagePublications(1);
	};

	const handlePageChangePublications = (event, value) => setCurrentPagePublications(value);

	const handlePageChangePlans = (event, value) => setCurrentPagePlans(value);

	const handleHistoryPageChange = (event, value) => {
		setPubHistoryPage(value);
		fetchPubActionHistory(value, dateFilterRange.start, dateFilterRange.end);
	};

	const handleDownload = async (fileUrl, fileName) => {
		if (!fileUrl || typeof fileUrl !== 'string' || fileUrl.trim() === '') {
			setError('Некорректный URL файла. Обратитесь к администратору.');
			setOpenError(true);
			return;
		}
		const normalizedFileUrl = fileUrl.startsWith('/') ? fileUrl : `/${fileUrl}`;
		const fullUrl = `http://localhost:5000${normalizedFileUrl}`;
		try {
			const response = await axios.get(fullUrl, {
				responseType: 'blob',
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			const blob = new Blob([response.data]);
			const url = window.URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.href = url;
			link.download = fileName || normalizedFileUrl.split('/').pop();
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			window.URL.revokeObjectURL(url);
		} catch (err) {
			setError(err.response ? `Ошибка сервера: ${err.response.status}` : 'Не удалось скачать файл.');
			setOpenError(true);
		}
	};

	const handleEditClick = (publication) => {
		setEditPublication(publication);
		setEditTitle(publication.title);
		setEditAuthors(publication.authors);
		setEditYear(publication.year);
		setEditType(publication.type);
		setEditStatus(publication.status);
		setEditFile(null);
		setOpenEditDialog(true);
	};

	const handleEditCancel = () => {
		setOpenEditDialog(false);
		setEditPublication(null);
		setEditTitle('');
		setEditAuthors('');
		setEditYear('');
		setEditType('article');
		setEditStatus('needs_review');
		setEditFile(null);
		setError('');
		setSuccess('');
	};

	const handleEditSubmit = async (event) => {
		event.preventDefault();
		if (!editTitle.trim() || !editAuthors.trim() || !editYear || editYear < 1900 || editYear > new Date().getFullYear()) {
			setError('Проверьте поля: название, авторы и год должны быть заполнены корректно.');
			setOpenError(true);
			return;
		}
		const formData = new FormData();
		formData.append('title', editTitle);
		formData.append('authors', editAuthors);
		formData.append('year', editYear);
		formData.append('type', editType);
		formData.append('status', editStatus);
		if (editFile) formData.append('file', editFile);

		try {
			await axios.put(`http://localhost:5000/admin_api/admin/publications/${editPublication.id}`, formData, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken, 'Content-Type': 'multipart/form-data' },
			});
			setSuccess('Публикация успешно обновлена!');
			setOpenSuccess(true);
			fetchPublications(currentPagePublications);
			fetchPubActionHistory(pubHistoryPage);
			handleEditCancel();
		} catch (err) {
			setError('Не удалось обновить публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleDeletePlanClick = (publication) => {
		setPublicationToDelete(publication);
		setOpenDeleteDialog(true);
	};

	const handleDeletePlanConfirm = async () => {
		if (publicationToDelete) {
			try {
				await axios.delete(`http://localhost:5000/admin_api/admin/publications/${publicationToDelete.id}`, {
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				});
				setSuccess('Публикация успешно удалена!');
				setOpenSuccess(true);
				fetchPublications(currentPagePublications);
				fetchPubActionHistory(pubHistoryPage);
				setOpenDeleteDialog(false);
				setPublicationToDelete(null);
			} catch (err) {
				setError('Не удалось удалить публикацию. Попробуйте позже.');
				setOpenError(true);
			}
		}
	};

	const handleApprovePlan = async (plan) => {
		try {
			await axios.post(`http://localhost:5000/admin_api/admin/plans/${plan.id}/approve`, {}, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setSuccess('План утверждён!');
			setOpenSuccess(true);
			fetchPlans(currentPagePlans);
			fetchPlanActionHistory(planHistoryPage);
		} catch (err) {
			setError('Не удалось утвердить план. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleOpenReturnDialog = (plan) => {
		setSelectedPlan(plan);
		setReturnComment('');
		setOpenReturnDialog(true);
	};

	const handleReturnForRevision = async () => {
		if (!returnComment.trim()) {
			setError('Комментарий обязателен.');
			setOpenError(true);
			return;
		}
		try {
			await axios.post(
				`http://localhost:5000/admin_api/admin/plans/${selectedPlan.id}/return-for-revision`,
				{ comment: returnComment },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('План возвращён на доработку!');
			setOpenSuccess(true);
			fetchPlans(currentPagePlans);
			fetchPlanActionHistory(planHistoryPage);
			setOpenReturnDialog(false);
		} catch (err) {
			setError('Не удалось вернуть план. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleApprovePublication = async (pub) => {
		try {
			await axios.put(
				`http://localhost:5000/admin_api/admin/publications/${pub.id}`,
				{ status: 'published' },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('Публикация утверждена!');
			setOpenSuccess(true);
			fetchPublications(currentPagePublications);
			fetchPubActionHistory(pubHistoryPage);
		} catch (err) {
			setError('Не удалось утвердить публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleReturnPublicationForRevision = async (pubId, comment) => {
		try {
			await axios.put(
				`http://localhost:5000/admin_api/admin/publications/${pubId}`,
				{ status: 'returned_for_revision', return_comment: comment },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('Публикация возвращена на доработку!');
			setOpenSuccess(true);
			fetchPublications(currentPagePublications);
			fetchPubActionHistory(pubHistoryPage);
			setOpenReturnDialog(false);
		} catch (err) {
			setError('Не удалось вернуть публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleOpenHistoryDrawer = () => {
		setOpenHistoryDrawer(true);
		fetchPubActionHistory(pubHistoryPage);
	};

	const handleCloseHistoryDrawer = () => setOpenHistoryDrawer(false);

	return (
		<Container maxWidth="lg" sx={{ mt: 8, mb: 4 }}>
			<AppleCard elevation={4} sx={{ p: 4, borderRadius: '16px', backgroundColor: '#FFFFFF' }}>
				<Typography variant="h4" sx={{ color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
					Панель управляющего
				</Typography>
				<Tabs
					value={value}
					onChange={handleTabChange}
					centered
					sx={{
						mb: 4,
						'& .MuiTab-root': { color: '#6E6E73', fontWeight: 600 },
						'& .MuiTab-root.Mui-selected': { color: '#0071E3' },
						'& .MuiTabs-indicator': { backgroundColor: '#0071E3' },
					}}
				>
					<Tab label="Работы на проверке" />
					<Tab label="Статистика по кафедре" />
					<Tab label="Регистрация пользователей" />
					<Tab label="Работа с планами" />
				</Tabs>

				{loadingInitial ? (
					<Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
						<CircularProgress sx={{ color: '#0071E3' }} />
					</Box>
				) : (
					<>
						{value === 0 && (
							<>
								<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
									Работы на проверке
								</Typography>
								<AppleCard sx={{ mt: 2, mb: 2, p: 2, backgroundColor: '#F5F5F7', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<AppleTextField
										fullWidth
										label="Поиск по названию, авторам или году"
										value={searchQuery}
										onChange={handleSearchChange}
										margin="normal"
										variant="outlined"
									/>
									<Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 2 }}>
										<AppleTextField
											select
											label="Фильтр по статусу"
											value={statusFilter}
											onChange={handleStatusFilterChange}
											margin="normal"
											variant="outlined"
											sx={{ width: '200px' }}
										>
											<MenuItem value="needs_review">На проверке</MenuItem>
											<MenuItem value="returned_for_revision">Отправлено на доработку</MenuItem>
											<MenuItem value="published">Опубликовано</MenuItem>
										</AppleTextField>
										<AppleButton startIcon={<HistoryIcon />} onClick={handleOpenHistoryDrawer} sx={{ height: 'fit-content', marginTop: '6px' }}>
											Показать историю
										</AppleButton>
									</Box>
								</AppleCard>
								<AppleTable sx={{ mt: 2, boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<TableHead>
										<TableRow sx={{ backgroundColor: '#0071E3' }}>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', borderRadius: '12px 0 0 0' }}>ID</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Название</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Авторы</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Год</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Тип</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Статус</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Пользователь</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', textAlign: 'center', borderRadius: '0 12px 0 0' }}>
												Действия
											</TableCell>
										</TableRow>
									</TableHead>
									<Fade in={true} timeout={500} key={publicationsTransitionKey}>
										<TableBody>
											{publications.length > 0 ? (
												publications.map((pub) => (
													<TableRow
														key={pub.id}
														sx={{ '&:hover': { backgroundColor: '#F5F5F7', transition: 'background-color 0.3s ease' } }}
													>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.id}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															<Typography
																sx={{
																	color: '#0071E3',
																	textDecoration: 'underline',
																	cursor: 'pointer',
																	'&:hover': { textDecoration: 'none' },
																}}
																onClick={() => navigate(`/publication/${pub.id}`)}
															>
																{pub.title}
															</Typography>
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.authors}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.year}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															{pub.type === 'article'
																? 'Статья'
																: pub.type === 'monograph'
																	? 'Монография'
																	: pub.type === 'conference'
																		? 'Доклад/конференция'
																		: 'Неизвестный тип'}
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															<StatusChip status={pub.status} role={user.role} />
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.user?.full_name || 'Не указан'}</TableCell>
														<TableCell sx={{ textAlign: 'center' }}>
															<Box sx={{ display: 'flex', justifyContent: 'center', gap: 1 }}>
																{pub.file_url && pub.file_url.trim() !== '' && (
																	<IconButton
																		aria-label="download"
																		onClick={() => handleDownload(pub.file_url, pub.file_url.split('/').pop())}
																		sx={{
																			color: '#0071E3',
																			borderRadius: '8px',
																			'&:hover': { color: '#FFFFFF', backgroundColor: '#0071E3', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)' },
																		}}
																	>
																		<DownloadIcon />
																	</IconButton>
																)}
															</Box>
														</TableCell>
													</TableRow>
												))
											) : (
												<TableRow>
													<TableCell colSpan={8} sx={{ textAlign: 'center', color: '#6E6E73' }}>
														Нет публикаций с указанными статусами.
													</TableCell>
												</TableRow>
											)}
										</TableBody>
									</Fade>
								</AppleTable>
								<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
									<Pagination
										count={totalPagesPublications}
										page={currentPagePublications}
										onChange={handlePageChangePublications}
										color="primary"
										sx={{
											'& .MuiPaginationItem-root': {
												borderRadius: 20,
												transition: 'all 0.3s ease',
												'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
												'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
											},
										}}
									/>
								</Box>
								<Drawer
									anchor="right"
									open={openHistoryDrawer}
									onClose={handleCloseHistoryDrawer}
									sx={{
										'& .MuiDrawer-paper': {
											width: 600,
											backgroundColor: '#FFFFFF',
											boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
											borderRadius: '16px 0 0 16px',
										},
									}}
								>
									<Box sx={{ p: 2, pr: 4 }}>
										<Typography variant="h6" sx={{ color: '#1D1D1F', fontWeight: 600, mb: 5 }}>
											История действий с публикациями
										</Typography>
										<Box sx={{ display: 'flex', gap: 2, mt: 2, mb: 2 }}>
											<AppleTextField
												label="Дата начала"
												type="date"
												value={dateFilterRange.start}
												onChange={(e) => {
													setDateFilterRange((prev) => ({ ...prev, start: e.target.value }));
													setPubHistoryPage(1);
												}}
												InputLabelProps={{ shrink: true }}
												sx={{ width: '200px' }}
											/>
											<AppleTextField
												label="Дата окончания"
												type="date"
												value={dateFilterRange.end}
												onChange={(e) => {
													setDateFilterRange((prev) => ({ ...prev, end: e.target.value }));
													setPubHistoryPage(1);
												}}
												InputLabelProps={{ shrink: true }}
												sx={{ width: '200px' }}
											/>
										</Box>
										{pubActionHistory.length > 0 ? (
											<>
												<AppleTable
													sx={{
														mt: 2,
														overflowX: 'auto',
														minWidth: '100%',
														backgroundColor: '#F5F5F7',
														boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
														borderRadius: '8px',
													}}
												>
													<TableHead>
														<TableRow sx={{ backgroundColor: '#0071E3', borderRadius: '8px 8px 0 0' }}>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '200px', borderTopLeftRadius: '8px' }}>
																Название
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '120px' }}>
																Действие
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '140px', borderTopRightRadius: '8px' }}>
																Время
															</TableCell>
														</TableRow>
													</TableHead>
													<Fade in={true} timeout={500} key={pubHistoryTransitionKey}>
														<TableBody>
															{pubActionHistory.map((action) => (
																<TableRow key={`${action.id}-${action.timestamp}`}>
																	<TableCell sx={{ minWidth: '200px', whiteSpace: 'normal', wordWrap: 'break-word' }}>
																		<Typography
																			sx={{
																				color: '#0071E3',
																				textDecoration: 'underline',
																				cursor: 'pointer',
																				'&:hover': { textDecoration: 'none' },
																			}}
																			onClick={() => {
																				handleCloseHistoryDrawer();
																				navigate(`/publication/${action.id}`);
																			}}
																		>
																			{action.title}
																		</Typography>
																	</TableCell>
																	<TableCell sx={{ minWidth: '120px' }}>
																		{action.action_type === 'approved' ? 'Утверждено' : 'Возвращено на доработку'}
																	</TableCell>
																	<TableCell sx={{ minWidth: '140px' }}>
																		{new Date(action.timestamp).toLocaleString('ru-RU')}
																	</TableCell>
																</TableRow>
															))}
														</TableBody>
													</Fade>
												</AppleTable>
												<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
													<Pagination
														count={totalPubHistoryPages}
														page={pubHistoryPage}
														onChange={handleHistoryPageChange}
														color="primary"
														sx={{
															'& .MuiPaginationItem-root': {
																borderRadius: 20,
																'&:hover': { backgroundColor: 'grey.100' },
																'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
															},
														}}
													/>
												</Box>
											</>
										) : (
											<Typography sx={{ mt: 2, color: '#6E6E73' }}>
												Нет записей в истории действий с публикациями.
											</Typography>
										)}
									</Box>
								</Drawer>
							</>
						)}

						{value === 1 && (
							<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
								Статистика по кафедре
							</Typography>
						)}

						{value === 2 && (
							<>
								<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
									Регистрация нового пользователя
								</Typography>
								<AppleCard sx={{ maxWidth: 'none', mx: 'auto', mt: 2, p: 4 }}>
									<form onSubmit={(e) => e.preventDefault()}>
										<AppleTextField
											fullWidth
											label="Фамилия"
											value={newLastName}
											onChange={handleLastNameChange}
											margin="normal"
											variant="outlined"
											autoComplete="family-name"
											error={!!lastNameError}
											helperText={lastNameError}
										/>
										<AppleTextField
											fullWidth
											label="Имя"
											value={newFirstName}
											onChange={handleFirstNameChange}
											margin="normal"
											variant="outlined"
											autoComplete="given-name"
											error={!!firstNameError}
											helperText={firstNameError}
										/>
										<AppleTextField
											fullWidth
											label="Отчество"
											value={newMiddleName}
											onChange={handleMiddleNameChange}
											margin="normal"
											variant="outlined"
											autoComplete="additional-name"
											error={!!middleNameError}
											helperText={middleNameError}
										/>
										<AppleTextField
											fullWidth
											label="Логин"
											value={newUsername}
											onChange={(e) => setNewUsername(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="username"
										/>
										<AppleTextField
											fullWidth
											label="Пароль"
											type={showPassword ? 'text' : 'password'}
											value={newPassword}
											onChange={(e) => setNewPassword(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="new-password"
											InputProps={{
												endAdornment: (
													<IconButton onClick={() => setShowPassword(!showPassword)}>
														{showPassword ? <VisibilityOff /> : <Visibility />}
													</IconButton>
												),
											}}
										/>
										<Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
											<AppleButton
												startIcon={<RefreshIcon />}
												onClick={async () => {
													const lastNameErr = validateNamePart(newLastName, 'Фамилия');
													const firstNameErr = validateNamePart(newFirstName, 'Имя');
													const middleNameErr = validateNamePart(newMiddleName, 'Отчество');
													const fullNameErr = validateFullName(newLastName, newFirstName, newMiddleName);

													if (lastNameErr || firstNameErr || middleNameErr || fullNameErr) {
														setLastNameError(lastNameErr);
														setFirstNameError(firstNameErr);
														setMiddleNameError(middleNameErr);
														if (fullNameErr) {
															setError(fullNameErr);
															setOpenError(true);
														}
														return;
													}

													const generateUsername = async () => {
														const transliterate = (text) => {
															const ruToEn = {
																а: 'a', б: 'b', в: 'v', г: 'g', д: 'd',
																е: 'e', ё: 'e', ж: 'zh', з: 'z', и: 'i',
																й: 'y', к: 'k', л: 'l', м: 'm', н: 'n',
																о: 'o', п: 'p', р: 'r', с: 's', т: 't',
																у: 'u', ф: 'f', х: 'kh', ц: 'ts', ч: 'ch',
																ш: 'sh', щ: 'sch', ъ: '', ы: 'y', ь: '',
																э: 'e', ю: 'yu', я: 'ya'
															};
															return text.toLowerCase().split('').map(char => ruToEn[char] || char).join('');
														};
														const capitalizeFirstLetter = (string) =>
															string ? string.charAt(0).toUpperCase() + string.slice(1) : '';
														const baseUsername = `${capitalizeFirstLetter(transliterate(newLastName))}${capitalizeFirstLetter(transliterate(newFirstName[0]))}${capitalizeFirstLetter(transliterate(newMiddleName[0]))}`;
														let generatedUsername = baseUsername;
														let suffix = 1;

														while (true) {
															try {
																const response = await axios.post(
																	'http://localhost:5000/admin_api/admin/check-username',
																	{ username: generatedUsername },
																	{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
																);
																if (!response.data.exists) break;
																generatedUsername = `${baseUsername}${suffix}`;
																suffix++;
															} catch (err) {
																setError('Ошибка проверки логина.');
																setOpenError(true);
																return null;
															}
														}
														return generatedUsername;
													};

													const generatedUsername = await generateUsername();
													if (!generatedUsername) return;

													try {
														const response = await axios.get('http://localhost:5000/admin_api/admin/generate-password', {
															withCredentials: true,
															headers: { 'X-CSRFToken': csrfToken },
														});
														setNewUsername(generatedUsername);
														setNewPassword(response.data.password);
														setSuccess('Логин и пароль успешно сгенерированы.');
														setOpenSuccess(true);
													} catch (err) {
														setError('Ошибка генерации пароля.');
														setOpenError(true);
													}
												}}
											>
												Сгенерировать логин и пароль
											</AppleButton>
											<AppleButton
												startIcon={<ContentCopyIcon />}
												onClick={() => {
													navigator.clipboard.writeText(`Логин: ${newUsername}\nПароль: ${newPassword}`);
													setSuccess('Данные скопированы в буфер обмена!');
													setOpenSuccess(true);
												}}
											>
												Скопировать в буфер обмена
											</AppleButton>
											<AppleButton
												type="submit"
												onClick={async () => {
													const lastNameErr = validateNamePart(newLastName, 'Фамилия');
													const firstNameErr = validateNamePart(newFirstName, 'Имя');
													const middleNameErr = validateNamePart(newMiddleName, 'Отчество');
													const fullNameErr = validateFullName(newLastName, newFirstName, newMiddleName);

													if (lastNameErr || firstNameErr || middleNameErr || fullNameErr) {
														setLastNameError(lastNameErr);
														setFirstNameError(firstNameErr);
														setMiddleNameError(middleNameErr);
														if (fullNameErr) {
															setError(fullNameErr);
															setOpenError(true);
														}
														return;
													}

													if (!newUsername.trim() || !newPassword.trim()) {
														setError('Логин и пароль обязательны.');
														setOpenError(true);
														return;
													}

													try {
														await axios.post(
															'http://localhost:5000/admin_api/admin/register',
															{
																username: newUsername,
																password: newPassword,
																last_name: newLastName,
																first_name: newFirstName,
																middle_name: newMiddleName,
															},
															{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
														);
														setSuccess('Пользователь успешно зарегистрирован!');
														setOpenSuccess(true);
														setNewLastName('');
														setNewFirstName('');
														setNewMiddleName('');
														setNewUsername('');
														setNewPassword('');
														setLastNameError('');
														setFirstNameError('');
														setMiddleNameError('');
													} catch (err) {
														setError(err.response?.data?.error || 'Не удалось зарегистрировать пользователя.');
														setOpenError(true);
													}
												}}
											>
												Создать
											</AppleButton>
										</Box>
										<Collapse in={openError}>
											{error && (
												<Alert
													severity="error"
													sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#FFF1F0', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
													onClose={() => setOpenError(false)}
												>
													{error}
												</Alert>
											)}
										</Collapse>
										<Collapse in={openSuccess}>
											{success && (
												<Alert
													severity="success"
													sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#E7F8E7', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
													onClose={() => setOpenSuccess(false)}
												>
													{success}
												</Alert>
											)}
										</Collapse>
									</form>
								</AppleCard>
							</>
						)}

						{value === 3 && (
							<Box sx={{ mt: 4 }}>
								<Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', mb: 2, position: 'relative' }}>
									<Typography variant="h5" sx={{ color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
										Работа с планами
									</Typography>
									<AppleButton
										startIcon={<HistoryIcon />}
										onClick={handleOpenPlanHistoryDrawer}
										sx={{ position: 'absolute', right: 16 }}
									>
										Показать историю
									</AppleButton>
								</Box>
								{plans.length > 0 ? (
									plans.map((plan) => {
										const entriesByType = plan.entries.reduce((acc, entry) => {
											const type = entry.type || 'unknown';
											if (!acc[type]) {
												acc[type] = { count: 0, type };
											}
											acc[type].count += 1;
											return acc;
										}, {});
										const groupedEntries = Object.values(entriesByType);

										return (
											<Accordion
												key={plan.id}
												sx={{ mb: 2, borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}
											>
												<AccordionSummary expandIcon={<ExpandMoreIcon />}>
													<Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
														<Box>
															<Typography variant="h6" sx={{ color: '#1D1D1F', whiteSpace: 'nowrap' }}>
																План на {plan.year} год
															</Typography>
															<Typography variant="body2" sx={{ color: '#6E6E73', mt: 0.5 }}>
																{plan.user && plan.user.full_name
																	? `${plan.user.full_name} (${plan.user.username || 'логин отсутствует'})`
																	: 'Пользователь не указан'}
															</Typography>
														</Box>
														<StatusChip status={plan.status} role={user.role} />
													</Box>
												</AccordionSummary>
												<AccordionDetails>
													<PlanTable>
														<TableHead>
															<TableRow>
																<TableCell>Планируемое количество</TableCell>
																<TableCell>Тип</TableCell>
															</TableRow>
														</TableHead>
														<Fade in={true} timeout={500} key={plansTransitionKey}>
															<TableBody>
																{groupedEntries.length > 0 ? (
																	groupedEntries.map((group, index) => (
																		<TableRow key={index}>
																			<TableCell sx={{ padding: '16px' }}>{group.count}</TableCell>
																			<TableCell>
																				{group.type === 'article'
																					? 'Статья'
																					: group.type === 'monograph'
																						? 'Монография'
																						: group.type === 'conference'
																							? 'Доклад/конференция'
																							: 'Не указано'}
																			</TableCell>
																		</TableRow>
																	))
																) : (
																	<TableRow>
																		<TableCell colSpan={2} sx={{ textAlign: 'center', color: '#6E6E73' }}>
																			Нет записей в плане.
																		</TableCell>
																	</TableRow>
																)}
															</TableBody>
														</Fade>
													</PlanTable>
													{plan.return_comment && (
														<Typography
															sx={{ mt: 2, color: '#000000', fontWeight: 600, display: 'flex', alignItems: 'center', gap: 1 }}
														>
															<WarningAmberIcon sx={{ color: '#FF3B30' }} />
															Комментарий при возврате: {plan.return_comment}
														</Typography>
													)}
													{plan.status === 'needs_review' && (
														<Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
															<GreenButton startIcon={<CheckIcon />} onClick={() => handleApprovePlan(plan)}>
																Утвердить
															</GreenButton>
															<AppleButton startIcon={<ReplayIcon />} onClick={() => handleOpenReturnDialog(plan)}>
																На доработку
															</AppleButton>
														</Box>
													)}
												</AccordionDetails>
											</Accordion>
										);
									})
								) : (
									<Typography sx={{ textAlign: 'center', color: '#6E6E73', mt: 2 }}>
										Нет планов для проверки.
									</Typography>
								)}
								<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
									<Pagination
										count={totalPagesPlans}
										page={currentPagePlans}
										onChange={handlePageChangePlans}
										color="primary"
										sx={{
											'& .MuiPaginationItem-root': {
												borderRadius: 20,
												'&:hover': { backgroundColor: 'grey.100' },
												'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
											},
										}}
									/>
								</Box>
								<Drawer
									anchor="right"
									open={openPlanHistoryDrawer}
									onClose={handleClosePlanHistoryDrawer}
									sx={{
										'& .MuiDrawer-paper': {
											width: 600,
											backgroundColor: '#FFFFFF',
											boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
											borderRadius: '16px 0 0 16px',
										},
									}}
								>
									<Box sx={{ p: 2, pr: 4 }}>
										<Typography variant="h6" sx={{ color: '#1D1D1F', fontWeight: 600, mb: 5 }}>
											История действий с планами
										</Typography>
										<Box sx={{ display: 'flex', gap: 2, mt: 2, mb: 2 }}>
											<AppleTextField
												label="Дата начала"
												type="date"
												value={dateFilterRange.start}
												onChange={(e) => {
													setDateFilterRange((prev) => ({ ...prev, start: e.target.value }));
													setPlanHistoryPage(1);
												}}
												InputLabelProps={{ shrink: true }}
												sx={{ width: '200px' }}
											/>
											<AppleTextField
												label="Дата окончания"
												type="date"
												value={dateFilterRange.end}
												onChange={(e) => {
													setDateFilterRange((prev) => ({ ...prev, end: e.target.value }));
													setPlanHistoryPage(1);
												}}
												InputLabelProps={{ shrink: true }}
												sx={{ width: '200px' }}
											/>
										</Box>
										{planActionHistory.length > 0 ? (
											<>
												<AppleTable
													sx={{
														mt: 2,
														backgroundColor: '#F5F5F7',
														boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
														borderRadius: '8px',
													}}
												>
													<TableHead>
														<TableRow sx={{ backgroundColor: '#0071E3', borderRadius: '8px 8px 0 0' }}>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '150px', borderTopLeftRadius: '8px' }}>
																План
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '150px' }}>
																Пользователь
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '120px' }}>
																Действие
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '140px', borderTopRightRadius: '8px' }}>
																Время
															</TableCell>
														</TableRow>
													</TableHead>
													<Fade in={true} timeout={500} key={planHistoryTransitionKey}>
														<TableBody>
															{planActionHistory.map((action) => (
																<TableRow key={action.id}>
																	<TableCell sx={{ minWidth: '150px', whiteSpace: 'nowrap' }}>
																		<Typography
																			sx={{
																				color: '#0071E3',
																				textDecoration: 'underline',
																				cursor: 'pointer',
																				'&:hover': { textDecoration: 'none' },
																			}}
																			onClick={() => {
																				if (action.id) {
																					handleClosePlanHistoryDrawer();
																					// navigate(`/plan/${action.id}`); // Раскомментируйте, если есть страница плана
																				} else {
																					setError('ID плана отсутствует в записи истории.');
																					setOpenError(true);
																				}
																			}}
																		>
																			План на {action.year} год
																		</Typography>
																	</TableCell>
																	<TableCell sx={{ minWidth: '150px', whiteSpace: 'normal', wordWrap: 'break-word' }}>
																		{action.user_full_name}
																	</TableCell>
																	<TableCell sx={{ minWidth: '120px' }}>
																		{action.action_type === 'approved' ? 'Утверждён' : 'Возвращён на доработку'}
																	</TableCell>
																	<TableCell sx={{ minWidth: '140px' }}>
																		{new Date(action.timestamp).toLocaleString('ru-RU')}
																	</TableCell>
																</TableRow>
															))}
														</TableBody>
													</Fade>
												</AppleTable>
												<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
													<Pagination
														count={totalPlanHistoryPages}
														page={planHistoryPage}
														onChange={handlePlanHistoryPageChange}
														color="primary"
														sx={{
															'& .MuiPaginationItem-root': {
																borderRadius: 20,
																'&:hover': { backgroundColor: 'grey.100' },
																'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
															},
														}}
													/>
												</Box>
											</>
										) : (
											<Typography sx={{ mt: 2, color: '#6E6E73' }}>
												Нет записей в истории действий с планами.
											</Typography>
										)}
									</Box>
								</Drawer>
							</Box>
						)}

						<Dialog
							open={openDeleteDialog}
							onClose={() => {
								setOpenDeleteDialog(false);
								setPublicationToDelete(null);
							}}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Подтвердите удаление
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<Typography sx={{ color: '#6E6E73' }}>
									Вы уверены, что хотите удалить публикацию "{publicationToDelete?.title}"?
								</Typography>
							</DialogContent>
							<DialogActions sx={{ padding: '16px 24px', borderTop: '1px solid #E5E5EA' }}>
								<CancelButton
									onClick={() => {
										setOpenDeleteDialog(false);
										setPublicationToDelete(null);
									}}
								>
									Отмена
								</CancelButton>
								<AppleButton onClick={handleDeletePlanConfirm}>Удалить</AppleButton>
							</DialogActions>
						</Dialog>

						<Dialog
							open={openEditDialog}
							onClose={handleEditCancel}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Редактировать публикацию
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<form onSubmit={handleEditSubmit}>
									<AppleTextField
										fullWidth
										label="Название"
										value={editTitle}
										onChange={(e) => setEditTitle(e.target.value)}
										margin="normal"
										variant="outlined"
									/>
									<AppleTextField
										fullWidth
										label="Авторы"
										value={editAuthors}
										onChange={(e) => setEditAuthors(e.target.value)}
										margin="normal"
										variant="outlined"
									/>
									<AppleTextField
										fullWidth
										label="Год"
										type="number"
										value={editYear}
										onChange={(e) => setEditYear(e.target.value)}
										margin="normal"
										variant="outlined"
									/>
									<AppleTextField
										fullWidth
										select
										label="Тип публикации"
										value={editType}
										onChange={(e) => setEditType(e.target.value)}
										margin="normal"
										variant="outlined"
									>
										<MenuItem value="article">Статья</MenuItem>
										<MenuItem value="monograph">Монография</MenuItem>
										<MenuItem value="conference">Доклад/конференция</MenuItem>
									</AppleTextField>
									<AppleTextField
										fullWidth
										select
										label="Статус"
										value={editStatus}
										onChange={(e) => setEditStatus(e.target.value)}
										margin="normal"
										variant="outlined"
										disabled={!editPublication?.file_url && !editFile}
									>
										<MenuItem value="draft">Черновик</MenuItem>
										<MenuItem value="needs_review">Нуждается в проверке</MenuItem>
										<MenuItem value="published" disabled={!editPublication?.file_url && !editFile}>
											Опубликовано
										</MenuItem>
									</AppleTextField>
									<Box sx={{ mt: 2 }}>
										<Typography variant="body2" sx={{ color: '#6E6E73', mb: 1 }}>
											Текущий файл: {editPublication?.file_url || 'Нет файла'}
										</Typography>
										<input
											type="file"
											accept=".pdf,.docx"
											onChange={(e) => setEditFile(e.target.files[0])}
											style={{ display: 'none' }}
											id="edit-upload-file"
										/>
										<label htmlFor="edit-upload-file">
											<AppleButton sx={{ border: '1px solid #D1D1D6', backgroundColor: '#F5F5F7', color: '#1D1D1F' }} component="span">
												Выбрать файл
											</AppleButton>
										</label>
										{editFile && <Typography sx={{ mt: 1, color: '#6E6E73' }}>{editFile.name}</Typography>}
									</Box>
									<Collapse in={openError}>
										{error && (
											<Alert
												severity="error"
												sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#FFF1F0', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
												onClose={() => setOpenError(false)}
											>
												{error}
											</Alert>
										)}
									</Collapse>
									<Collapse in={openSuccess}>
										{success && (
											<Alert
												severity="success"
												sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#E7F8E7', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
												onClose={() => setOpenSuccess(false)}
											>
												{success}
											</Alert>
										)}
									</Collapse>
									<DialogActions sx={{ padding: '16px 0', borderTop: '1px solid #E5E5EA' }}>
										<CancelButton onClick={handleEditCancel}>Отмена</CancelButton>
										<AppleButton type="submit">Сохранить</AppleButton>
									</DialogActions>
								</form>
							</DialogContent>
						</Dialog>

						<Dialog
							open={openReturnDialog}
							onClose={() => setOpenReturnDialog(false)}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
									maxWidth: '400px',
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Вернуть на доработку
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<Typography sx={{ color: '#6E6E73', mb: 2 }}>
									Пожалуйста, укажите комментарий для пользователя:
								</Typography>
								<TextField
									autoFocus
									margin="dense"
									label="Комментарий"
									type="text"
									fullWidth
									multiline
									rows={3}
									value={returnComment}
									onChange={(e) => setReturnComment(e.target.value)}
									variant="outlined"
								/>
							</DialogContent>
							<DialogActions sx={{ padding: '16px 24px', borderTop: '1px solid #E5E5EA' }}>
								<CancelButton onClick={() => setOpenReturnDialog(false)}>Отмена</CancelButton>
								<AppleButton
									onClick={() => {
										if (selectedPublication) {
											handleReturnPublicationForRevision(selectedPublication, returnComment);
										} else if (selectedPlan) {
											handleReturnForRevision();
										}
									}}
								>
									Отправить
								</AppleButton>
							</DialogActions>
						</Dialog>

						{value !== 2 && (
							<>
								<Collapse in={openError}>
									{error && (
										<Alert
											severity="error"
											sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#FFF1F0', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
											onClose={() => setOpenError(false)}
										>
											{error}
										</Alert>
									)}
								</Collapse>
								<Collapse in={openSuccess}>
									{success && (
										<Alert
											severity="success"
											sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#E7F8E7', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
											onClose={() => setOpenSuccess(false)}
										>
											{success}
										</Alert>
									)}
								</Collapse>
							</>
						)}
					</>
				)}
			</AppleCard>
		</Container>
	);
}

export default ManagerDashboard;

import React, { useEffect, useState, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
	Container,
	Typography,
	Card,
	Button,
	CardContent,
	Box,
	Pagination,
} from '@mui/material';
import { styled } from '@mui/system';
import { Document, Page, pdfjs } from 'react-pdf';
import 'react-pdf/dist/Page/AnnotationLayer.css';
import 'react-pdf/dist/Page/TextLayer.css';
import axios from 'axios';
import DownloadIcon from '@mui/icons-material/Download';
import { useAuth } from '../contexts/AuthContext';
import CommentSection from './CommentSection';

pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.min.js`;

const AppleButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#0071E3',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#0066CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const GreenButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: 'green',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': {
		backgroundColor: '#2EBB4A',
		boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
	},
	'&:disabled': {
		backgroundColor: '#D1D1D6',
		color: '#FFFFFF',
	},
});

const RedButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#FF3B30',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': {
		backgroundColor: '#E63935',
		boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
	},
	'&:disabled': {
		backgroundColor: '#D1D1D6',
		color: '#FFFFFF',
	},
});

const AppleCard = styled(Card)({
	borderRadius: '16px',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	backgroundColor: '#FFFFFF',
});

const DocumentViewer = styled(Box)({
	mb: 4,
	border: '1px solid #E5E5EA',
	borderRadius: '12px',
	overflow: 'hidden',
	backgroundColor: '#FFFFFF',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	width: '100%',
	height: '850px',
	display: 'flex',
	justifyContent: 'center',
	alignItems: 'flex-start',
	'&::-webkit-scrollbar': { display: 'none' },
	'-ms-overflow-style': 'none',
	'scrollbar-width': 'none',
});

function Publication() {
	const { id } = useParams();
	const [publication, setPublication] = useState(null);
	const [error, setError] = useState('');
	const [numPages, setNumPages] = useState(null);
	const [pageNumber, setPageNumber] = useState(1);
	const { user, isAuthenticated, csrfToken } = useAuth();
	const [hasReviewerComment, setHasReviewerComment] = useState(false);
	const [loadingUser, setLoadingUser] = useState(true);

	const fetchPublication = useCallback(async () => {
		try {
			const response = await axios.get(`http://localhost:5000/api/publications/${id}`, { withCredentials: true });
			setPublication(response.data);
			const reviewerComment = response.data.comments.some(
				(comment) =>
					['admin', 'manager'].includes(comment.user.role) ||
					comment.replies.some((reply) => ['admin', 'manager'].includes(reply.user.role))
			);
			setHasReviewerComment(reviewerComment);
		} catch (err) {
			console.error('Ошибка загрузки публикации:', err);
			setError('Не удалось загрузить публикацию. Попробуйте позже.');
		}
	}, [id]);

	useEffect(() => {
		fetchPublication();
	}, [fetchPublication]);

	useEffect(() => {
		if (user !== null) {
			setLoadingUser(false);
		}
	}, [user]);

	const onDocumentLoadSuccess = ({ numPages }) => {
		setNumPages(numPages);
	};

	const handleDownload = () => {
		if (publication && publication.file_url) {
			const fileUrl = `http://localhost:5000${publication.file_url}`;
			const link = document.createElement('a');
			link.href = fileUrl;
			link.download = publication.file_url.split('/').pop();
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		}
	};

	const handlePublish = async () => {
		try {
			const response = await axios.post(
				`http://localhost:5000/api/publications/${id}/publish`,
				{},
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			console.log('Publication response:', response.data);
			fetchPublication();
		} catch (err) {
			console.error('Ошибка при публикации:', err);
			setError('Не удалось опубликовать публикацию.');
		}
	};

	const handleReject = async () => {
		try {
			const reviewerComment = publication.comments
				.filter((comment) => ['admin', 'manager'].includes(comment.user.role))
				.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0]?.content || '';

			if (!reviewerComment) {
				setError('Добавьте комментарий перед отправкой на доработку.');
				return;
			}

			const response = await axios.post(
				`http://localhost:5000/api/publications/${id}/return-for-revision`,
				{ comment: reviewerComment },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			console.log('Return for revision response:', response.data);
			fetchPublication();
		} catch (err) {
			console.error('Ошибка при отправке на доработку:', err);
			setError('Не удалось отправить на доработку. Убедитесь, что был добавлен комментарий.');
		}
	};

	const handleCommentAdded = (newComment) => {
		setPublication((prev) => {
			if (newComment.parent_id) {
				const updatedComments = prev.comments.map((comment) =>
					comment.id === newComment.parent_id
						? { ...comment, replies: [...comment.replies, newComment] }
						: comment
				);
				return { ...prev, comments: updatedComments };
			}
			return { ...prev, comments: [...prev.comments, newComment] };
		});
		if (['admin', 'manager'].includes(newComment.user.role)) {
			setHasReviewerComment(true);
		}
	};

	if (error) return <Typography color="error">{error}</Typography>;
	if (!publication || loadingUser) return <Typography sx={{ color: '#212121' }}>Загрузка...</Typography>;

	const fileUrl = publication.file_url ? `http://localhost:5000${publication.file_url}` : null;

	// Функция для отображения статуса с учётом локализации и цвета
	const renderStatus = (status, returnedForRevision, isReviewer) => {
		console.log('renderStatus called with:', { status, returnedForRevision, isReviewer });

		let statusText = '';
		let statusColor = '#757575'; // Цвет по умолчанию (серый)
		let backgroundColor = 'transparent'; // Фон по умолчанию

		// Проверяем оба возможных условия для "Требует доработки"
		if (status === 'returned_for_revision' || (status === 'draft' && returnedForRevision)) {
			statusText = 'Требует доработки';
			statusColor = '#FF3B30'; // Белый текст
			backgroundColor = '#FFfff'; // Красный фон с приоритетом
			console.log('Condition matched: Требует доработки');
		} else if (isReviewer) {
			// Логика для менеджера или админа
			switch (status) {
				case 'draft':
					statusText = 'Черновик';
					break;
				case 'needs_review':
					statusText = 'Нуждается в проверке';
					statusColor = '#FF3B30'; // Красный текст
					break;
				case 'published':
					statusText = 'Опубликованные';
					break;
				default:
					statusText = status || 'Неизвестный статус';
			}
			console.log('Reviewer logic applied:', statusText);
		} else {
			// Логика для обычного пользователя
			if (status === 'needs_review') {
				statusText = 'На проверке';
			} else if (status === 'draft') {
				statusText = 'Черновик';
			} else if (status === 'published') {
				statusText = 'Опубликованные';
			} else {
				statusText = status || 'Неизвестный статус';
			}
			console.log('User logic applied:', statusText);
		}

		return (
			<Typography
				variant="body1"
				sx={{
					color: statusColor,
					backgroundColor: backgroundColor,
					display: 'inline-block',
					padding: 'px 8px',
					borderRadius: '4px',
					mb: 1,
				}}
			>
				{`Статус: ${statusText}`}
			</Typography>
		);
	};
	const isReviewer = ['admin', 'manager'].includes(user?.role);

	console.log('User:', user);
	console.log('User role:', user?.role);
	console.log('Publication status:', publication.status);
	console.log('Is reviewer and needs_review:', isReviewer && publication.status === 'needs_review');

	return (
		<Container maxWidth="lg" sx={{ mt: 8, mb: 4 }}>
			<AppleCard elevation={4}>
				<CardContent sx={{ pt: 4, pb: 4 }}>
					<Typography variant="h4" sx={{ color: '#1D1D1F', mb: 2, fontWeight: 600 }}>
						{publication.title}
					</Typography>
					<Typography variant="body1" sx={{ color: '#757575', mb: 1 }}>
						Авторы: {publication.authors}
					</Typography>
					<Typography variant="body1" sx={{ color: '#757575', mb: 1 }}>
						Год: {publication.year}
					</Typography>
					<Typography variant="body1" sx={{ color: '#757575', mb: 1 }}>
						Тип: {publication.type === 'article' ? 'Статья' : publication.type === 'monograph' ? 'Монография' : publication.type === 'conference' ? 'Доклад/конференция' : publication.type}
					</Typography>
					{renderStatus(publication.status, publication.returned_for_revision, isReviewer)}
					<Typography variant="body1" sx={{ color: '#757575', mb: 2 }}>
						Опубликовал: {publication.user.full_name}
					</Typography>

					<Typography variant="h6" sx={{ color: '#1D1D1F', mb: 2, fontWeight: 500 }}>
						Предпросмотр:
					</Typography>
					{fileUrl ? (
						fileUrl.endsWith('.pdf') ? (
							<>
								<DocumentViewer>
									<Document
										file={fileUrl}
										onLoadSuccess={onDocumentLoadSuccess}
										onLoadError={(err) => setError(`Ошибка загрузки PDF: ${err.message}`)}
									>
										<Page
											pageNumber={pageNumber}
											scale={1}
											renderTextLayer={false}
											renderAnnotationLayer={false}
										/>
									</Document>
								</DocumentViewer>
								{numPages > 1 && (
									<Box sx={{ display: 'flex', justifyContent: 'center', mt: 2, mb: 4 }}>
										<Pagination
											count={numPages}
											page={pageNumber}
											onChange={(event, newPage) => setPageNumber(newPage)}
											color="primary"
											sx={{
												'& .MuiPaginationItem-root': {
													borderRadius: 20,
													transition: 'all 0.3s ease',
													'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
													'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
												},
											}}
										/>
									</Box>
								)}
							</>
						) : fileUrl.endsWith('.docx') ? (
							<Typography sx={{ color: '#6E6E73', mb: 2 }}>
								Файл загружен в формате DOCX, предпросмотр недоступен.
							</Typography>
						) : (
							<Typography sx={{ color: '#6E6E73', mb: 2 }}>
								Формат файла не поддерживается для отображения (только PDF и DOCX).
							</Typography>
						)
					) : (
						<Typography sx={{ color: '#6E6E73', mb: 2 }}>
							Файл не прикреплен к этой публикации.
						</Typography>
					)}
					{fileUrl && (
						<Box sx={{ mb: 2 }}>
							<AppleButton startIcon={<DownloadIcon />} onClick={handleDownload}>
								Скачать
							</AppleButton>
						</Box>
					)}

					{isReviewer && publication.status === 'needs_review' && (
						<Box sx={{ mb: 2, display: 'flex', gap: 2 }}>
							<GreenButton onClick={handlePublish}>Опубликовать</GreenButton>
							<RedButton onClick={handleReject} disabled={!hasReviewerComment}>
								Отправить на доработку
							</RedButton>
						</Box>
					)}

					<Typography variant="h5" sx={{ color: '#1D1D1F', mb: 2, fontWeight: 600 }}>
						Комментарии
					</Typography>
					{publication.comments && (
						<CommentSection
							comments={publication.comments}
							publicationId={publication.id}
							onCommentAdded={handleCommentAdded}
						/>
					)}
				</CardContent>
			</AppleCard>
		</Container>
	);
}

export default Publication;
D:\publication-system\backend\app\api.py

from flask import Blueprint, jsonify, request, send_file
from werkzeug.utils import secure_filename
from flask_login import login_required, current_user
from flask import current_app
from app.extensions import db
from app.models import Publication, User, Plan, PlanEntry, PlanActionHistory, PublicationActionHistory
import os
import logging
from io import BytesIO
import bibtexparser
from datetime import datetime
from sqlalchemy import or_


bp = Blueprint('admin_api', __name__, url_prefix='/admin_api')
logger = logging.getLogger(__name__)

def admin_or_manager_required(f):
    @login_required
    def wrapper(*args, **kwargs):
        if current_user.role not in ['admin', 'manager']:
            logger.warning(f"Unauthorized access attempt by user {current_user.id} with role {current_user.role}")
            return jsonify({"error": "Доступ запрещён. Требуется роль администратора или управляющего."}), 403
        return f(*args, **kwargs)
    wrapper.__name__ = f.__name__
    return wrapper

def admin_required(f):
    @login_required
    def wrapper(*args, **kwargs):
        if current_user.role != 'admin':
            logger.warning(f"Unauthorized access attempt by user {current_user.id} with role {current_user.role}")
            return jsonify({"error": "Доступ запрещён. Требуется роль администратора."}), 403
        return f(*args, **kwargs)
    wrapper.__name__ = f.__name__
    return wrapper

@bp.route('/admin/users', methods=['GET'])
@admin_required
def get_users():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)

    query = User.query
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (User.username.ilike(search_pattern)) |
            (User.last_name.ilike(search_pattern)) |
            (User.first_name.ilike(search_pattern)) |
            (User.middle_name.ilike(search_pattern))
        )

    paginated_users = query.paginate(page=page, per_page=per_page, error_out=False)
    users = [{
        'id': user.id,
        'username': user.username,
        'role': user.role,
        'last_name': user.last_name,
        'first_name': user.first_name,
        'middle_name': user.middle_name,
        'full_name': user.full_name,
    } for user in paginated_users.items]

    return jsonify({
        'users': users,
        'pages': paginated_users.pages,
        'total': paginated_users.total
    }), 200

@bp.route('/admin/users/<int:user_id>', methods=['PUT'])
@admin_required
def update_user(user_id):
    user = User.query.get_or_404(user_id)
    data = request.get_json()

    user.username = data.get('username', user.username)
    user.role = data.get('role', user.role)
    user.last_name = data.get('last_name', user.last_name)
    user.first_name = data.get('first_name', user.first_name)
    user.middle_name = data.get('middle_name', user.middle_name)

    if 'new_password' in data and data['new_password']:
        user.set_password(data['new_password'])

    try:
        db.session.commit()
        return jsonify({
            'message': 'Пользователь успешно обновлён',
            'user': {
                'id': user.id,
                'username': user.username,
                'role': user.role,
                'last_name': user.last_name,
                'first_name': user.first_name,
                'middle_name': user.middle_name
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при обновлении пользователя {user_id}: {str(e)}")
        return jsonify({"error": "Ошибка при обновлении пользователя. Попробуйте позже."}), 500

@bp.route('/admin/users/<int:user_id>', methods=['DELETE'])
@admin_required
def delete_user(user_id):
    user = User.query.get_or_404(user_id)

    if user.id == current_user.id:
        return jsonify({"error": "Нельзя удалить самого себя."}), 400

    try:
        db.session.delete(user)
        db.session.commit()
        return jsonify({"message": "Пользователь успешно удалён."}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при удалении пользователя {user_id}: {str(e)}")
        return jsonify({"error": "Ошибка при удалении пользователя. Попробуйте позже."}), 500

@bp.route('/admin/publications', methods=['GET'])
@admin_or_manager_required
def get_publications():
    # Получаем параметры запроса
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)
    pub_type = request.args.get('type', 'all', type=str)
    status = request.args.get('status', 'all', type=str)
    sort_status = request.args.get('sort_status', None, type=str)
    sort_by = request.args.get('sort_by', 'updated_at', type=str)  # По умолчанию updated_at
    sort_order = request.args.get('sort_order', 'desc', type=str)  # По умолчанию desc

    # Логируем параметры для отладки
    logger.debug(f"Параметры запроса: page={page}, per_page={per_page}, search={search}, type={pub_type}, status={status}, sort_status={sort_status}, sort_by={sort_by}, sort_order={sort_order}")

    # Базовый запрос
    query = Publication.query

    # Применяем фильтр поиска
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (Publication.title.ilike(search_pattern)) |
            (Publication.authors.ilike(search_pattern)) |
            (db.cast(Publication.year, db.String).ilike(search_pattern))
        )

    # Фильтры по типу и статусу
    if pub_type != 'all':
        query = query.filter_by(type=pub_type)
    
    valid_statuses = ['draft', 'needs_review', 'returned_for_revision', 'published']
    if status != 'all':
        status_list = status.split(',')
        filtered_statuses = [s for s in status_list if s in valid_statuses]
        if not filtered_statuses:
            return jsonify({"error": "Указаны недопустимые статусы"}), 400
        query = query.filter(Publication.status.in_(filtered_statuses))
    else:
        filtered_statuses = valid_statuses

    # Ограничение для менеджеров
    if current_user.role == 'manager':
        allowed_statuses = ['needs_review', 'returned_for_revision', 'published']
        query = query.filter(Publication.status.in_(allowed_statuses))
        filtered_statuses = allowed_statuses

    # Определяем поле для сортировки
    valid_sort_fields = ['id', 'title', 'year', 'updated_at', 'published_at']
    if sort_by not in valid_sort_fields:
        sort_by = 'updated_at'  # По умолчанию
    sort_column = getattr(Publication, sort_by)

    # Определяем направление сортировки
    if sort_order == 'desc':
        sort_column = sort_column.desc()
    else:
        sort_column = sort_column.asc()

    # Применяем сортировку
    if sort_status and sort_status in filtered_statuses:
        sort_case = db.case(
            {sort_status: 0},
            value=Publication.status,
            else_=1
        ).label('status_priority')
        query = query.order_by(sort_case, sort_column)
    else:
        query = query.order_by(sort_column)

    # Пагинация
    try:
        paginated_publications = query.paginate(page=page, per_page=per_page, error_out=False)
    except Exception as e:
        logger.error(f"Ошибка пагинации: {str(e)}")
        return jsonify({"error": "Ошибка сервера при загрузке публикаций"}), 500

    # Формируем ответ
    publications = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'user': {
            'id': pub.user.id if pub.user else None,
            'full_name': pub.user.full_name if pub.user else None
        },
        'returned_for_revision': pub.returned_for_revision,
        'published_at': pub.published_at.isoformat() if pub.published_at else None,
        'updated_at': pub.updated_at.isoformat() if pub.updated_at else None  # Добавляем updated_at в ответ
    } for pub in paginated_publications.items]

    return jsonify({
        'publications': publications,
        'pages': paginated_publications.pages,
        'total': paginated_publications.total
    }), 200
@bp.route('/admin/publications/<int:pub_id>', methods=['PUT'])
@admin_or_manager_required
def update_publication(pub_id):
    # Получаем публикацию или возвращаем 404
    publication = Publication.query.get_or_404(pub_id)

    # Обрабатываем загрузку файла, если есть
    if 'file' in request.files:
        file = request.files['file']
        if file and allowed_file(file.filename):
            if publication.file_url:
                old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                if os.path.exists(old_file_path):
                    os.remove(old_file_path)
            filename = secure_filename(file.filename)
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
            if os.path.exists(file_path):
                base, extension = os.path.splitext(filename)
                counter = 1
                while os.path.exists(file_path):
                    filename = f"{base}_{counter}{extension}"
                    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                    counter += 1
            try:
                file.save(file_path)
                publication.file_url = f"/uploads/{filename}"
            except Exception as e:
                logger.error(f"Ошибка при сохранении файла: {str(e)}")
                return jsonify({"error": "Ошибка при сохранении файла. Попробуйте снова."}), 500

    # Получаем данные
    data = request.form if 'file' in request.files else request.get_json()
    publication.title = data.get('title', publication.title)
    publication.authors = data.get('authors', publication.authors)
    publication.year = int(data.get('year', publication.year))
    publication.type = data.get('type', publication.type)
    new_status = data.get('status', publication.status)
    comment = data.get('return_comment', '')  # Комментарий для любого действия

    # Записываем действие в историю при смене статуса
    if new_status != publication.status:
        timestamp = datetime.utcnow()  # Время действия
        if new_status == 'published':
            publication.published_at = timestamp
            publication.returned_for_revision = False
            publication.returned_at = None
            publication.return_comment = None
            action_type = 'published'  # Исправляем на логичное значение
        elif new_status == 'returned_for_revision':
            publication.returned_for_revision = True
            publication.returned_at = timestamp
            publication.return_comment = comment
            action_type = 'returned'
        else:
            # Для других статусов (например, 'needs_review')
            action_type = new_status  # Используем новый статус как тип действия
            if publication.status in ['published', 'returned_for_revision']:
                publication.published_at = None
                publication.returned_at = None
                publication.return_comment = None
                publication.returned_for_revision = False

        # Создаем запись в истории
        action = PublicationActionHistory(
            publication_id=publication.id,
            user_id=current_user.id,
            action_type=action_type,
            timestamp=timestamp,
            comment=comment if comment.strip() else None  # Записываем комментарий, если он не пустой
        )
        db.session.add(action)

    publication.status = new_status

    try:
        db.session.commit()
        logger.debug(f"Публикация {pub_id} обновлена пользователем {current_user.id}, новый статус: {new_status}")
        return jsonify({
            'message': 'Публикация успешно обновлена',
            'publication': publication.to_dict()
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при обновлении публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при обновлении публикации. Попробуйте позже."}), 500
@bp.route('/admin/publications/<int:pub_id>', methods=['DELETE'])
@admin_or_manager_required
def delete_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    try:
        if publication.file_url:
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
            if os.path.exists(file_path):
                os.remove(file_path)

        db.session.delete(publication)
        db.session.commit()
        return jsonify({"message": "Публикация успешно удалена."}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при удалении публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при удалении публикации. Попробуйте позже."}), 500

@bp.route('/admin/publications/needs-review', methods=['GET'])
@admin_or_manager_required
def get_needs_review_publications():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)

    query = Publication.query.filter_by(status='needs_review')
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (Publication.title.ilike(search_pattern)) |
            (Publication.authors.ilike(search_pattern)) |
            (Publication.year.ilike(search_pattern))
        )

    paginated_publications = query.paginate(page=page, per_page=per_page, error_out=False)

    publications = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'user': {
            'id': pub.user.id if pub.user else None,
            'full_name': pub.user.full_name if pub.user else None
        },
        'returned_for_revision': pub.returned_for_revision,
        'published_at': pub.published_at.isoformat() if pub.published_at else None
    } for pub in paginated_publications.items]

    return jsonify({
        'publications': publications,
        'pages': paginated_publications.pages,
        'total': paginated_publications.total
    }), 200 

@bp.route('/admin/register', methods=['POST'])
@admin_or_manager_required
def register():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    last_name = data.get('last_name')
    first_name = data.get('first_name')
    middle_name = data.get('middle_name')

    if not username or not password:
        return jsonify({"error": "Логин и пароль обязательны."}), 400

    existing_user = User.query.filter_by(username=username).first()
    if existing_user:
        return jsonify({"error": "Пользователь с таким логином уже существует."}), 400

    new_user = User(
        username=username,
        last_name=last_name,
        first_name=first_name,
        middle_name=middle_name,
    )
    new_user.set_password(password)

    try:
        db.session.add(new_user)
        db.session.commit()
        logger.debug(f"User registered successfully: {username}, response: {'Пользователь успешно зарегистрирован.'}")
        return jsonify({"message": "Пользователь успешно зарегистрирован."}), 201
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при регистрации пользователя {username}: {str(e)}")
        return jsonify({"error": "Ошибка при регистрации. Попробуйте позже."}), 500

@bp.route('/admin/check-username', methods=['POST'])
@admin_or_manager_required
def check_username():
    data = request.get_json()
    username = data.get('username')
    user = User.query.filter_by(username=username).first()
    return jsonify({'exists': user is not None})

@bp.route('/admin/generate-password', methods=['GET'])
@admin_or_manager_required
def generate_password():
    import secrets
    import string
    # Используем только буквы (строчные и заглавные) и цифры
    characters = string.ascii_letters + string.digits
    password = ''.join(secrets.choice(characters) for _ in range(12))
    return jsonify({'password': password})

@bp.route('/admin/plans', methods=['GET'])
@admin_or_manager_required
def get_all_plans():
    logger.debug(f"Получен GET запрос для /admin_api/admin/plans")
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    pagination = Plan.query.order_by(Plan.year.desc()).paginate(page=page, per_page=per_page)
    plans = pagination.items
    return jsonify({
        'plans': [plan.to_dict() for plan in plans],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/admin/plans/<int:plan_id>', methods=['PUT'])
@admin_required
def update_plan(plan_id):
    logger.debug(f"Получен PUT запрос для /admin_api/admin/plans/{plan_id}")
    plan = Plan.query.get_or_404(plan_id)
    data = request.get_json()
    if not all(k in data for k in ('year', 'expectedCount', 'fillType', 'user_id', 'entries')):
        return jsonify({'error': 'Missing required fields'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Invalid year'}), 400
    
    if not isinstance(data['expectedCount'], int) or data['expectedCount'] < 1:
        return jsonify({'error': 'Expected count must be at least 1'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Invalid fill type'}), 400

    plan.year = data['year']
    plan.expectedCount = data['expectedCount']
    plan.fillType = data['fillType']
    plan.user_id = data['user_id']

    PlanEntry.query.filter_by(plan_id=plan.id).delete()
    for entry_data in data['entries']:
        entry = PlanEntry(
            title=entry_data.get('title'),
            type=entry_data.get('type'),
            publication_id=entry_data.get('publication_id'),
            status=entry_data.get('status', 'planned'),
            plan=plan
        )
        if entry.publication_id:
            publication = Publication.query.filter_by(id=entry.publication_id, user_id=plan.user_id, status='published').first()
            if not publication:
                db.session.rollback()
                return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
        db.session.add(entry)

    db.session.commit()
    return jsonify({'message': 'Plan updated successfully', 'plan': plan.to_dict()}), 200

@bp.route('/admin/plans/<int:plan_id>', methods=['DELETE'])
@admin_required
def delete_plan(plan_id):
    logger.debug(f"Получен DELETE запрос для /admin_api/admin/plans/{plan_id}")
    plan = Plan.query.get_or_404(plan_id)
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'Cannot delete plan that is under review or approved'}), 403
    
    db.session.delete(plan)
    db.session.commit()
    return jsonify({'message': 'Plan deleted successfully'}), 200

@bp.route('/admin/plans/<int:plan_id>/approve', methods=['POST'])
@admin_or_manager_required
def approve_plan(plan_id):
    plan = Plan.query.get_or_404(plan_id)
    plan.status = 'approved'
    plan.approved_at = datetime.utcnow()
    # Не сбрасываем returned_at и return_comment

    # Добавляем запись в историю
    action = PlanActionHistory(
        plan_id=plan.id,
        action_type='approved',
        timestamp=plan.approved_at,
        user_id=current_user.id  # Кто утвердил
    )
    db.session.add(action)
    db.session.commit()
    return jsonify({"message": "План утверждён"}), 200
@bp.route('/admin/plans/<int:plan_id>/return-for-revision', methods=['POST'])
@admin_or_manager_required
def return_plan_for_revision(plan_id):
    plan = Plan.query.get_or_404(plan_id)
    data = request.get_json()
    comment = data.get('comment', '')
    plan.status = 'returned'
    plan.return_comment = comment
    plan.returned_at = datetime.utcnow()
    # Не сбрасываем approved_at

    # Добавляем запись в историю
    action = PlanActionHistory(
        plan_id=plan.id,
        action_type='returned',
        timestamp=plan.returned_at,
        comment=comment,
        user_id=current_user.id  # Кто вернул
    )
    db.session.add(action)
    db.session.commit()
    return jsonify({"message": "План возвращён на доработку"}), 200
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in {'pdf', 'docx'}

def get_publications_by_year(user_id):
    publications = Publication.query.filter_by(user_id=user_id).all()
    yearly_counts = {}
    for pub in publications:
        year = pub.year
        yearly_counts[year] = yearly_counts.get(year, 0) + 1
    return sorted(yearly_counts.items(), key=lambda x: x[0])


@bp.route('/admin/plan-action-history', methods=['GET'])
@admin_or_manager_required
def get_plan_action_history():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    start_date = request.args.get('start_date', type=str)
    end_date = request.args.get('end_date', type=str)

    # Базовый запрос к истории действий
    query = PlanActionHistory.query.join(Plan).filter(
        PlanActionHistory.action_type.in_(['approved', 'returned'])
    )

    # Фильтрация по датам
    if start_date:
        try:
            start_datetime = datetime.strptime(start_date, '%Y-%m-%d')
            query = query.filter(PlanActionHistory.timestamp >= start_datetime)
        except ValueError as e:
            logger.error(f"Некорректный формат start_date: {start_date}, ошибка: {str(e)}")
            return jsonify({"error": "Некорректный формат даты начала"}), 400

    if end_date:
        try:
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            query = query.filter(PlanActionHistory.timestamp <= end_datetime)
        except ValueError as e:
            logger.error(f"Некорректный формат end_date: {end_date}, ошибка: {str(e)}")
            return jsonify({"error": "Некорректный формат даты окончания"}), 400

    # Сортировка по убыванию (новые действия первыми)
    query = query.order_by(desc(PlanActionHistory.timestamp))

    # Пагинация
    paginated_actions = query.paginate(page=page, per_page=per_page, error_out=False)
    
    logger.debug(f"Найдено действий: {paginated_actions.total}")
    for action in paginated_actions.items:
        logger.debug(f"Действие ID={action.id}, план ID={action.plan_id}, тип={action.action_type}, время={action.timestamp}")

    # Формируем историю
    history = []
    for action in paginated_actions.items:
        history.append({
            'id': action.plan_id,  # ID плана
            'year': action.plan.year,
            'action_type': action.action_type,
            'timestamp': action.timestamp.isoformat(),
            'comment': action.comment,
            'user_full_name': action.plan.user.full_name if action.plan.user else "Не указан"
        })

    return jsonify({
        'history': history,
        'pages': paginated_actions.pages,
        'total': paginated_actions.total
    }), 200


@bp.route('admin/plans/needs-review', methods=['GET'])
@login_required
def get_needs_review_plans():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    
    # Запрос планов со статусом 'needs_review'
    plans_query = Plan.query.filter_by(status='needs_review')
    pagination = plans_query.paginate(page=page, per_page=per_page, error_out=False)
    
    plans = [plan.to_dict() for plan in pagination.items]
    
    return jsonify({
        'plans': plans,
        'pages': pagination.pages,
        'total': pagination.total
    })


from sqlalchemy import case, or_, desc, func

@bp.route('/admin/publication-action-history', methods=['GET'])
@admin_or_manager_required
def get_publication_action_history():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    start_date = request.args.get('start_date', type=str)
    end_date = request.args.get('end_date', type=str)

    query = PublicationActionHistory.query.join(Publication).filter(
        PublicationActionHistory.action_type.in_(['approved', 'returned'])
    )

    if start_date:
        try:
            start_datetime = datetime.strptime(start_date, '%Y-%m-%d')
            query = query.filter(PublicationActionHistory.timestamp >= start_datetime)
        except ValueError:
            return jsonify({"error": "Некорректный формат даты начала"}), 400

    if end_date:
        try:
            end_datetime = datetime.strptime(end_date, '%Y-%m-%d')
            query = query.filter(PublicationActionHistory.timestamp <= end_datetime)
        except ValueError:
            return jsonify({"error": "Некорректный формат даты окончания"}), 400

    query = query.order_by(db.desc(PublicationActionHistory.timestamp))
    paginated_actions = query.paginate(page=page, per_page=per_page, error_out=False)

    history = [{
        'id': action.publication_id,
        'title': action.publication.title,
        'action_type': action.action_type,
        'timestamp': action.timestamp.isoformat(),
        'comment': action.comment,
        'user_full_name': action.user.full_name if action.user else "Не указан"
    } for action in paginated_actions.items]

    return jsonify({
        'history': history,
        'pages': paginated_actions.pages,
        'total': paginated_actions.total
    }), 200


		D:\publication-system\backend\app\models.py

		from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash
from .extensions import db
from flask_login import UserMixin

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    publication_id = db.Column(db.Integer, db.ForeignKey('publication.id'), nullable=False)
    parent_id = db.Column(db.Integer, db.ForeignKey('comment.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.utcnow(), nullable=False)

    user = db.relationship('User', backref='comments', lazy=True)
    publication = db.relationship('Publication', backref='comments', lazy=True)
    parent = db.relationship('Comment', remote_side=[id], backref='replies', lazy=True)

class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    publications = db.relationship('Publication', back_populates='user', lazy=True)
    password_hash = db.Column(db.Text)
    role = db.Column(db.String(20), default='user', nullable=False)  # 'user', 'admin', 'manager'
    last_name = db.Column(db.String(100), nullable=True)
    first_name = db.Column(db.String(100), nullable=True)
    middle_name = db.Column(db.String(100), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.utcnow(), nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    @property
    def full_name(self):
        return f"{self.last_name or ''} {self.first_name or ''} {self.middle_name or ''}".strip()
    
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
    
    def is_active(self):
        return True

    def is_authenticated(self):
        return True

    def is_anonymous(self):
        return False
    
    def get_id(self):
        return str(self.id)
    
		

class Publication(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    authors = db.Column(db.String(200), nullable=False)
    year = db.Column(db.Integer, nullable=False)
    type = db.Column(db.String(50), nullable=False)
    status = db.Column(db.String(50), nullable=False, default='draft')
    file_url = db.Column(db.String(200), nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='SET NULL'), nullable=True)
    updated_at = db.Column(db.DateTime, default=lambda: datetime.utcnow(), onupdate=lambda: datetime.utcnow(), nullable=False)
    returned_for_revision = db.Column(db.Boolean, default=False)
    published_at = db.Column(db.DateTime, nullable=True)
    # Новые поля
    returned_at = db.Column(db.DateTime, nullable=True)  # Время возврата на доработку
    return_comment = db.Column(db.Text, nullable=True)   # Комментарий при возврате

    user = db.relationship('User', back_populates='publications', lazy=True)
    plan_entries = db.relationship('PlanEntry', back_populates='publication', lazy=True)
    @property
    def type_ru(self):
        return {
            'article': 'Статья',
            'monograph': 'Монография',
            'conference': 'Доклад/конференция'
        }.get(self.type, self.type)

    @property
    def status_ru(self):
        return {
            'draft': 'Черновик',
            'needs_review': 'На проверке',
            'published': 'Опубликованные'
        }.get(self.status, self.status)

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'authors': self.authors,
            'year': self.year,
            'type': self.type,
            'status': self.status,
            'file_url': self.file_url,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'returned_for_revision': self.returned_for_revision,
            'published_at': self.published_at.isoformat() if self.published_at else None,
            'returned_at': self.returned_at.isoformat() if self.returned_at else None,  # Добавляем новое поле
            'return_comment': self.return_comment,  # Добавляем новое поле
            'user': {
                'full_name': self.user.full_name if self.user else None
            } if self.user else None
        }

class PlanActionHistory(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    plan_id = db.Column(db.Integer, db.ForeignKey('plan.id'), nullable=False)
    action_type = db.Column(db.String(20), nullable=False)  # 'approved', 'returned', etc.
    timestamp = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    comment = db.Column(db.Text, nullable=True)  # Комментарий для возврата
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)  # Кто выполнил действие

    plan = db.relationship('Plan', backref=db.backref('action_history', lazy='dynamic'))
    user = db.relationship('User', backref='plan_actions')
    
class PublicationActionHistory(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    publication_id = db.Column(db.Integer, db.ForeignKey('publication.id'), nullable=False)
    action_type = db.Column(db.String(20), nullable=False)  # 'approved', 'returned'
    timestamp = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    comment = db.Column(db.Text, nullable=True)  # Комментарий для возврата
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)  # Кто выполнил действие

    publication = db.relationship('Publication', backref=db.backref('action_history', lazy='dynamic'))
    user = db.relationship('User', backref='publication_actions')		
class Achievement(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    badge = db.Column(db.String(50))
    date_earned = db.Column(db.DateTime, default=lambda: datetime.utcnow(), nullable=False)

    user = db.relationship('User', backref='achievements', lazy=True)

    @staticmethod
    def check_achievements(user_id):
        user = User.query.get_or_404(user_id)
        pub_count = Publication.query.filter_by(user_id=user_id).count()

        achievements = [
            ('top_author', pub_count >= 10),
            ('10_publications', pub_count >= 10),
            ('50_publications', pub_count >= 50)
        ]

        for badge, condition in achievements:
            if condition and not Achievement.query.filter_by(user_id=user_id, badge=badge).first():
                new_achievement = Achievement(user_id=user_id, badge=badge)
                db.session.add(new_achievement)
        db.session.commit()

class Plan(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    year = db.Column(db.Integer, nullable=False)
    fillType = db.Column(db.String(10), nullable=False, default='manual')
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    status = db.Column(db.String(20), nullable=False, default='draft')
    return_comment = db.Column(db.Text, nullable=True)
    approved_at = db.Column(db.DateTime, nullable=True)  # Новое поле
    returned_at = db.Column(db.DateTime, nullable=True)  # Новое поле

    user = db.relationship('User', backref='plans', lazy=True)
    entries = db.relationship('PlanEntry', back_populates='plan', lazy=True, cascade='all, delete-orphan')

    def to_dict(self):
        plan_count = len(self.entries)
        fact_count = sum(1 for entry in self.entries if entry.publication_id is not None)
        return {
            'id': self.id,
            'year': self.year,
            'fillType': self.fillType,
            'status': self.status,
            'user': {
                'full_name': self.user.full_name if self.user else None,
                'username': self.user.username if self.user else None
            } if self.user else None,
            'entries': [entry.to_dict() for entry in self.entries],
            'return_comment': self.return_comment,
            'plan_count': plan_count,
            'fact_count': fact_count,
            'approved_at': self.approved_at.isoformat() if self.approved_at else None,  # Добавляем в ответ
            'returned_at': self.returned_at.isoformat() if self.returned_at else None,  # Добавляем в ответ
        }

class PlanEntry(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    plan_id = db.Column(db.Integer, db.ForeignKey('plan.id'), nullable=False)
    title = db.Column(db.String(200), nullable=True)  # Для ручного заполнения
    type = db.Column(db.String(50), nullable=True)  # Для ручного заполнения
    publication_id = db.Column(db.Integer, db.ForeignKey('publication.id'), nullable=True)  # Для привязки
    status = db.Column(db.String(50), nullable=False, default='planned')  # 'planned', 'in_progress', 'completed'
    isPostApproval = db.Column(db.Boolean, nullable=False, default=False)  # Новое поле

    plan = db.relationship('Plan', back_populates='entries')
    publication = db.relationship('Publication', back_populates='plan_entries', lazy=True)

    def to_dict(self):
        from flask_login import current_user
        result = {
            'id': self.id,
            'title': self.title,
            'type': self.type,
            'publication_id': self.publication_id,
            'status': self.status,
            'isPostApproval': self.isPostApproval,  # Добавляем поле в ответ
            'publication': {
                'id': self.publication.id,
                'title': self.publication.title
            } if self.publication else None
        }
        if current_user.is_authenticated and current_user.role in ['admin', 'manager']:
            result['status'] = self.status
        return result


			D:\publication-system\frontend\src\components\ManagerDashboard.js	
			import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
	Container,
	Typography,
	Card as AppleCard,
	Tabs,
	Tab,
	Box,
	CircularProgress,
	Table,
	TableBody,
	TableCell,
	TableHead,
	TableRow,
	IconButton,
	Dialog,
	DialogTitle,
	DialogContent,
	DialogActions,
	TextField,
	Collapse,
	Alert,
	Pagination,
	Fade,
	MenuItem,
	Button,
	Drawer,
	Accordion,
	AccordionSummary,
	AccordionDetails,
} from '@mui/material';
import { styled } from '@mui/system';
import DeleteIcon from '@mui/icons-material/Delete';
import DownloadIcon from '@mui/icons-material/Download';
import CheckIcon from '@mui/icons-material/Check';
import ReplayIcon from '@mui/icons-material/Replay';
import RefreshIcon from '@mui/icons-material/Refresh';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import Visibility from '@mui/icons-material/Visibility';
import VisibilityOff from '@mui/icons-material/VisibilityOff';
import HistoryIcon from '@mui/icons-material/History';
import WarningAmberIcon from '@mui/icons-material/WarningAmber';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import axios from 'axios';
import { useAuth } from '../contexts/AuthContext';
import StatusChip from './StatusChip';

// Стили
const AppleTextField = styled(TextField)({
	'& .MuiOutlinedInput-root': {
		borderRadius: '12px',
		backgroundColor: '#F5F5F7',
		'& fieldset': { borderColor: '#D1D1D6' },
		'&:hover fieldset': { borderColor: '#0071E3' },
		'&.Mui-focused fieldset': { borderColor: '#0071E3' },
	},
	'& .MuiInputLabel-root': { color: '#6E6E73' },
	'& .MuiInputLabel-root.Mui-focused': { color: '#0071E3' },
});

const AppleTable = styled(Table)({
	borderCollapse: 'separate',
	borderSpacing: '0 8px',
});

const PlanTable = styled(Table)({
	borderRadius: '16px',
	overflow: 'hidden',
	backgroundColor: '#FFFFFF',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	marginBottom: '16px',
});

const AppleButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#0071E3',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#0066CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const GreenButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: 'green',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#2EBB4A', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const CancelButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#D1D1D6',
	color: '#1D1D1F',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#C7C7CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

// Регулярные выражения для проверки ФИО
const namePartRegex = /^[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?$/;
const fullNameRegex = /^[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?\s[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?\s[А-ЯЁ][а-яё]+(?:-[А-ЯЁ][а-яё]+)?$/;

function ManagerDashboard() {
	const { user, csrfToken, isAuthenticated } = useAuth();
	const navigate = useNavigate();
	const [value, setValue] = useState(0);
	const [publications, setPublications] = useState([]);
	const [plans, setPlans] = useState([]);
	const [currentPagePublications, setCurrentPagePublications] = useState(1);
	const [currentPagePlans, setCurrentPagePlans] = useState(1);
	const [dateFilterRange, setDateFilterRange] = useState({ start: '', end: '' });
	const [totalPagesPublications, setTotalPagesPublications] = useState(1);
	const [totalPagesPlans, setTotalPagesPlans] = useState(1);
	const [searchQuery, setSearchQuery] = useState('');
	const [statusFilter, setStatusFilter] = useState('needs_review');
	const [loadingInitial, setLoadingInitial] = useState(true);
	const [openEditDialog, setOpenEditDialog] = useState(false);
	const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
	const [publicationToDelete, setPublicationToDelete] = useState(null);
	const [editPublication, setEditPublication] = useState(null);
	const [editTitle, setEditTitle] = useState('');
	const [editAuthors, setEditAuthors] = useState('');
	const [editYear, setEditYear] = useState('');
	const [editType, setEditType] = useState('article');
	const [editStatus, setEditStatus] = useState('needs_review');
	const [editFile, setEditFile] = useState(null);
	const [error, setError] = useState('');
	const [success, setSuccess] = useState('');
	const [openError, setOpenError] = useState(false);
	const [openSuccess, setOpenSuccess] = useState(false);
	const [newLastName, setNewLastName] = useState('');
	const [newFirstName, setNewFirstName] = useState('');
	const [newMiddleName, setNewMiddleName] = useState('');
	const [newUsername, setNewUsername] = useState('');
	const [newPassword, setNewPassword] = useState('');
	const [showPassword, setShowPassword] = useState(false);
	const [openReturnDialog, setOpenReturnDialog] = useState(false);
	const [selectedPlan, setSelectedPlan] = useState(null);
	const [returnComment, setReturnComment] = useState('');
	const [lastNameError, setLastNameError] = useState('');
	const [firstNameError, setFirstNameError] = useState('');
	const [middleNameError, setMiddleNameError] = useState('');
	const [openHistoryDrawer, setOpenHistoryDrawer] = useState(false);
	const [publicationsTransitionKey, setPublicationsTransitionKey] = useState(0);
	const [plansTransitionKey, setPlansTransitionKey] = useState(0);
	const [planActionHistory, setPlanActionHistory] = useState([]);
	const [planHistoryPage, setPlanHistoryPage] = useState(1);
	const [totalPlanHistoryPages, setTotalPlanHistoryPages] = useState(1);
	const [openPlanHistoryDrawer, setOpenPlanHistoryDrawer] = useState(false);
	const [planHistoryTransitionKey, setPlanHistoryTransitionKey] = useState(0);
	const [pubActionHistory, setPubActionHistory] = useState([]);
	const [pubHistoryPage, setPubHistoryPage] = useState(1);
	const [totalPubHistoryPages, setTotalPubHistoryPages] = useState(1);
	const [pubHistoryTransitionKey, setPubHistoryTransitionKey] = useState(0);
	const [selectedPublication, setSelectedPublication] = useState(null);

	// Эффект для автоматического закрытия уведомлений
	useEffect(() => {
		let errorTimer, successTimer;
		if (openError) errorTimer = setTimeout(() => setOpenError(false), 3000);
		if (openSuccess) successTimer = setTimeout(() => setOpenSuccess(false), 3000);
		return () => {
			if (errorTimer) clearTimeout(errorTimer);
			if (successTimer) clearTimeout(successTimer);
		};
	}, [openError, openSuccess]);

	// Валидация ФИО
	const validateNamePart = (value, fieldName) => {
		if (!value.trim()) return `${fieldName} обязательно для заполнения.`;
		if (!namePartRegex.test(value))
			return `${fieldName} должно начинаться с заглавной буквы, содержать только кириллицу и быть длиной не менее 2 символов.`;
		return '';
	};

	const validateFullName = (lastName, firstName, middleName) => {
		const fullName = `${lastName} ${firstName} ${middleName}`;
		if (!fullNameRegex.test(fullName))
			return 'ФИО должно быть в формате "Иванов Иван Иванович" (три слова с заглавной буквы, разделённые пробелами).';
		return '';
	};

	// Обработчики изменения полей ФИО
	const handleLastNameChange = (e) => {
		const value = e.target.value;
		setNewLastName(value);
		setLastNameError(validateNamePart(value, 'Фамилия'));
	};

	const handleFirstNameChange = (e) => {
		const value = e.target.value;
		setNewFirstName(value);
		setFirstNameError(validateNamePart(value, 'Имя'));
	};

	const handleMiddleNameChange = (e) => {
		const value = e.target.value;
		setNewMiddleName(value);
		setMiddleNameError(validateNamePart(value, 'Отчество'));
	};

	const fetchPlanActionHistory = async (page, startDate = '', endDate = '') => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/plan-action-history`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: {
					page,
					per_page: 10,
					start_date: startDate || undefined,
					end_date: endDate || undefined,
				},
			});
			setPlanActionHistory(response.data.history);
			setTotalPlanHistoryPages(response.data.pages);
			setPlanHistoryTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки истории действий с планами:', err);
			setError('Не удалось загрузить историю действий с планами.');
			setOpenError(true);
		}
	};

	const fetchPublications = async (page) => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/publications`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: {
					page,
					per_page: 10,
					search: searchQuery,
					status: ['needs_review', 'returned_for_revision', 'published'].join(','),
					sort_status: statusFilter,
				},
			});
			setPublications(response.data.publications);
			setTotalPagesPublications(response.data.pages);
			setPublicationsTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки публикаций:', err);
			setError('Не удалось загрузить публикации. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const fetchPlans = async (page) => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/plans/needs-review?page=${page}&per_page=10`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setPlans(response.data.plans);
			setTotalPagesPlans(response.data.pages);
			setPlansTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки планов:', err);
			setError('Не удалось загрузить планы. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const fetchPubActionHistory = async (page, startDate = '', endDate = '') => {
		try {
			const response = await axios.get('http://localhost:5000/admin_api/admin/publication-action-history', {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
				params: {
					page,
					per_page: 10,
					start_date: startDate || undefined,
					end_date: endDate || undefined,
				},
			});
			setPubActionHistory(response.data.history);
			setTotalPubHistoryPages(response.data.pages);
			setPubHistoryTransitionKey((prev) => prev + 1);
		} catch (err) {
			console.error('Ошибка загрузки истории действий с публикациями:', err);
			setError('Не удалось загрузить историю действий с публикациями.');
			setOpenError(true);
		}
	};

	// Инициализация данных
	useEffect(() => {
		if (!isAuthenticated || user.role !== 'manager') navigate('/login');
		setLoadingInitial(true);
		Promise.all([
			fetchPublications(currentPagePublications),
			fetchPlans(currentPagePlans),
			fetchPubActionHistory(pubHistoryPage, dateFilterRange.start, dateFilterRange.end),
			fetchPlanActionHistory(planHistoryPage, dateFilterRange.start, dateFilterRange.end),
		]).finally(() => setLoadingInitial(false));
	}, [isAuthenticated, user, navigate]);

	// Обновление истории публикаций
	useEffect(() => {
		fetchPubActionHistory(pubHistoryPage, dateFilterRange.start, dateFilterRange.end);
	}, [pubHistoryPage, dateFilterRange.start, dateFilterRange.end]);

	// Обновление публикаций
	useEffect(() => {
		fetchPublications(currentPagePublications);
	}, [currentPagePublications, searchQuery, statusFilter]);

	// Обновление планов
	useEffect(() => {
		fetchPlans(currentPagePlans);
	}, [currentPagePlans]);

	// Обработчики
	const handleTabChange = (event, newValue) => setValue(newValue);

	const handleSearchChange = (e) => {
		setSearchQuery(e.target.value);
		setCurrentPagePublications(1);
	};

	const handleOpenPlanHistoryDrawer = () => {
		setOpenPlanHistoryDrawer(true);
		fetchPlanActionHistory(planHistoryPage);
	};

	const handleClosePlanHistoryDrawer = () => setOpenPlanHistoryDrawer(false);

	const handlePlanHistoryPageChange = (event, value) => {
		setPlanHistoryPage(value);
		fetchPlanActionHistory(value, dateFilterRange.start, dateFilterRange.end);
	};

	const handleStatusFilterChange = (e) => {
		setStatusFilter(e.target.value);
		setCurrentPagePublications(1);
	};

	const handlePageChangePublications = (event, value) => setCurrentPagePublications(value);

	const handlePageChangePlans = (event, value) => setCurrentPagePlans(value);

	const handleHistoryPageChange = (event, value) => {
		setPubHistoryPage(value);
		fetchPubActionHistory(value, dateFilterRange.start, dateFilterRange.end);
	};

	const handleDownload = async (fileUrl, fileName) => {
		if (!fileUrl || typeof fileUrl !== 'string' || fileUrl.trim() === '') {
			setError('Некорректный URL файла. Обратитесь к администратору.');
			setOpenError(true);
			return;
		}
		const normalizedFileUrl = fileUrl.startsWith('/') ? fileUrl : `/${fileUrl}`;
		const fullUrl = `http://localhost:5000${normalizedFileUrl}`;
		try {
			const response = await axios.get(fullUrl, {
				responseType: 'blob',
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			const blob = new Blob([response.data]);
			const url = window.URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.href = url;
			link.download = fileName || normalizedFileUrl.split('/').pop();
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			window.URL.revokeObjectURL(url);
		} catch (err) {
			setError(err.response ? `Ошибка сервера: ${err.response.status}` : 'Не удалось скачать файл.');
			setOpenError(true);
		}
	};

	const handleEditClick = (publication) => {
		setEditPublication(publication);
		setEditTitle(publication.title);
		setEditAuthors(publication.authors);
		setEditYear(publication.year);
		setEditType(publication.type);
		setEditStatus(publication.status);
		setEditFile(null);
		setOpenEditDialog(true);
	};

	const handleEditCancel = () => {
		setOpenEditDialog(false);
		setEditPublication(null);
		setEditTitle('');
		setEditAuthors('');
		setEditYear('');
		setEditType('article');
		setEditStatus('needs_review');
		setEditFile(null);
		setError('');
		setSuccess('');
	};

	const handleEditSubmit = async (event) => {
		event.preventDefault();
		if (!editTitle.trim() || !editAuthors.trim() || !editYear || editYear < 1900 || editYear > new Date().getFullYear()) {
			setError('Проверьте поля: название, авторы и год должны быть заполнены корректно.');
			setOpenError(true);
			return;
		}
		const formData = new FormData();
		formData.append('title', editTitle);
		formData.append('authors', editAuthors);
		formData.append('year', editYear);
		formData.append('type', editType);
		formData.append('status', editStatus);
		if (editFile) formData.append('file', editFile);

		try {
			await axios.put(`http://localhost:5000/admin_api/admin/publications/${editPublication.id}`, formData, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken, 'Content-Type': 'multipart/form-data' },
			});
			setSuccess('Публикация успешно обновлена!');
			setOpenSuccess(true);
			fetchPublications(currentPagePublications);
			fetchPubActionHistory(pubHistoryPage);
			handleEditCancel();
		} catch (err) {
			setError('Не удалось обновить публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleDeletePlanClick = (publication) => {
		setPublicationToDelete(publication);
		setOpenDeleteDialog(true);
	};

	const handleDeletePlanConfirm = async () => {
		if (publicationToDelete) {
			try {
				await axios.delete(`http://localhost:5000/admin_api/admin/publications/${publicationToDelete.id}`, {
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				});
				setSuccess('Публикация успешно удалена!');
				setOpenSuccess(true);
				fetchPublications(currentPagePublications);
				fetchPubActionHistory(pubHistoryPage);
				setOpenDeleteDialog(false);
				setPublicationToDelete(null);
			} catch (err) {
				setError('Не удалось удалить публикацию. Попробуйте позже.');
				setOpenError(true);
			}
		}
	};

	const handleApprovePlan = async (plan) => {
		try {
			await axios.post(`http://localhost:5000/admin_api/admin/plans/${plan.id}/approve`, {}, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setSuccess('План утверждён!');
			setOpenSuccess(true);
			fetchPlans(currentPagePlans);
			fetchPlanActionHistory(planHistoryPage);
		} catch (err) {
			setError('Не удалось утвердить план. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleOpenReturnDialog = (plan) => {
		setSelectedPlan(plan);
		setReturnComment('');
		setOpenReturnDialog(true);
	};

	const handleReturnForRevision = async () => {
		if (!returnComment.trim()) {
			setError('Комментарий обязателен.');
			setOpenError(true);
			return;
		}
		try {
			await axios.post(
				`http://localhost:5000/admin_api/admin/plans/${selectedPlan.id}/return-for-revision`,
				{ comment: returnComment },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('План возвращён на доработку!');
			setOpenSuccess(true);
			fetchPlans(currentPagePlans);
			fetchPlanActionHistory(planHistoryPage);
			setOpenReturnDialog(false);
		} catch (err) {
			setError('Не удалось вернуть план. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleApprovePublication = async (pub) => {
		try {
			await axios.put(
				`http://localhost:5000/admin_api/admin/publications/${pub.id}`,
				{ status: 'published' },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('Публикация утверждена!');
			setOpenSuccess(true);
			fetchPublications(currentPagePublications);
			fetchPubActionHistory(pubHistoryPage);
		} catch (err) {
			setError('Не удалось утвердить публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleReturnPublicationForRevision = async (pubId, comment) => {
		try {
			await axios.put(
				`http://localhost:5000/admin_api/admin/publications/${pubId}`,
				{ status: 'returned_for_revision', return_comment: comment },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('Публикация возвращена на доработку!');
			setOpenSuccess(true);
			fetchPublications(currentPagePublications);
			fetchPubActionHistory(pubHistoryPage);
			setOpenReturnDialog(false);
		} catch (err) {
			setError('Не удалось вернуть публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleOpenHistoryDrawer = () => {
		setOpenHistoryDrawer(true);
		fetchPubActionHistory(pubHistoryPage);
	};

	const handleCloseHistoryDrawer = () => setOpenHistoryDrawer(false);

	return (
		<Container maxWidth="lg" sx={{ mt: 8, mb: 4 }}>
			<AppleCard elevation={4} sx={{ p: 4, borderRadius: '16px', backgroundColor: '#FFFFFF' }}>
				<Typography variant="h4" sx={{ color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
					Панель управляющего
				</Typography>
				<Tabs
					value={value}
					onChange={handleTabChange}
					centered
					sx={{
						mb: 4,
						'& .MuiTab-root': { color: '#6E6E73', fontWeight: 600 },
						'& .MuiTab-root.Mui-selected': { color: '#0071E3' },
						'& .MuiTabs-indicator': { backgroundColor: '#0071E3' },
					}}
				>
					<Tab label="Работы на проверке" />
					<Tab label="Статистика по кафедре" />
					<Tab label="Регистрация пользователей" />
					<Tab label="Работа с планами" />
				</Tabs>

				{loadingInitial ? (
					<Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
						<CircularProgress sx={{ color: '#0071E3' }} />
					</Box>
				) : (
					<>
						{value === 0 && (
							<>
								<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
									Работы на проверке
								</Typography>
								<AppleCard sx={{ mt: 2, mb: 2, p: 2, backgroundColor: '#F5F5F7', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<AppleTextField
										fullWidth
										label="Поиск по названию, авторам или году"
										value={searchQuery}
										onChange={handleSearchChange}
										margin="normal"
										variant="outlined"
									/>
									<Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 2 }}>
										<AppleTextField
											select
											label="Фильтр по статусу"
											value={statusFilter}
											onChange={handleStatusFilterChange}
											margin="normal"
											variant="outlined"
											sx={{ width: '200px' }}
										>
											<MenuItem value="needs_review">На проверке</MenuItem>
											<MenuItem value="returned_for_revision">Отправлено на доработку</MenuItem>
											<MenuItem value="published">Опубликовано</MenuItem>
										</AppleTextField>
										<AppleButton startIcon={<HistoryIcon />} onClick={handleOpenHistoryDrawer} sx={{ height: 'fit-content', marginTop: '6px' }}>
											Показать историю
										</AppleButton>
									</Box>
								</AppleCard>
								<AppleTable sx={{ mt: 2, boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<TableHead>
										<TableRow sx={{ backgroundColor: '#0071E3' }}>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', borderRadius: '12px 0 0 0' }}>ID</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Название</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Авторы</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Год</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Тип</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Статус</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Пользователь</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', textAlign: 'center', borderRadius: '0 12px 0 0' }}>
												Действия
											</TableCell>
										</TableRow>
									</TableHead>
									<Fade in={true} timeout={500} key={publicationsTransitionKey}>
										<TableBody>
											{publications.length > 0 ? (
												publications.map((pub) => (
													<TableRow
														key={pub.id}
														sx={{ '&:hover': { backgroundColor: '#F5F5F7', transition: 'background-color 0.3s ease' } }}
													>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.id}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															<Typography
																sx={{
																	color: '#0071E3',
																	textDecoration: 'underline',
																	cursor: 'pointer',
																	'&:hover': { textDecoration: 'none' },
																}}
																onClick={() => navigate(`/publication/${pub.id}`)}
															>
																{pub.title}
															</Typography>
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.authors}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.year}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															{pub.type === 'article'
																? 'Статья'
																: pub.type === 'monograph'
																	? 'Монография'
																	: pub.type === 'conference'
																		? 'Доклад/конференция'
																		: 'Неизвестный тип'}
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															<StatusChip status={pub.status} role={user.role} />
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.user?.full_name || 'Не указан'}</TableCell>
														<TableCell sx={{ textAlign: 'center' }}>
															<Box sx={{ display: 'flex', justifyContent: 'center', gap: 1 }}>
																{pub.file_url && pub.file_url.trim() !== '' && (
																	<IconButton
																		aria-label="download"
																		onClick={() => handleDownload(pub.file_url, pub.file_url.split('/').pop())}
																		sx={{
																			color: '#0071E3',
																			borderRadius: '8px',
																			'&:hover': { color: '#FFFFFF', backgroundColor: '#0071E3', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)' },
																		}}
																	>
																		<DownloadIcon />
																	</IconButton>
																)}
															</Box>
														</TableCell>
													</TableRow>
												))
											) : (
												<TableRow>
													<TableCell colSpan={8} sx={{ textAlign: 'center', color: '#6E6E73' }}>
														Нет публикаций с указанными статусами.
													</TableCell>
												</TableRow>
											)}
										</TableBody>
									</Fade>
								</AppleTable>
								<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
									<Pagination
										count={totalPagesPublications}
										page={currentPagePublications}
										onChange={handlePageChangePublications}
										color="primary"
										sx={{
											'& .MuiPaginationItem-root': {
												borderRadius: 20,
												transition: 'all 0.3s ease',
												'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
												'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
											},
										}}
									/>
								</Box>
								<Drawer
									anchor="right"
									open={openHistoryDrawer}
									onClose={handleCloseHistoryDrawer}
									sx={{
										'& .MuiDrawer-paper': {
											width: 600,
											backgroundColor: '#FFFFFF',
											boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
											borderRadius: '16px 0 0 16px',
										},
									}}
								>
									<Box sx={{ p: 2, pr: 4 }}>
										<Typography variant="h6" sx={{ color: '#1D1D1F', fontWeight: 600, mb: 5 }}>
											История действий с публикациями
										</Typography>
										<Box sx={{ display: 'flex', gap: 2, mt: 2, mb: 2 }}>
											<AppleTextField
												label="Дата начала"
												type="date"
												value={dateFilterRange.start}
												onChange={(e) => {
													setDateFilterRange((prev) => ({ ...prev, start: e.target.value }));
													setPubHistoryPage(1);
												}}
												InputLabelProps={{ shrink: true }}
												sx={{ width: '200px' }}
											/>
											<AppleTextField
												label="Дата окончания"
												type="date"
												value={dateFilterRange.end}
												onChange={(e) => {
													setDateFilterRange((prev) => ({ ...prev, end: e.target.value }));
													setPubHistoryPage(1);
												}}
												InputLabelProps={{ shrink: true }}
												sx={{ width: '200px' }}
											/>
										</Box>
										{pubActionHistory.length > 0 ? (
											<>
												<AppleTable
													sx={{
														mt: 2,
														overflowX: 'auto',
														minWidth: '100%',
														backgroundColor: '#F5F5F7',
														boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
														borderRadius: '8px',
													}}
												>
													<TableHead>
														<TableRow sx={{ backgroundColor: '#0071E3', borderRadius: '8px 8px 0 0' }}>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '200px', borderTopLeftRadius: '8px' }}>
																Название
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '120px' }}>
																Действие
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '140px', borderTopRightRadius: '8px' }}>
																Время
															</TableCell>
														</TableRow>
													</TableHead>
													<Fade in={true} timeout={500} key={pubHistoryTransitionKey}>
														<TableBody>
															{pubActionHistory.map((action) => (
																<TableRow key={`${action.id}-${action.timestamp}`}>
																	<TableCell sx={{ minWidth: '200px', whiteSpace: 'normal', wordWrap: 'break-word' }}>
																		<Typography
																			sx={{
																				color: '#0071E3',
																				textDecoration: 'underline',
																				cursor: 'pointer',
																				'&:hover': { textDecoration: 'none' },
																			}}
																			onClick={() => {
																				handleCloseHistoryDrawer();
																				navigate(`/publication/${action.id}`);
																			}}
																		>
																			{action.title}
																		</Typography>
																	</TableCell>
																	<TableCell sx={{ minWidth: '120px' }}>
																		{action.action_type === 'approved' ? 'Утверждено' : 'Возвращено на доработку'}
																	</TableCell>
																	<TableCell sx={{ minWidth: '140px' }}>
																		{new Date(action.timestamp).toLocaleString('ru-RU')}
																	</TableCell>
																</TableRow>
															))}
														</TableBody>
													</Fade>
												</AppleTable>
												<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
													<Pagination
														count={totalPubHistoryPages}
														page={pubHistoryPage}
														onChange={handleHistoryPageChange}
														color="primary"
														sx={{
															'& .MuiPaginationItem-root': {
																borderRadius: 20,
																'&:hover': { backgroundColor: 'grey.100' },
																'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
															},
														}}
													/>
												</Box>
											</>
										) : (
											<Typography sx={{ mt: 2, color: '#6E6E73' }}>
												Нет записей в истории действий с публикациями.
											</Typography>
										)}
									</Box>
								</Drawer>
							</>
						)}

						{value === 1 && (
							<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
								Статистика по кафедре
							</Typography>
						)}

						{value === 2 && (
							<>
								<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
									Регистрация нового пользователя
								</Typography>
								<AppleCard sx={{ maxWidth: 'none', mx: 'auto', mt: 2, p: 4 }}>
									<form onSubmit={(e) => e.preventDefault()}>
										<AppleTextField
											fullWidth
											label="Фамилия"
											value={newLastName}
											onChange={handleLastNameChange}
											margin="normal"
											variant="outlined"
											autoComplete="family-name"
											error={!!lastNameError}
											helperText={lastNameError}
										/>
										<AppleTextField
											fullWidth
											label="Имя"
											value={newFirstName}
											onChange={handleFirstNameChange}
											margin="normal"
											variant="outlined"
											autoComplete="given-name"
											error={!!firstNameError}
											helperText={firstNameError}
										/>
										<AppleTextField
											fullWidth
											label="Отчество"
											value={newMiddleName}
											onChange={handleMiddleNameChange}
											margin="normal"
											variant="outlined"
											autoComplete="additional-name"
											error={!!middleNameError}
											helperText={middleNameError}
										/>
										<AppleTextField
											fullWidth
											label="Логин"
											value={newUsername}
											onChange={(e) => setNewUsername(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="username"
										/>
										<AppleTextField
											fullWidth
											label="Пароль"
											type={showPassword ? 'text' : 'password'}
											value={newPassword}
											onChange={(e) => setNewPassword(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="new-password"
											InputProps={{
												endAdornment: (
													<IconButton onClick={() => setShowPassword(!showPassword)}>
														{showPassword ? <VisibilityOff /> : <Visibility />}
													</IconButton>
												),
											}}
										/>
										<Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
											<AppleButton
												startIcon={<RefreshIcon />}
												onClick={async () => {
													const lastNameErr = validateNamePart(newLastName, 'Фамилия');
													const firstNameErr = validateNamePart(newFirstName, 'Имя');
													const middleNameErr = validateNamePart(newMiddleName, 'Отчество');
													const fullNameErr = validateFullName(newLastName, newFirstName, newMiddleName);

													if (lastNameErr || firstNameErr || middleNameErr || fullNameErr) {
														setLastNameError(lastNameErr);
														setFirstNameError(firstNameErr);
														setMiddleNameError(middleNameErr);
														if (fullNameErr) {
															setError(fullNameErr);
															setOpenError(true);
														}
														return;
													}

													const generateUsername = async () => {
														const transliterate = (text) => {
															const ruToEn = {
																а: 'a', б: 'b', в: 'v', г: 'g', д: 'd',
																е: 'e', ё: 'e', ж: 'zh', з: 'z', и: 'i',
																й: 'y', к: 'k', л: 'l', м: 'm', н: 'n',
																о: 'o', п: 'p', р: 'r', с: 's', т: 't',
																у: 'u', ф: 'f', х: 'kh', ц: 'ts', ч: 'ch',
																ш: 'sh', щ: 'sch', ъ: '', ы: 'y', ь: '',
																э: 'e', ю: 'yu', я: 'ya'
															};
															return text.toLowerCase().split('').map(char => ruToEn[char] || char).join('');
														};
														const capitalizeFirstLetter = (string) =>
															string ? string.charAt(0).toUpperCase() + string.slice(1) : '';
														const baseUsername = `${capitalizeFirstLetter(transliterate(newLastName))}${capitalizeFirstLetter(transliterate(newFirstName[0]))}${capitalizeFirstLetter(transliterate(newMiddleName[0]))}`;
														let generatedUsername = baseUsername;
														let suffix = 1;

														while (true) {
															try {
																const response = await axios.post(
																	'http://localhost:5000/admin_api/admin/check-username',
																	{ username: generatedUsername },
																	{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
																);
																if (!response.data.exists) break;
																generatedUsername = `${baseUsername}${suffix}`;
																suffix++;
															} catch (err) {
																setError('Ошибка проверки логина.');
																setOpenError(true);
																return null;
															}
														}
														return generatedUsername;
													};

													const generatedUsername = await generateUsername();
													if (!generatedUsername) return;

													try {
														const response = await axios.get('http://localhost:5000/admin_api/admin/generate-password', {
															withCredentials: true,
															headers: { 'X-CSRFToken': csrfToken },
														});
														setNewUsername(generatedUsername);
														setNewPassword(response.data.password);
														setSuccess('Логин и пароль успешно сгенерированы.');
														setOpenSuccess(true);
													} catch (err) {
														setError('Ошибка генерации пароля.');
														setOpenError(true);
													}
												}}
											>
												Сгенерировать логин и пароль
											</AppleButton>
											<AppleButton
												startIcon={<ContentCopyIcon />}
												onClick={() => {
													navigator.clipboard.writeText(`Логин: ${newUsername}\nПароль: ${newPassword}`);
													setSuccess('Данные скопированы в буфер обмена!');
													setOpenSuccess(true);
												}}
											>
												Скопировать в буфер обмена
											</AppleButton>
											<AppleButton
												type="submit"
												onClick={async () => {
													const lastNameErr = validateNamePart(newLastName, 'Фамилия');
													const firstNameErr = validateNamePart(newFirstName, 'Имя');
													const middleNameErr = validateNamePart(newMiddleName, 'Отчество');
													const fullNameErr = validateFullName(newLastName, newFirstName, newMiddleName);

													if (lastNameErr || firstNameErr || middleNameErr || fullNameErr) {
														setLastNameError(lastNameErr);
														setFirstNameError(firstNameErr);
														setMiddleNameError(middleNameErr);
														if (fullNameErr) {
															setError(fullNameErr);
															setOpenError(true);
														}
														return;
													}

													if (!newUsername.trim() || !newPassword.trim()) {
														setError('Логин и пароль обязательны.');
														setOpenError(true);
														return;
													}

													try {
														await axios.post(
															'http://localhost:5000/admin_api/admin/register',
															{
																username: newUsername,
																password: newPassword,
																last_name: newLastName,
																first_name: newFirstName,
																middle_name: newMiddleName,
															},
															{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
														);
														setSuccess('Пользователь успешно зарегистрирован!');
														setOpenSuccess(true);
														setNewLastName('');
														setNewFirstName('');
														setNewMiddleName('');
														setNewUsername('');
														setNewPassword('');
														setLastNameError('');
														setFirstNameError('');
														setMiddleNameError('');
													} catch (err) {
														setError(err.response?.data?.error || 'Не удалось зарегистрировать пользователя.');
														setOpenError(true);
													}
												}}
											>
												Создать
											</AppleButton>
										</Box>
										<Collapse in={openError}>
											{error && (
												<Alert
													severity="error"
													sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#FFF1F0', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
													onClose={() => setOpenError(false)}
												>
													{error}
												</Alert>
											)}
										</Collapse>
										<Collapse in={openSuccess}>
											{success && (
												<Alert
													severity="success"
													sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#E7F8E7', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
													onClose={() => setOpenSuccess(false)}
												>
													{success}
												</Alert>
											)}
										</Collapse>
									</form>
								</AppleCard>
							</>
						)}

						{value === 3 && (
							<Box sx={{ mt: 4 }}>
								<Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', mb: 2, position: 'relative' }}>
									<Typography variant="h5" sx={{ color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
										Работа с планами
									</Typography>
									<AppleButton
										startIcon={<HistoryIcon />}
										onClick={handleOpenPlanHistoryDrawer}
										sx={{ position: 'absolute', right: 16 }}
									>
										Показать историю
									</AppleButton>
								</Box>
								{plans.length > 0 ? (
									plans.map((plan) => {
										const entriesByType = plan.entries.reduce((acc, entry) => {
											const type = entry.type || 'unknown';
											if (!acc[type]) {
												acc[type] = { count: 0, type };
											}
											acc[type].count += 1;
											return acc;
										}, {});
										const groupedEntries = Object.values(entriesByType);

										return (
											<Accordion
												key={plan.id}
												sx={{ mb: 2, borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}
											>
												<AccordionSummary expandIcon={<ExpandMoreIcon />}>
													<Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
														<Box>
															<Typography variant="h6" sx={{ color: '#1D1D1F', whiteSpace: 'nowrap' }}>
																План на {plan.year} год
															</Typography>
															<Typography variant="body2" sx={{ color: '#6E6E73', mt: 0.5 }}>
																{plan.user && plan.user.full_name
																	? `${plan.user.full_name} (${plan.user.username || 'логин отсутствует'})`
																	: 'Пользователь не указан'}
															</Typography>
														</Box>
														<StatusChip status={plan.status} role={user.role} />
													</Box>
												</AccordionSummary>
												<AccordionDetails>
													<PlanTable>
														<TableHead>
															<TableRow>
																<TableCell>Планируемое количество</TableCell>
																<TableCell>Тип</TableCell>
															</TableRow>
														</TableHead>
														<Fade in={true} timeout={500} key={plansTransitionKey}>
															<TableBody>
																{groupedEntries.length > 0 ? (
																	groupedEntries.map((group, index) => (
																		<TableRow key={index}>
																			<TableCell sx={{ padding: '16px' }}>{group.count}</TableCell>
																			<TableCell>
																				{group.type === 'article'
																					? 'Статья'
																					: group.type === 'monograph'
																						? 'Монография'
																						: group.type === 'conference'
																							? 'Доклад/конференция'
																							: 'Не указано'}
																			</TableCell>
																		</TableRow>
																	))
																) : (
																	<TableRow>
																		<TableCell colSpan={2} sx={{ textAlign: 'center', color: '#6E6E73' }}>
																			Нет записей в плане.
																		</TableCell>
																	</TableRow>
																)}
															</TableBody>
														</Fade>
													</PlanTable>
													{plan.return_comment && (
														<Typography
															sx={{ mt: 2, color: '#000000', fontWeight: 600, display: 'flex', alignItems: 'center', gap: 1 }}
														>
															<WarningAmberIcon sx={{ color: '#FF3B30' }} />
															Комментарий при возврате: {plan.return_comment}
														</Typography>
													)}
													{plan.status === 'needs_review' && (
														<Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
															<GreenButton startIcon={<CheckIcon />} onClick={() => handleApprovePlan(plan)}>
																Утвердить
															</GreenButton>
															<AppleButton startIcon={<ReplayIcon />} onClick={() => handleOpenReturnDialog(plan)}>
																На доработку
															</AppleButton>
														</Box>
													)}
												</AccordionDetails>
											</Accordion>
										);
									})
								) : (
									<Typography sx={{ textAlign: 'center', color: '#6E6E73', mt: 2 }}>
										Нет планов для проверки.
									</Typography>
								)}
								<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
									<Pagination
										count={totalPagesPlans}
										page={currentPagePlans}
										onChange={handlePageChangePlans}
										color="primary"
										sx={{
											'& .MuiPaginationItem-root': {
												borderRadius: 20,
												'&:hover': { backgroundColor: 'grey.100' },
												'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
											},
										}}
									/>
								</Box>
								<Drawer
									anchor="right"
									open={openPlanHistoryDrawer}
									onClose={handleClosePlanHistoryDrawer}
									sx={{
										'& .MuiDrawer-paper': {
											width: 600,
											backgroundColor: '#FFFFFF',
											boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
											borderRadius: '16px 0 0 16px',
										},
									}}
								>
									<Box sx={{ p: 2, pr: 4 }}>
										<Typography variant="h6" sx={{ color: '#1D1D1F', fontWeight: 600, mb: 5 }}>
											История действий с планами
										</Typography>
										<Box sx={{ display: 'flex', gap: 2, mt: 2, mb: 2 }}>
											<AppleTextField
												label="Дата начала"
												type="date"
												value={dateFilterRange.start}
												onChange={(e) => {
													setDateFilterRange((prev) => ({ ...prev, start: e.target.value }));
													setPlanHistoryPage(1);
												}}
												InputLabelProps={{ shrink: true }}
												sx={{ width: '200px' }}
											/>
											<AppleTextField
												label="Дата окончания"
												type="date"
												value={dateFilterRange.end}
												onChange={(e) => {
													setDateFilterRange((prev) => ({ ...prev, end: e.target.value }));
													setPlanHistoryPage(1);
												}}
												InputLabelProps={{ shrink: true }}
												sx={{ width: '200px' }}
											/>
										</Box>
										{planActionHistory.length > 0 ? (
											<>
												<AppleTable
													sx={{
														mt: 2,
														backgroundColor: '#F5F5F7',
														boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
														borderRadius: '8px',
													}}
												>
													<TableHead>
														<TableRow sx={{ backgroundColor: '#0071E3', borderRadius: '8px 8px 0 0' }}>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '150px', borderTopLeftRadius: '8px' }}>
																План
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '150px' }}>
																Пользователь
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '120px' }}>
																Действие
															</TableCell>
															<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', minWidth: '140px', borderTopRightRadius: '8px' }}>
																Время
															</TableCell>
														</TableRow>
													</TableHead>
													<Fade in={true} timeout={500} key={planHistoryTransitionKey}>
														<TableBody>
															{planActionHistory.map((action) => (
																<TableRow key={action.id}>
																	<TableCell sx={{ minWidth: '150px', whiteSpace: 'nowrap' }}>
																		<Typography
																			sx={{
																				color: '#0071E3',
																				textDecoration: 'underline',
																				cursor: 'pointer',
																				'&:hover': { textDecoration: 'none' },
																			}}
																			onClick={() => {
																				if (action.id) {
																					handleClosePlanHistoryDrawer();
																					// navigate(`/plan/${action.id}`); // Раскомментируйте, если есть страница плана
																				} else {
																					setError('ID плана отсутствует в записи истории.');
																					setOpenError(true);
																				}
																			}}
																		>
																			План на {action.year} год
																		</Typography>
																	</TableCell>
																	<TableCell sx={{ minWidth: '150px', whiteSpace: 'normal', wordWrap: 'break-word' }}>
																		{action.user_full_name}
																	</TableCell>
																	<TableCell sx={{ minWidth: '120px' }}>
																		{action.action_type === 'approved' ? 'Утверждён' : 'Возвращён на доработку'}
																	</TableCell>
																	<TableCell sx={{ minWidth: '140px' }}>
																		{new Date(action.timestamp).toLocaleString('ru-RU')}
																	</TableCell>
																</TableRow>
															))}
														</TableBody>
													</Fade>
												</AppleTable>
												<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
													<Pagination
														count={totalPlanHistoryPages}
														page={planHistoryPage}
														onChange={handlePlanHistoryPageChange}
														color="primary"
														sx={{
															'& .MuiPaginationItem-root': {
																borderRadius: 20,
																'&:hover': { backgroundColor: 'grey.100' },
																'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
															},
														}}
													/>
												</Box>
											</>
										) : (
											<Typography sx={{ mt: 2, color: '#6E6E73' }}>
												Нет записей в истории действий с планами.
											</Typography>
										)}
									</Box>
								</Drawer>
							</Box>
						)}

						<Dialog
							open={openDeleteDialog}
							onClose={() => {
								setOpenDeleteDialog(false);
								setPublicationToDelete(null);
							}}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Подтвердите удаление
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<Typography sx={{ color: '#6E6E73' }}>
									Вы уверены, что хотите удалить публикацию "{publicationToDelete?.title}"?
								</Typography>
							</DialogContent>
							<DialogActions sx={{ padding: '16px 24px', borderTop: '1px solid #E5E5EA' }}>
								<CancelButton
									onClick={() => {
										setOpenDeleteDialog(false);
										setPublicationToDelete(null);
									}}
								>
									Отмена
								</CancelButton>
								<AppleButton onClick={handleDeletePlanConfirm}>Удалить</AppleButton>
							</DialogActions>
						</Dialog>

						<Dialog
							open={openEditDialog}
							onClose={handleEditCancel}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Редактировать публикацию
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<form onSubmit={handleEditSubmit}>
									<AppleTextField
										fullWidth
										label="Название"
										value={editTitle}
										onChange={(e) => setEditTitle(e.target.value)}
										margin="normal"
										variant="outlined"
									/>
									<AppleTextField
										fullWidth
										label="Авторы"
										value={editAuthors}
										onChange={(e) => setEditAuthors(e.target.value)}
										margin="normal"
										variant="outlined"
									/>
									<AppleTextField
										fullWidth
										label="Год"
										type="number"
										value={editYear}
										onChange={(e) => setEditYear(e.target.value)}
										margin="normal"
										variant="outlined"
									/>
									<AppleTextField
										fullWidth
										select
										label="Тип публикации"
										value={editType}
										onChange={(e) => setEditType(e.target.value)}
										margin="normal"
										variant="outlined"
									>
										<MenuItem value="article">Статья</MenuItem>
										<MenuItem value="monograph">Монография</MenuItem>
										<MenuItem value="conference">Доклад/конференция</MenuItem>
									</AppleTextField>
									<AppleTextField
										fullWidth
										select
										label="Статус"
										value={editStatus}
										onChange={(e) => setEditStatus(e.target.value)}
										margin="normal"
										variant="outlined"
										disabled={!editPublication?.file_url && !editFile}
									>
										<MenuItem value="draft">Черновик</MenuItem>
										<MenuItem value="needs_review">Нуждается в проверке</MenuItem>
										<MenuItem value="published" disabled={!editPublication?.file_url && !editFile}>
											Опубликовано
										</MenuItem>
									</AppleTextField>
									<Box sx={{ mt: 2 }}>
										<Typography variant="body2" sx={{ color: '#6E6E73', mb: 1 }}>
											Текущий файл: {editPublication?.file_url || 'Нет файла'}
										</Typography>
										<input
											type="file"
											accept=".pdf,.docx"
											onChange={(e) => setEditFile(e.target.files[0])}
											style={{ display: 'none' }}
											id="edit-upload-file"
										/>
										<label htmlFor="edit-upload-file">
											<AppleButton sx={{ border: '1px solid #D1D1D6', backgroundColor: '#F5F5F7', color: '#1D1D1F' }} component="span">
												Выбрать файл
											</AppleButton>
										</label>
										{editFile && <Typography sx={{ mt: 1, color: '#6E6E73' }}>{editFile.name}</Typography>}
									</Box>
									<Collapse in={openError}>
										{error && (
											<Alert
												severity="error"
												sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#FFF1F0', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
												onClose={() => setOpenError(false)}
											>
												{error}
											</Alert>
										)}
									</Collapse>
									<Collapse in={openSuccess}>
										{success && (
											<Alert
												severity="success"
												sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#E7F8E7', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
												onClose={() => setOpenSuccess(false)}
											>
												{success}
											</Alert>
										)}
									</Collapse>
									<DialogActions sx={{ padding: '16px 0', borderTop: '1px solid #E5E5EA' }}>
										<CancelButton onClick={handleEditCancel}>Отмена</CancelButton>
										<AppleButton type="submit">Сохранить</AppleButton>
									</DialogActions>
								</form>
							</DialogContent>
						</Dialog>

						<Dialog
							open={openReturnDialog}
							onClose={() => setOpenReturnDialog(false)}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
									maxWidth: '400px',
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Вернуть на доработку
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<Typography sx={{ color: '#6E6E73', mb: 2 }}>
									Пожалуйста, укажите комментарий для пользователя:
								</Typography>
								<TextField
									autoFocus
									margin="dense"
									label="Комментарий"
									type="text"
									fullWidth
									multiline
									rows={3}
									value={returnComment}
									onChange={(e) => setReturnComment(e.target.value)}
									variant="outlined"
								/>
							</DialogContent>
							<DialogActions sx={{ padding: '16px 24px', borderTop: '1px solid #E5E5EA' }}>
								<CancelButton onClick={() => setOpenReturnDialog(false)}>Отмена</CancelButton>
								<AppleButton
									onClick={() => {
										if (selectedPublication) {
											handleReturnPublicationForRevision(selectedPublication, returnComment);
										} else if (selectedPlan) {
											handleReturnForRevision();
										}
									}}
								>
									Отправить
								</AppleButton>
							</DialogActions>
						</Dialog>

						{value !== 2 && (
							<>
								<Collapse in={openError}>
									{error && (
										<Alert
											severity="error"
											sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#FFF1F0', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
											onClose={() => setOpenError(false)}
										>
											{error}
										</Alert>
									)}
								</Collapse>
								<Collapse in={openSuccess}>
									{success && (
										<Alert
											severity="success"
											sx={{ mt: 2, borderRadius: '12px', backgroundColor: '#E7F8E7', color: '#1D1D1F', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}
											onClose={() => setOpenSuccess(false)}
										>
											{success}
										</Alert>
									)}
								</Collapse>
							</>
						)}
					</>
				)}
			</AppleCard>
		</Container>
	);
}

export default ManagerDashboard;
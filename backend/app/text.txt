D:\publication-system\backend\app\__init__.py
from flask import Flask, send_from_directory, make_response, request
from flask_cors import CORS
from .extensions import db, migrate, login_manager, csrf
from .models import User
import os
import logging
from flask_session import Session

# Настройка логирования
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def create_app():
    app = Flask(__name__)
    app.config.from_object('config.Config')

    # Устанавливаем секретный ключ
    app.secret_key = os.getenv("SECRET_KEY", "your-fixed-secret-key-here")

    # Настройка Flask-Session
    app.config['SESSION_TYPE'] = 'sqlalchemy'
    app.config['SESSION_SQLALCHEMY'] = db
    app.config['SESSION_PERMANENT'] = True
    app.config['PERMANENT_SESSION_LIFETIME'] = 60 * 60 * 24 * 7  # 7 дней
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    app.config['SESSION_COOKIE_SECURE'] = False  # Установите True в продакшене с HTTPS

    # Инициализация расширений
    db.init_app(app)
    migrate.init_app(app, db)
    login_manager.init_app(app)
    Session(app)
    csrf.init_app(app)

    # Настройка CORS
    allowed_origins = ["http://localhost:3000", "http://localhost:3001"]
    CORS(app, resources={r"/*": {"origins": allowed_origins}}, supports_credentials=True)
    # Обработка предварительных запросов
    @app.before_request
    def handle_preflight(
        if request.method == 'OPTIONS':
            response = make_response()
            response.headers['Access-Control-Allow-Origin'] = 'http://localhost:3001'
            response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, X-CSRFToken'
            response.headers['Access-Control-Allow-Credentials'] = 'true'
            response.headers['Access-Control-Max-Age'] = '86400'
            return response, 200

    # Регистрация Blueprint'ов
    from .routes import bp as user_bp
    app.register_blueprint(user_bp, url_prefix='/api')
    logger.debug("Зарегистрирован Blueprint 'api' с префиксом '/api'")

    from .api import bp as admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin_api')
    logger.debug("Зарегистрирован Blueprint 'admin_api' с префиксом '/admin_api'")

    # Обработчик для загрузки файлов
    @app.route('/uploads/<path:filename>')
    def download_file(filename):
        logger.debug(f"Отправка файла из /uploads/{filename}")
        return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

    with app.app_context():
        db.create_all()

    return app

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

		-------------------------
		D:\publication-system\backend\app\analytics.py
		from .extensions import db
from .models import Publication
from sqlalchemy import func

def get_publications_by_year(user_id=None):
    query = db.session.query(
        Publication.year, 
        func.count(Publication.id)
    ).group_by(Publication.year)
    if user_id:
        query = query.filter(Publication.user_id == user_id)
    # Сортируем результаты по году в порядке возрастания
    return query.order_by(Publication.year.asc()).all()
		---------
		D:\publication-system\backend\app\api.py
		from flask import Blueprint, jsonify, request, send_file
from werkzeug.utils import secure_filename
from flask_login import login_required, current_user
from flask import current_app
from app.extensions import db
from app.models import Publication, User, Plan, PlanEntry
import os
import logging
from io import BytesIO
import bibtexparser
from datetime import datetime

bp = Blueprint('admin_api', __name__, url_prefix='/admin_api')
logger = logging.getLogger(__name__)

def admin_or_manager_required(f):
    @login_required
    def wrapper(*args, **kwargs):
        if current_user.role not in ['admin', 'manager']:
            logger.warning(f"Unauthorized access attempt by user {current_user.id} with role {current_user.role}")
            return jsonify({"error": "Доступ запрещён. Требуется роль администратора или управляющего."}), 403
        return f(*args, **kwargs)
    wrapper.__name__ = f.__name__
    return wrapper

def admin_required(f):
    @login_required
    def wrapper(*args, **kwargs):
        if current_user.role != 'admin':
            logger.warning(f"Unauthorized access attempt by user {current_user.id} with role {current_user.role}")
            return jsonify({"error": "Доступ запрещён. Требуется роль администратора."}), 403
        return f(*args, **kwargs)
    wrapper.__name__ = f.__name__
    return wrapper

@bp.route('/admin/users', methods=['GET'])
@admin_required
def get_users():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)

    query = User.query
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (User.username.ilike(search_pattern)) |
            (User.last_name.ilike(search_pattern)) |
            (User.first_name.ilike(search_pattern)) |
            (User.middle_name.ilike(search_pattern))
        )

    paginated_users = query.paginate(page=page, per_page=per_page, error_out=False)
    users = [{
        'id': user.id,
        'username': user.username,
        'role': user.role,
        'last_name': user.last_name,
        'first_name': user.first_name,
        'middle_name': user.middle_name,
        'full_name': user.full_name,
    } for user in paginated_users.items]

    return jsonify({
        'users': users,
        'pages': paginated_users.pages,
        'total': paginated_users.total
    }), 200

@bp.route('/admin/users/<int:user_id>', methods=['PUT'])
@admin_required
def update_user(user_id):
    user = User.query.get_or_404(user_id)
    data = request.get_json()

    user.username = data.get('username', user.username)
    user.role = data.get('role', user.role)
    user.last_name = data.get('last_name', user.last_name)
    user.first_name = data.get('first_name', user.first_name)
    user.middle_name = data.get('middle_name', user.middle_name)

    if 'new_password' in data and data['new_password']:
        user.set_password(data['new_password'])

    try:
        db.session.commit()
        return jsonify({
            'message': 'Пользователь успешно обновлён',
            'user': {
                'id': user.id,
                'username': user.username,
                'role': user.role,
                'last_name': user.last_name,
                'first_name': user.first_name,
                'middle_name': user.middle_name
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при обновлении пользователя {user_id}: {str(e)}")
        return jsonify({"error": "Ошибка при обновлении пользователя. Попробуйте позже."}), 500

@bp.route('/admin/users/<int:user_id>', methods=['DELETE'])
@admin_required
def delete_user(user_id):
    user = User.query.get_or_404(user_id)

    if user.id == current_user.id:
        return jsonify({"error": "Нельзя удалить самого себя."}), 400

    try:
        db.session.delete(user)
        db.session.commit()
        return jsonify({"message": "Пользователь успешно удалён."}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при удалении пользователя {user_id}: {str(e)}")
        return jsonify({"error": "Ошибка при удалении пользователя. Попробуйте позже."}), 500

@bp.route('/admin/publications', methods=['GET'])
@admin_required
def get_publications():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)
    pub_type = request.args.get('type', 'all', type=str)
    status = request.args.get('status', 'all', type=str)

    query = Publication.query
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (Publication.title.ilike(search_pattern)) |
            (Publication.authors.ilike(search_pattern)) |
            (Publication.year.ilike(search_pattern))
        )

    if pub_type != 'all':
        query = query.filter_by(type=pub_type)
    if status != 'all':
        query = query.filter_by(status=status)

    paginated_publications = query.paginate(page=page, per_page=per_page, error_out=False)

    publications = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'user': {
            'id': pub.user.id if pub.user else None,
            'full_name': pub.user.full_name if pub.user else None
        },
        'returned_for_revision': pub.returned_for_revision,
        'published_at': pub.published_at.isoformat() if pub.published_at else None
    } for pub in paginated_publications.items]

    return jsonify({
        'publications': publications,
        'pages': paginated_publications.pages,
        'total': paginated_publications.total
    }), 200

@bp.route('/admin/publications/<int:pub_id>', methods=['PUT'])
@admin_or_manager_required
def update_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    if 'file' in request.files:
        file = request.files['file']
        if file and allowed_file(file.filename):
            if publication.file_url:
                old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                if os.path.exists(old_file_path):
                    os.remove(old_file_path)
            filename = secure_filename(file.filename)
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
            if os.path.exists(file_path):
                base, extension = os.path.splitext(filename)
                counter = 1
                while os.path.exists(file_path):
                    filename = f"{base}_{counter}{extension}"
                    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                    counter += 1
            try:
                file.save(file_path)
                publication.file_url = f"/uploads/{filename}"
            except Exception as e:
                logger.error(f"Ошибка при сохранении файла: {str(e)}")
                return jsonify({"error": "Ошибка при сохранении файла. Попробуйте снова."}), 500

    data = request.form if 'file' in request.files else request.get_json()
    publication.title = data.get('title', publication.title)
    publication.authors = data.get('authors', publication.authors)
    publication.year = int(data.get('year', publication.year))
    publication.type = data.get('type', publication.type)
    publication.status = data.get('status', publication.status)

    if publication.status == 'published' and not publication.published_at:
        publication.published_at = datetime.utcnow()

    try:
        db.session.commit()
        return jsonify({
            'message': 'Публикация успешно обновлена',
            'publication': {
                'id': publication.id,
                'title': publication.title,
                'authors': publication.authors,
                'year': publication.year,
                'type': publication.type,
                'status': publication.status,
                'file_url': publication.file_url,
                'published_at': publication.published_at.isoformat() if publication.published_at else None
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при обновлении публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при обновлении публикации. Попробуйте позже."}), 500

@bp.route('/admin/publications/<int:pub_id>', methods=['DELETE'])
@admin_or_manager_required
def delete_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    try:
        if publication.file_url:
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
            if os.path.exists(file_path):
                os.remove(file_path)

        db.session.delete(publication)
        db.session.commit()
        return jsonify({"message": "Публикация успешно удалена."}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при удалении публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при удалении публикации. Попробуйте позже."}), 500

@bp.route('/admin/publications/needs-review', methods=['GET'])
@admin_or_manager_required
def get_needs_review_publications():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '', type=str)

    query = Publication.query.filter_by(status='needs_review')
    if search:
        search_pattern = f'%{search}%'
        query = query.filter(
            (Publication.title.ilike(search_pattern)) |
            (Publication.authors.ilike(search_pattern)) |
            (Publication.year.ilike(search_pattern))
        )

    paginated_publications = query.paginate(page=page, per_page=per_page, error_out=False)

    publications = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'user': {
            'id': pub.user.id if pub.user else None,
            'full_name': pub.user.full_name if pub.user else None
        },
        'returned_for_revision': pub.returned_for_revision,
        'published_at': pub.published_at.isoformat() if pub.published_at else None
    } for pub in paginated_publications.items]

    return jsonify({
        'publications': publications,
        'pages': paginated_publications.pages,
        'total': paginated_publications.total
    }), 200 

@bp.route('/admin/register', methods=['POST'])
@admin_or_manager_required
def register():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    last_name = data.get('last_name')
    first_name = data.get('first_name')
    middle_name = data.get('middle_name')

    if not username or not password:
        return jsonify({"error": "Логин и пароль обязательны."}), 400

    existing_user = User.query.filter_by(username=username).first()
    if existing_user:
        return jsonify({"error": "Пользователь с таким логином уже существует."}), 400

    new_user = User(
        username=username,
        last_name=last_name,
        first_name=first_name,
        middle_name=middle_name,
    )
    new_user.set_password(password)

    try:
        db.session.add(new_user)
        db.session.commit()
        logger.debug(f"User registered successfully: {username}, response: {'Пользователь успешно зарегистрирован.'}")
        return jsonify({"message": "Пользователь успешно зарегистрирован."}), 201
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при регистрации пользователя {username}: {str(e)}")
        return jsonify({"error": "Ошибка при регистрации. Попробуйте позже."}), 500

@bp.route('/admin/check-username', methods=['POST'])
@admin_or_manager_required
def check_username():
    data = request.get_json()
    username = data.get('username')
    user = User.query.filter_by(username=username).first()
    return jsonify({'exists': user is not None})

@bp.route('/admin/generate-password', methods=['GET'])
@admin_or_manager_required
def generate_password():
    import secrets
    import string
    characters = string.ascii_letters + string.digits + string.punctuation
    password = ''.join(secrets.choice(characters) for _ in range(12))
    return jsonify({'password': password})

@bp.route('/admin/plans', methods=['GET'])
@admin_or_manager_required
def get_all_plans():
    logger.debug(f"Получен GET запрос для /admin_api/admin/plans")
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    pagination = Plan.query.order_by(Plan.year.desc()).paginate(page=page, per_page=per_page)
    plans = pagination.items
    return jsonify({
        'plans': [plan.to_dict() for plan in plans],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/admin/plans/<int:plan_id>', methods=['PUT'])
@admin_required
def update_plan(plan_id):
    logger.debug(f"Получен PUT запрос для /admin_api/admin/plans/{plan_id}")
    plan = Plan.query.get_or_404(plan_id)
    data = request.get_json()
    if not all(k in data for k in ('year', 'expectedCount', 'fillType', 'user_id', 'entries')):
        return jsonify({'error': 'Missing required fields'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Invalid year'}), 400
    
    if not isinstance(data['expectedCount'], int) or data['expectedCount'] < 1:
        return jsonify({'error': 'Expected count must be at least 1'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Invalid fill type'}), 400

    plan.year = data['year']
    plan.expectedCount = data['expectedCount']
    plan.fillType = data['fillType']
    plan.user_id = data['user_id']

    PlanEntry.query.filter_by(plan_id=plan.id).delete()
    for entry_data in data['entries']:
        entry = PlanEntry(
            title=entry_data.get('title'),
            type=entry_data.get('type'),
            publication_id=entry_data.get('publication_id'),
            status=entry_data.get('status', 'planned'),
            plan=plan
        )
        if entry.publication_id:
            publication = Publication.query.filter_by(id=entry.publication_id, user_id=plan.user_id, status='published').first()
            if not publication:
                db.session.rollback()
                return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
        db.session.add(entry)

    db.session.commit()
    return jsonify({'message': 'Plan updated successfully', 'plan': plan.to_dict()}), 200

@bp.route('/admin/plans/<int:plan_id>', methods=['DELETE'])
@admin_required
def delete_plan(plan_id):
    logger.debug(f"Получен DELETE запрос для /admin_api/admin/plans/{plan_id}")
    plan = Plan.query.get_or_404(plan_id)
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'Cannot delete plan that is under review or approved'}), 403
    
    db.session.delete(plan)
    db.session.commit()
    return jsonify({'message': 'Plan deleted successfully'}), 200

@bp.route('/admin/plans/<int:plan_id>/approve', methods=['POST'])
@admin_or_manager_required
def approve_plan(plan_id):
    logger.debug(f"Получен POST запрос для /admin_api/admin/plans/{plan_id}/approve")
    plan = Plan.query.get_or_404(plan_id)
    if plan.status != 'needs_review':
        return jsonify({'error': 'План не находится на проверке'}), 400

    plan.status = 'approved'
    db.session.commit()
    return jsonify({'message': 'План утверждён', 'plan': plan.to_dict()}), 200

@bp.route('/admin/plans/<int:plan_id>/return-for-revision', methods=['POST'])
@admin_or_manager_required
def return_plan_for_revision(plan_id):
    logger.debug(f"Получен POST запрос для /admin_api/admin/plans/{plan_id}/return-for-revision")
    plan = Plan.query.get_or_404(plan_id)
    if plan.status != 'needs_review':
        return jsonify({'error': 'План не находится на проверке'}), 400

    data = request.get_json()
    comment = data.get('comment', '').strip()
    if not comment:
        return jsonify({'error': 'Комментарий обязателен'}), 400

    plan.status = 'returned'
    plan.return_comment = comment
    db.session.commit()
    return jsonify({'message': 'План возвращён на доработку', 'plan': plan.to_dict()}), 200

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in {'pdf', 'docx'}

def get_publications_by_year(user_id):
    publications = Publication.query.filter_by(user_id=user_id).all()
    yearly_counts = {}
    for pub in publications:
        year = pub.year
        yearly_counts[year] = yearly_counts.get(year, 0) + 1
    return sorted(yearly_counts.items(), key=lambda x: x[0])


@bp.route('admin/plans/needs-review', methods=['GET'])
@login_required
def get_needs_review_plans():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    
    # Запрос планов со статусом 'needs_review'
    plans_query = Plan.query.filter_by(status='needs_review')
    pagination = plans_query.paginate(page=page, per_page=per_page, error_out=False)
    
    plans = [plan.to_dict() for plan in pagination.items]
    
    return jsonify({
        'plans': plans,
        'pages': pagination.pages,
        'total': pagination.total
    })
		-------------
		D:\publication-system\backend\app\extensions.py
		from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager
from flask_wtf.csrf import CSRFProtect  # Добавляем CSRFProtect

db = SQLAlchemy()
migrate = Migrate()
login_manager = LoginManager()
csrf = CSRFProtect()  # Инициализируем CSRFProtect
------------------
D:\publication-system\backend\app\middleware.py
from functools import wraps
from flask import jsonify
from flask_login import current_user
import logging

logging.basicConfig(level=logging.DEBUG)  # Установите уровень DEBUG для более детальных логов
logger = logging.getLogger(__name__)

def admin_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        logger.debug(f"Проверка прав доступа для пользователя: {current_user}")
        logger.debug(f"Роль пользователя: {current_user.role if current_user.is_authenticated else 'Not authenticated'}")
        if not current_user.is_authenticated or current_user.role != 'admin':
            logger.warning(f"Доступ запрещён для пользователя {current_user.username if current_user.is_authenticated else 'неавторизованного'}")
            return jsonify({"error": "Доступ запрещён. Требуется роль администратора."}), 403
        logger.debug(f"Доступ предоставлен для пользователя {current_user.username}")
        return f(*args, **kwargs)
    return decorated

		------------
		D:\publication-system\backend\app\models.py
		from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash
from .extensions import db
from flask_login import UserMixin

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    publication_id = db.Column(db.Integer, db.ForeignKey('publication.id'), nullable=False)
    parent_id = db.Column(db.Integer, db.ForeignKey('comment.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.utcnow(), nullable=False)

    user = db.relationship('User', backref='comments', lazy=True)
    publication = db.relationship('Publication', backref='comments', lazy=True)
    parent = db.relationship('Comment', remote_side=[id], backref='replies', lazy=True)

class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    publications = db.relationship('Publication', back_populates='user', lazy=True)
    password_hash = db.Column(db.Text)
    role = db.Column(db.String(20), default='user', nullable=False)  # 'user', 'admin', 'manager'
    last_name = db.Column(db.String(100), nullable=True)
    first_name = db.Column(db.String(100), nullable=True)
    middle_name = db.Column(db.String(100), nullable=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.utcnow(), nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    @property
    def full_name(self):
        return f"{self.last_name or ''} {self.first_name or ''} {self.middle_name or ''}".strip()
    
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
    
    def is_active(self):
        return True

    def is_authenticated(self):
        return True

    def is_anonymous(self):
        return False
    
    def get_id(self):
        return str(self.id)

class Publication(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    authors = db.Column(db.String(200), nullable=False)
    year = db.Column(db.Integer, nullable=False)
    type = db.Column(db.String(50), nullable=False)
    status = db.Column(db.String(50), nullable=False, default='draft')
    file_url = db.Column(db.String(200), nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='SET NULL'), nullable=True)
    updated_at = db.Column(db.DateTime, default=lambda: datetime.utcnow(), onupdate=lambda: datetime.utcnow(), nullable=False)
    returned_for_revision = db.Column(db.Boolean, default=False)
    published_at = db.Column(db.DateTime, nullable=True)

    user = db.relationship('User', back_populates='publications', lazy=True)
    plan_entries = db.relationship('PlanEntry', back_populates='publication', lazy=True)

    @property
    def type_ru(self):
        return {
            'article': 'Статья',
            'monograph': 'Монография',
            'conference': 'Доклад/конференция'
        }.get(self.type, self.type)

    @property
    def status_ru(self):
        return {
            'draft': 'Черновик',
            'needs_review': 'На проверке',
            'published': 'Опубликованные'
        }.get(self.status, self.status)

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'authors': self.authors,
            'year': self.year,
            'type': self.type,
            'status': self.status,
            'file_url': self.file_url,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'returned_for_revision': self.returned_for_revision,
            'published_at': self.published_at.isoformat() if self.published_at else None,
            'user': {
                'full_name': self.user.full_name if self.user else None
            } if self.user else None
        }

class Achievement(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    badge = db.Column(db.String(50))
    date_earned = db.Column(db.DateTime, default=lambda: datetime.utcnow(), nullable=False)

    user = db.relationship('User', backref='achievements', lazy=True)

    @staticmethod
    def check_achievements(user_id):
        user = User.query.get_or_404(user_id)
        pub_count = Publication.query.filter_by(user_id=user_id).count()

        achievements = [
            ('top_author', pub_count >= 10),
            ('10_publications', pub_count >= 10),
            ('50_publications', pub_count >= 50)
        ]

        for badge, condition in achievements:
            if condition and not Achievement.query.filter_by(user_id=user_id, badge=badge).first():
                new_achievement = Achievement(user_id=user_id, badge=badge)
                db.session.add(new_achievement)
        db.session.commit()

class Plan(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    year = db.Column(db.Integer, nullable=False)
    expectedCount = db.Column(db.Integer, nullable=False, default=1)
    fillType = db.Column(db.String(10), nullable=False, default='manual')  # 'manual' или 'link'
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    status = db.Column(db.String(20), nullable=False, default='draft')  # 'draft', 'needs_review', 'approved', 'returned'
    return_comment = db.Column(db.Text, nullable=True)  # Добавлено для комментариев при возврате

    user = db.relationship('User', backref='plans', lazy=True)
    entries = db.relationship('PlanEntry', back_populates='plan', lazy=True, cascade='all, delete-orphan')

    def to_dict(self):
        return {
            'id': self.id,
            'year': self.year,
            'expectedCount': self.expectedCount,
            'fillType': self.fillType,
            'status': self.status,
            'user': {
                'full_name': self.user.full_name if self.user else None,
                'username': self.user.username if self.user else None  # Добавляем username
            } if self.user else None,
            'entries': [entry.to_dict() for entry in self.entries],
            'return_comment': self.return_comment
        }

class PlanEntry(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    plan_id = db.Column(db.Integer, db.ForeignKey('plan.id'), nullable=False)
    title = db.Column(db.String(200), nullable=True)  # Для ручного заполнения
    type = db.Column(db.String(50), nullable=True)  # Для ручного заполнения
    publication_id = db.Column(db.Integer, db.ForeignKey('publication.id'), nullable=True)  # Для привязки
    status = db.Column(db.String(50), nullable=False, default='planned')  # 'planned', 'in_progress', 'completed'
    isPostApproval = db.Column(db.Boolean, nullable=False, default=False)  # Новое поле

    plan = db.relationship('Plan', back_populates='entries')
    publication = db.relationship('Publication', back_populates='plan_entries', lazy=True)

    def to_dict(self):
        from flask_login import current_user
        result = {
            'id': self.id,
            'title': self.title,
            'type': self.type,
            'publication_id': self.publication_id,
            'status': self.status,
            'isPostApproval': self.isPostApproval,  # Добавляем поле в ответ
            'publication': {
                'id': self.publication.id,
                'title': self.publication.title
            } if self.publication else None
        }
        if current_user.is_authenticated and current_user.role in ['admin', 'manager']:
            result['status'] = self.status
        return result
				---------------
				D:\publication-system\backend\app\routes.py
				from flask import Blueprint, jsonify, request, make_response, current_app, send_file
from .extensions import db, login_manager, csrf
from .models import User, Publication, Comment, Plan, PlanEntry
from .utils import allowed_file
from flask_login import login_user, current_user, logout_user, login_required
from werkzeug.utils import secure_filename
from flask_wtf.csrf import generate_csrf
import os
from .analytics import get_publications_by_year
import bibtexparser
from reportlab.platypus import SimpleDocTemplate, Paragraph
from reportlab.lib.pagesizes import letter
from bibtexparser.bibdatabase import BibDatabase
from bibtexparser.bwriter import BibTexWriter
import logging
from datetime import datetime, UTC
from werkzeug.security import generate_password_hash, check_password_hash

bp = Blueprint('api', __name__, url_prefix='/api')

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

@bp.route('/uploads/<path:filename>')
def download_file(filename):
    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
    logger.debug(f"Serving file from {file_path}")
    if not os.path.exists(file_path):
        logger.error(f"File not found: {file_path}")
        return jsonify({'error': 'Файл не найден'}), 404
    response = send_file(file_path, as_attachment=True)
    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

@bp.route('/publications/<int:pub_id>', methods=['GET'])
@login_required
def get_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)

    if publication.user_id != current_user.id and current_user.role not in ['admin', 'manager']:
        logger.warning(f"Unauthorized access attempt to publication {pub_id} by user {current_user.id} with role {current_user.role}")
        return jsonify({"error": "У вас нет прав для просмотра этой публикации."}), 403

    comments = Comment.query.filter_by(publication_id=pub_id, parent_id=None).order_by(Comment.created_at.asc()).all()
    
    def build_comment_tree(comment):
        return {
            'id': comment.id,
            'content': comment.content,
            'user': {'username': comment.user.username, 'full_name': comment.user.full_name, 'role': comment.user.role},
            'created_at': comment.created_at.isoformat(),
            'replies': [build_comment_tree(reply) for reply in comment.replies]
        }
    
    return jsonify({
        'id': publication.id,
        'title': publication.title,
        'authors': publication.authors,
        'year': publication.year,
        'type': publication.type,
        'status': publication.status,
        'file_url': publication.file_url if publication.file_url else None,
        'user': {
            'id': publication.user.id if publication.user else None,
            'full_name': publication.user.full_name if publication.user else None},
        'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
        'published_at': publication.published_at.isoformat() if publication.published_at else None,
        'returned_for_revision': publication.returned_for_revision,
        'comments': [build_comment_tree(comment) for comment in comments]
    }), 200

@bp.route('/publications/<int:pub_id>/comments', methods=['POST'])
@login_required
def add_comment(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    data = request.get_json()
    content = data.get('content')
    parent_id = data.get('parent_id')

    if not content:
        return jsonify({'error': 'Комментарий не может быть пустым'}), 400

    comment = Comment(
        content=content,
        user_id=current_user.id,
        publication_id=pub_id,
        parent_id=parent_id if parent_id else None
    )
    db.session.add(comment)
    db.session.commit()

    return jsonify({
        'message': 'Комментарий добавлен',
        'comment': {
            'id': comment.id,
            'content': comment.content,
            'user': {'username': current_user.username, 'full_name': current_user.full_name, 'role': current_user.role},
            'created_at': comment.created_at.isoformat(),
            'replies': []
        }
    }), 201

@bp.route('/publications/<int:pub_id>/submit-for-review', methods=['POST'])
@login_required
def submit_for_review(pub_id):
    publication = Publication.query.get_or_404(pub_id)
    
    if publication.user_id != current_user.id:
        return jsonify({'error': 'У вас нет прав на отправку этой публикации на проверку'}), 403

    if publication.status != 'draft':
        return jsonify({'error': 'Публикация уже отправлена на проверку или опубликована'}), 400

    if not publication.file_url:
        return jsonify({'error': 'Нельзя отправить на проверку публикацию без прикреплённого файла'}), 400

    publication.status = 'needs_review'
    publication.updated_at = datetime.utcnow()
    publication.returned_for_revision = False

    try:
        db.session.commit()
        return jsonify({'message': 'Публикация отправлена на проверку'}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка отправки на проверку публикации {pub_id}: {str(e)}")
        return jsonify({'error': 'Ошибка при отправке на проверку. Попробуйте позже.'}), 500

@bp.route('/publications/<int:pub_id>/publish', methods=['POST'])
@login_required
def publish_publication(pub_id):
    publication = Publication.query.get_or_404(pub_id)

    if current_user.role not in ['admin', 'manager']:
        logger.warning(f"Несанкционированная попытка опубликовать публикацию {pub_id} пользователем {current_user.id} с ролью {current_user.role}")
        return jsonify({"error": "У вас нет прав для публикации этой работы."}), 403

    if publication.status != 'needs_review':
        return jsonify({"error": "Публикация не находится на стадии проверки."}), 400

    if not publication.file_url:
        return jsonify({"error": "Нельзя опубликовать работу без прикреплённого файла."}), 400

    publication.status = 'published'
    publication.published_at = datetime.utcnow()
    publication.returned_for_revision = False

    try:
        db.session.commit()
        logger.debug(f"Публикация {pub_id} успешно опубликована пользователем {current_user.id}")
        return jsonify({
            'message': 'Публикация успешно опубликована',
            'publication': {
                'id': publication.id,
                'title': publication.title,
                'status': publication.status,
                'published_at': publication.published_at.isoformat()
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при публикации публикации {pub_id}: {str(e)}")
        return jsonify({"error": "Ошибка при публикации. Попробуйте позже."}), 500

@bp.route('/publications/<int:pub_id>/return-for-revision', methods=['POST'])
@login_required
def return_for_revision(pub_id):
    publication = Publication.query.get_or_404(pub_id)

    if current_user.role not in ['admin', 'manager']:
        logger.warning(f"Несанкционированная попытка вернуть публикацию {pub_id} на доработку пользователем {current_user.id} с ролью {current_user.role}")
        return jsonify({"error": "У вас нет прав для возврата этой работы на доработку."}), 403

    if publication.status != 'needs_review':
        return jsonify({"error": "Публикация не находится на стадии проверки."}), 400

    comments = Comment.query.filter_by(publication_id=pub_id).all()
    has_reviewer_comment = any(
        comment.user.role in ['admin', 'manager'] or any(reply.user.role in ['admin', 'manager'] for reply in comment.replies)
        for comment in comments
    )
    if not has_reviewer_comment:
        return jsonify({"error": "Необходимо добавить комментарий перед возвратом на доработку."}), 400

    publication.status = 'draft'
    publication.returned_for_revision = True
    publication.published_at = None

    try:
        db.session.commit()
        logger.debug(f"Публикация {pub_id} возвращена на доработку пользователем {current_user.id}")
        return jsonify({
            'message': 'Публикация отправлена на доработку',
            'publication': {
                'id': publication.id,
                'title': publication.title,
                'status': publication.status,
                'returned_for_revision': publication.returned_for_revision
            }
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка при возврате публикации {pub_id} на доработку: {str(e)}")
        return jsonify({"error": "Ошибка при возврате на доработку. Попробуйте позже."}), 500

@bp.route('/login', methods=['POST'])
@csrf.exempt
def login():
    logger.debug(f"Получен POST запрос для /login")
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    user = User.query.filter_by(username=username).first()
    if user and check_password_hash(user.password_hash, password):
        login_user(user, remember=True)
        return jsonify({
            'message': 'Успешная авторизация',
            'user': {
                'id': user.id,
                'username': user.username,
                'role': user.role,
                'last_name': user.last_name,
                'first_name': user.first_name,
                'middle_name': user.middle_name
            }
        }), 200
    return jsonify({'error': 'Неверное имя пользователя или пароль'}), 401

@bp.route('/csrf-token', methods=['GET'])
def get_csrf_token():
    logger.debug(f"Получен GET запрос для /api/csrf-token")
    token = generate_csrf()
    return jsonify({'csrf_token': token}), 200

@bp.route('/logout', methods=['POST'])
@login_required
def logout():
    logger.debug(f"Получен POST запрос для /logout")
    logout_user()
    response = jsonify({'message': 'Успешный выход'})
    response.set_cookie('session', '', expires=0)
    return response, 200

@bp.route('/user', methods=['GET', 'PUT'])
@login_required
def user():
    logger.debug(f"Получен {request.method} запрос для /user")
    logger.debug(f"Текущий пользователь: {current_user.id if current_user.is_authenticated else 'Не аутентифицирован'}")
    logger.debug(f"Куки сессии: {request.cookies.get('session')}")
    if request.method == 'GET':
        response_data = {
            'id': current_user.id,
            'username': current_user.username,
            'role': current_user.role,
            'last_name': current_user.last_name,
            'first_name': current_user.first_name,
            'middle_name': current_user.middle_name,
            'created_at': current_user.created_at.isoformat() if current_user.created_at else None
        }
        logger.debug(f"Ответ сервера для /api/user: {response_data}")
        return jsonify(response_data), 200
    elif request.method == 'PUT':
        data = request.get_json()
        current_user.last_name = data.get('last_name', current_user.last_name)
        current_user.first_name = data.get('first_name', current_user.first_name)
        current_user.middle_name = data.get('middle_name', current_user.middle_name)
        try:
            db.session.commit()
            return jsonify({
                'message': 'Данные пользователя успешно обновлены',
                'user': {
                    'id': current_user.id,
                    'username': current_user.username,
                    'role': current_user.role,
                    'last_name': current_user.last_name,
                    'first_name': current_user.first_name,
                    'middle_name': current_user.middle_name
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка обновления данных пользователя {current_user.id}: {str(e)}")
            return jsonify({"error": "Ошибка при обновлении данных. Попробуйте позже."}), 500

@bp.route('/user/password', methods=['PUT'])
@login_required
def change_password():
    logger.debug(f"Получен PUT запрос для /user/password")
    data = request.get_json()
    current_password = data.get('current_password')
    new_password = data.get('new_password')

    if not check_password_hash(current_user.password_hash, current_password):
        return jsonify({'error': 'Текущий пароль неверен'}), 401

    current_user.password_hash = generate_password_hash(new_password)
    try:
        db.session.commit()
        return jsonify({'message': 'Пароль успешно изменён'}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Ошибка изменения пароля для пользователя {current_user.id}: {str(e)}")
        return jsonify({"error": "Ошибка при изменении пароля. Попробуйте позже."}), 500

@bp.route('/public/publications', methods=['GET'])
def get_public_publications():
    logger.debug(f"Получен GET запрос для /api/public/publications")
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)

    query = Publication.query.filter_by(status='published').order_by(
        db.func.coalesce(Publication.published_at, Publication.updated_at).desc()
    )

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    publications = pagination.items

    logger.debug(f"Returning {len(publications)} published publications, sorted by published_at/updated_at: {[pub.published_at.isoformat() if pub.published_at else pub.updated_at.isoformat() for pub in publications]}")
    logger.debug(f"Total published publications: {pagination.total}, pages: {pagination.pages}, current page: {pagination.page}")

    response = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'updated_at': pub.updated_at.isoformat() if pub.updated_at else None,
        'published_at': pub.published_at.isoformat() if pub.published_at else None,
        'returned_for_revision': pub.returned_for_revision,
        'user': {
            'full_name': pub.user.full_name if pub.user else 'Не указан'
        } if pub.user else None
    } for pub in publications]

    return jsonify({
        'publications': response,
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/publications', methods=['GET'])
@login_required
def get_publications():
    logger.debug(f"Получен GET запрос для /publications")
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search = request.args.get('search', '').lower()
    pub_type = request.args.get('type', 'all')
    status = request.args.get('status', 'all')

    query = Publication.query.filter_by(user_id=current_user.id)

    total_records_before_filters = query.count()
    logger.debug(f"Total records before filters: {total_records_before_filters}")

    if search:
        query = query.filter(
            db.or_(
                Publication.title.ilike(f'%{search}%'),
                Publication.authors.ilike(f'%{search}%'),
                db.cast(Publication.year, db.String).ilike(f'%{search}%')
            )
        )

    total_records_after_search = query.count()
    logger.debug(f"Total records after search: {total_records_after_search}")

    if pub_type != 'all':
        query = query.filter(Publication.type == pub_type)

    total_records_after_type = query.count()
    logger.debug(f"Total records after type filter: {total_records_after_type}")

    if status != 'all':
        query = query.filter(Publication.status == status)

    total_records_after_status = query.count()
    logger.debug(f"Total records after status filter: {total_records_after_status}")

    query = query.order_by(Publication.updated_at.desc())

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    publications = pagination.items

    logger.debug(f"Publications on page {page}: {len(publications)}")

    response = [{
        'id': pub.id,
        'title': pub.title,
        'authors': pub.authors,
        'year': pub.year,
        'type': pub.type,
        'status': pub.status,
        'file_url': pub.file_url,
        'updated_at': pub.updated_at.isoformat() if pub.updated_at else None,
        'returned_for_revision': pub.returned_for_revision,
    } for pub in publications]

    return jsonify({
        'publications': response,
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': pagination.page
    }), 200

@bp.route('/publications/<int:pub_id>', methods=['PUT', 'DELETE'])
@login_required
def manage_publication(pub_id):
    logger.debug(f"Получен {request.method} запрос для /publications/{pub_id}")
    publication = Publication.query.get_or_404(pub_id)
    if publication.user_id != current_user.id:
        return jsonify({'error': 'У вас нет прав на управление этой публикацией'}), 403

    if publication.status == 'needs_review':
        return jsonify({'error': 'Нельзя редактировать публикацию, пока она на проверке'}), 403

    if request.method == 'PUT':
        if request.content_type == 'application/json':
            data = request.get_json()
        elif 'file' in request.files or request.content_type.startswith('multipart/form-data'):
            data = request.form
        else:
            return jsonify({"error": "Неподдерживаемый формат данных. Используйте application/json или multipart/form-data."}), 415

        old_status = publication.status

        if 'file' in request.files:
            file = request.files['file']
            if file and allowed_file(file.filename):
                if publication.file_url:
                    old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                    if os.path.exists(old_file_path):
                        os.remove(old_file_path)
                filename = secure_filename(file.filename)
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                if os.path.exists(file_path):
                    base, extension = os.path.splitext(filename)
                    counter = 1
                    while os.path.exists(file_path):
                        filename = f"{base}_{counter}{extension}"
                        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                        counter += 1
                file.save(file_path)
                publication.file_url = f"/uploads/{filename}"

        publication.title = data.get('title', publication.title)
        publication.authors = data.get('authors', publication.authors)
        publication.year = data.get('year', publication.year)
        publication.type = data.get('type', publication.type)
        new_status = data.get('status', publication.status)

        if new_status == 'published' and not publication.file_url:
            return jsonify({'error': 'Нельзя опубликовать работу без прикреплённого файла.'}), 400

        publication.status = new_status

        if publication.status == 'published' and old_status != 'published':
            publication.published_at = datetime.utcnow()

        try:
            db.session.commit()
            return jsonify({
                'message': 'Публикация успешно обновлена',
                'publication': {
                    'id': publication.id,
                    'title': publication.title,
                    'authors': publication.authors,
                    'year': publication.year,
                    'type': publication.type,
                    'status': publication.status,
                    'file_url': publication.file_url,
                    'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
                    'published_at': publication.published_at.isoformat() if publication.published_at else None,
                    'returned_for_revision': publication.returned_for_revision,
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка обновления публикации {pub_id}: {str(e)}")
            return jsonify({"error": "Ошибка при обновлении публикации. Попробуйте позже."}), 500

    elif request.method == 'DELETE':
        try:
            if publication.file_url:
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
                if os.path.exists(file_path):
                    os.remove(file_path)
            db.session.delete(publication)
            db.session.commit()
            return jsonify({'message': 'Публикация успешно удалена'}), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка удаления публикации {pub_id}: {str(e)}")
            return jsonify({"error": "Ошибка при удалении публикации. Попробуйте позже."}), 500

@bp.route('/publications/upload-file', methods=['POST'])
@login_required
def upload_file():
    logger.debug(f"Получен POST запрос для /publications/upload-file")
    if 'file' not in request.files:
        return jsonify({'error': 'Файл не предоставлен'}), 400

    file = request.files['file']
    if not file or not allowed_file(file.filename):
        return jsonify({'error': 'Недопустимый файл'}), 400

    title = request.form.get('title')
    authors = request.form.get('authors')
    year = request.form.get('year')
    type = request.form.get('type', 'article')
    
    if not title or not authors or not year:
        return jsonify({'error': 'Название, авторы и год обязательны'}), 400

    try:
        year = int(year)
        if year < 1900 or year > datetime.now().year:
            return jsonify({'error': 'Недопустимый год'}), 400
    except ValueError:
        return jsonify({'error': 'Год должен быть числом'}), 400

    filename = secure_filename(file.filename)
    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
    if os.path.exists(file_path):
        base, extension = os.path.splitext(filename)
        counter = 1
        while os.path.exists(file_path):
            filename = f"{base}_{counter}{extension}"
            file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
            counter += 1
    file.save(file_path)

    publication = Publication(
        title=title,
        authors=authors,
        year=year,
        type=type,
        status='draft',
        file_url=f"/uploads/{filename}",
        user_id=current_user.id,
        returned_for_revision=False,
    )

    db.session.add(publication)
    db.session.commit()

    return jsonify({
        'message': 'Публикация успешно загружена',
        'publication': {
            'id': publication.id,
            'title': publication.title,
            'authors': publication.authors,
            'year': publication.year,
            'type': publication.type,
            'status': publication.status,
            'file_url': publication.file_url,
            'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
            'returned_for_revision': publication.returned_for_revision,
        }
    }), 200

@bp.route('/publications/upload-bibtex', methods=['POST'])
@login_required
def upload_bibtex():
    logger.debug(f"Получен POST запрос для /publications/upload-bibtex")
    if 'file' not in request.files:
        return jsonify({'error': 'BibTeX файл не предоставлен'}), 400

    file = request.files['file']
    if file and file.filename.endswith('.bib'):
        try:
            content = file.read().decode('utf-8')
            bib_database = bibtexparser.loads(content)
            publications_added = 0

            for entry in bib_database.entries:
                title = entry.get('title', 'Без названия')
                authors = entry.get('author', 'Неизвестный автор')
                year = entry.get('year', datetime.now().year)
                try:
                    year = int(year)
                except (ValueError, TypeError):
                    year = datetime.now().year
                type = entry.get('entrytype', 'article')

                publication = Publication(
                    title=title,
                    authors=authors,
                    year=year,
                    type=type,
                    status='draft',
                    user_id=current_user.id,
                    returned_for_revision=False,
                )
                db.session.add(publication)
                publications_added += 1

            db.session.commit()
            return jsonify({'message': f'Обработано {publications_added} публикаций'}), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка обработки BibTeX: {str(e)}")
            return jsonify({'error': 'Ошибка при обработке BibTeX файла'}), 500
    return jsonify({'error': 'Недопустимый файл. Ожидается .bib'}), 400

@bp.route('/publications/<int:pub_id>/attach-file', methods=['POST'])
@login_required
def attach_file(pub_id):
    logger.debug(f"Получен POST запрос для /publications/{pub_id}/attach-file")
    publication = Publication.query.get_or_404(pub_id)
    if publication.user_id != current_user.id:
        return jsonify({'error': 'У вас нет прав на изменение этой публикации'}), 403

    if publication.status == 'needs_review':
        return jsonify({'error': 'Нельзя редактировать публикацию, пока она на проверке'}), 403

    if 'file' not in request.files:
        return jsonify({'error': 'Файл не предоставлен'}), 400

    file = request.files['file']
    if file and allowed_file(file.filename):
        if publication.file_url:
            old_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], publication.file_url.split('/')[-1])
            if os.path.exists(old_file_path):
                os.remove(old_file_path)
        filename = secure_filename(file.filename)
        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
        if os.path.exists(file_path):
            base, extension = os.path.splitext(filename)
            counter = 1
            while os.path.exists(file_path):
                filename = f"{base}_{counter}{extension}"
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                counter += 1
        file.save(file_path)
        publication.file_url = f"/uploads/{filename}"

        try:
            db.session.commit()
            return jsonify({
                'message': 'Файл успешно прикреплен',
                'publication': {
                    'id': publication.id,
                    'title': publication.title,
                    'authors': publication.authors,
                    'year': publication.year,
                    'type': publication.type,
                    'status': publication.status,
                    'file_url': publication.file_url,
                    'updated_at': publication.updated_at.isoformat() if publication.updated_at else None,
                    'returned_for_revision': publication.returned_for_revision,
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            logger.error(f"Ошибка прикрепления файла к публикации {pub_id}: {str(e)}")
            return jsonify({"error": "Ошибка при прикреплении файла. Попробуйте позже."}), 500
    return jsonify({'error': 'Недопустимый файл'}), 400

@bp.route('/publications/export-bibtex', methods=['GET'])
@login_required
def export_bibtex():
    logger.debug(f"Получен GET запрос для /publications/export-bibtex")
    try:
        logger.debug("Начинаем запрос публикаций для текущего пользователя")
        publications = Publication.query.filter_by(user_id=current_user.id).all()
        logger.debug(f"Найдено публикаций: {len(publications)}")

        bib_db = BibDatabase()
        bib_db.entries = [{
            'ENTRYTYPE': pub.type or 'article',
            'ID': f'pub{pub.id}',
            'title': pub.title or 'Без названия',
            'author': pub.authors or 'Неизвестный автор',
            'year': str(pub.year) if pub.year else str(datetime.now().year)
        } for pub in publications]

        writer = BibTexWriter()
        if not callable(writer.write):
            raise AttributeError("Метод write в BibTexWriter не является callable. Проверьте версию bibtexparser.")

        bibtex_str = writer.write(bib_db)
        
        response = make_response(bibtex_str)
        response.headers['Content-Disposition'] = 'attachment; filename=publications.bib'
        response.headers['Content-Type'] = 'application/x-bibtex'
        logger.debug("BibTeX успешно сгенерирован и отправлен")
        return response
    except ImportError as e:
        logger.error(f"Ошибка импорта bibtexparser: {str(e)}")
        return jsonify({'error': 'Ошибка импорта библиотеки bibtexparser. Установите или обновите bibtexparser (>=1.4.0).'}), 500
    except AttributeError as e:
        logger.error(f"Ошибка атрибута в bibtexparser: {str(e)}")
        return jsonify({'error': 'Ошибка в библиотеке bibtexparser. Проверьте установку и версию.'}), 500
    except Exception as e:
        logger.error(f"Ошибка экспорта BibTeX: {str(e)}")
        return jsonify({'error': f'Внутренняя ошибка сервера при экспорте BibTeX: {str(e)}'}), 500

@bp.route('/analytics/yearly', methods=['GET'])
@login_required
def get_analytics_yearly():
    logger.debug(f"Получен GET запрос для /analytics/yearly")
    analytics = get_publications_by_year(current_user.id)
    return jsonify([{
        'year': year,
        'count': count
    } for year, count in analytics]), 200

@bp.route('/plans', methods=['GET'])
@login_required
def get_plans():
    logger.debug(f"Получен GET запрос для /plans")
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    plans = Plan.query.filter_by(user_id=current_user.id).order_by(Plan.year.desc()).paginate(page=page, per_page=per_page)
    return jsonify({
        'plans': [plan.to_dict() for plan in plans.items],
        'total': plans.total,
        'pages': plans.pages,
        'current_page': plans.page
    })

@bp.route('/plans', methods=['POST'])
@login_required
def create_plan():
    logger.debug(f"Получен POST запрос для /plans")
    data = request.get_json()
    if not all(k in data for k in ('year', 'expectedCount', 'fillType', 'entries')):
        return jsonify({'error': 'Missing required fields'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Invalid year'}), 400
    
    if not isinstance(data['expectedCount'], int) or data['expectedCount'] < 1:
        return jsonify({'error': 'Expected count must be at least 1'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Invalid fill type'}), 400

    plan = Plan(
        year=data['year'],
        expectedCount=data['expectedCount'],
        fillType=data['fillType'],
        user_id=current_user.id,
        status='draft'
    )
    db.session.add(plan)

    for entry_data in data['entries']:
        entry = PlanEntry(
            title=entry_data.get('title'),
            type=entry_data.get('type'),
            publication_id=entry_data.get('publication_id'),
            status=entry_data.get('status', 'planned'),
            isPostApproval=False,
            plan=plan
        )
        if entry.publication_id:
            publication = Publication.query.filter_by(id=entry.publication_id, user_id=current_user.id, status='published').first()
            if not publication:
                db.session.rollback()
                return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
        db.session.add(entry)

    db.session.commit()
    return jsonify({'message': f'Plan created with ID {plan.id}', 'plan': plan.to_dict()}), 201

@bp.route('/plans/<int:plan_id>', methods=['PUT'])
@login_required
def update_plan(plan_id):
    logger.debug(f"Получен PUT запрос для /plans/{plan_id}")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    if plan.status not in ['draft', 'returned', 'approved']:
        return jsonify({'error': 'Cannot edit plan that is under review'}), 403

    data = request.get_json()
    if not all(k in data for k in ('year', 'expectedCount', 'fillType', 'entries')):
        return jsonify({'error': 'Missing required fields'}), 400
    
    if not isinstance(data['year'], int) or data['year'] < 1900 or data['year'] > 2100:
        return jsonify({'error': 'Invalid year'}), 400
    
    if data['fillType'] not in ['manual', 'link']:
        return jsonify({'error': 'Invalid fill type'}), 400

    if plan.status == 'approved':
        existing_entries = {entry.id: entry for entry in plan.entries}
        new_entries = []
        for entry_data in data['entries']:
            entry_id = entry_data.get('id')
            if entry_id and entry_id in existing_entries:
                entry = existing_entries[entry_id]
                entry.title = entry_data.get('title', entry.title)
                entry.type = entry_data.get('type', entry.type)
                entry.publication_id = entry_data.get('publication_id', entry.publication_id)
                entry.status = entry_data.get('status', entry.status)
                if entry.publication_id:
                    publication = Publication.query.filter_by(id=entry.publication_id, user_id=current_user.id, status='published').first()
                    if not publication:
                        db.session.rollback()
                        return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
            else:
                new_entry = PlanEntry(
                    title=entry_data.get('title', ''),
                    type=entry_data.get('type', 'article'),
                    publication_id=entry_data.get('publication_id'),
                    status=entry_data.get('status', 'planned'),
                    isPostApproval=True,
                    plan=plan
                )
                if new_entry.publication_id:
                    publication = Publication.query.filter_by(id=new_entry.publication_id, user_id=current_user.id, status='published').first()
                    if not publication:
                        db.session.rollback()
                        return jsonify({'error': f'Publication with ID {new_entry.publication_id} not found or not published'}), 404
                new_entries.append(new_entry)
                db.session.add(new_entry)
    else:
        plan.year = data['year']
        plan.fillType = data['fillType']
        PlanEntry.query.filter_by(plan_id=plan.id).delete()
        for entry_data in data['entries']:
            entry = PlanEntry(
                title=entry_data.get('title'),
                type=entry_data.get('type'),
                publication_id=entry_data.get('publication_id'),
                status=entry_data.get('status', 'planned'),
                isPostApproval=False,
                plan=plan
            )
            if entry.publication_id:
                publication = Publication.query.filter_by(id=entry.publication_id, user_id=current_user.id, status='published').first()
                if not publication:
                    db.session.rollback()
                    return jsonify({'error': f'Publication with ID {entry.publication_id} not found or not published'}), 404
            db.session.add(entry)

    db.session.commit()
    return jsonify({'message': 'Plan updated successfully', 'plan': plan.to_dict()}), 200

@bp.route('/plans/<int:plan_id>', methods=['DELETE'])
@login_required
def delete_plan(plan_id):
    logger.debug(f"Получен DELETE запрос для /plans/{plan_id}")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'Cannot delete plan that is under review or approved'}), 403

    db.session.delete(plan)
    db.session.commit()
    return jsonify({'message': 'Plan deleted successfully'}), 200

@bp.route('/plans/<int:plan_id>/submit-for-review', methods=['POST'])
@login_required
def submit_plan_for_review(plan_id):
    logger.debug(f"Получен POST запрос для /plans/{plan_id}/submit-for-review")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    if plan.status not in ['draft', 'returned']:
        return jsonify({'error': 'План уже отправлен на проверку или утверждён'}), 400
    
    if not all(entry.title and entry.title.strip() for entry in plan.entries):
        return jsonify({'error': 'Все записи плана должны иметь заполненные заголовки'}), 400

    plan.status = 'needs_review'
    db.session.commit()
    return jsonify({'message': 'План отправлен на проверку', 'plan': plan.to_dict()}), 200

@bp.route('/plans/<int:plan_id>/entries/<int:entry_id>/link', methods=['POST'])
@login_required
def link_publication_to_plan_entry(plan_id, entry_id):
    logger.debug(f"Получен POST запрос для /plans/{plan_id}/entries/{entry_id}/link")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    entry = PlanEntry.query.filter_by(id=entry_id, plan_id=plan_id).first()
    if not entry:
        return jsonify({'error': 'Entry not found'}), 404
    
    if plan.status != 'approved':
        return jsonify({'error': 'Can only link publications to approved plans'}), 403
    
    if entry.publication_id:
        return jsonify({'error': 'Entry already linked to a publication'}), 400

    data = request.get_json()
    publication_id = data.get('publication_id')
    if not publication_id:
        return jsonify({'error': 'Publication ID is required'}), 400

    publication = Publication.query.filter_by(id=publication_id, user_id=current_user.id, status='published').first()
    if not publication:
        return jsonify({'error': f'Publication with ID {publication_id} not found or not published'}), 404

    existing_link = PlanEntry.query.filter_by(publication_id=publication_id).first()
    if existing_link:
        return jsonify({'error': f'Publication with ID {publication_id} is already linked to another plan entry'}), 400

    entry.publication_id = publication_id
    entry.status = 'completed'
    db.session.commit()
    return jsonify({'message': 'Publication linked successfully', 'entry': entry.to_dict()}), 200

@bp.route('/plans/<int:plan_id>/entries/<int:entry_id>/unlink', methods=['POST'])
@login_required
def unlink_publication_from_plan_entry(plan_id, entry_id):
    logger.debug(f"Получен POST запрос для /plans/{plan_id}/entries/{entry_id}/unlink")
    plan = Plan.query.filter_by(id=plan_id, user_id=current_user.id).first()
    if not plan:
        return jsonify({'error': 'Plan not found or unauthorized'}), 404
    
    entry = PlanEntry.query.filter_by(id=entry_id, plan_id=plan_id).first()
    if not entry:
        return jsonify({'error': 'Entry not found'}), 404
    
    if plan.status != 'approved':
        return jsonify({'error': 'Can only unlink publications from approved plans'}), 403
    
    if not entry.publication_id:
        return jsonify({'error': 'No publication linked to this entry'}), 400

    entry.publication_id = None
    entry.status = 'planned'
    db.session.commit()
    return jsonify({'message': 'Publication unlinked successfully', 'entry': entry.to_dict()}), 200
		----------------
		D:\publication-system\backend\app\server.py
		from flask import Flask, request, send_file
from flask_cors import CORS
import os
import tempfile
from spire.doc import Document, FileFormat

app = Flask(__name__)
CORS(app)  # Разрешаем CORS для всех маршрутов

# Путь для временного хранения файлов
UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

@app.route('/convert', methods=['POST'])
def convert_docx_to_pdf():
    try:
        if 'file' not in request.files:
            return {"error": "No file part in the request"}, 400
        
        file = request.files['file']
        if file.filename == '':
            return {"error": "No selected file"}, 400
        
        if file and file.filename.lower().endswith('.docx'):
            with tempfile.TemporaryDirectory() as temp_dir:
                input_path = os.path.join(temp_dir, file.filename)
                output_path = os.path.join(temp_dir, "converted.pdf")
                
                file.save(input_path)

                document = Document()
                document.LoadFromFile(input_path)
                document.SaveToFile(output_path, FileFormat.PDF)
                document.Close()

                return send_file(
                    output_path,
                    as_attachment=True,
                    download_name='converted.pdf',
                    mimetype='application/pdf'
                )

        return {"error": "Invalid file format, only .docx is supported"}, 400

    except Exception as e:
        return {"error": f"Error converting file: {str(e)}"}, 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
		----------------------
		D:\publication-system\backend\app\utils.py
		from werkzeug.utils import secure_filename
import os

def allowed_file(filename, allowed_extensions=['pdf', 'docx', 'bib']):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in allowed_extensions

-----------------
D:\publication-system\backend\config.py
import os

class Config:
    SQLALCHEMY_DATABASE_URI = os.getenv(
        'DATABASE_URL',
        'postgresql://postgres:1111@localhost:5432/publication_db'
    )
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SECRET_KEY = os.getenv("SECRET_KEY", "your-unique-secret-key-here")	
    # Конфигурация для загрузки файлов
    UPLOAD_FOLDER = os.path.join(os.getcwd(), 'uploads')
    ALLOWED_EXTENSIONS = {'pdf', 'docx', 'bib'}  # Добавляем .bib

if not os.path.exists(Config.UPLOAD_FOLDER):
    os.makedirs(Config.UPLOAD_FOLDER)
		-----------------
		D:\publication-system\backend\requirements.txt
		alembic==1.14.1
bibtexparser==1.4.3
blinker==1.9.0
cachelib==0.13.0
chardet==5.2.0
click==8.1.8
colorama==0.4.6
Flask==3.1.0
Flask-Cors==5.0.0
Flask-Login==0.6.3
Flask-Migrate==4.1.0
Flask-Session==0.8.0
Flask-SQLAlchemy==3.1.1
Flask-WTF==1.2.2
greenlet==3.1.1
grep==0.3.2
itsdangerous==2.2.0
Jinja2==3.1.5
lxml==5.3.1
Mako==1.3.9
MarkupSafe==3.0.2
msgspec==0.19.0
pillow==11.1.0
plum-dispatch==1.7.4
psycopg2-binary==2.9.10
pyparsing==3.2.1
python-docx==1.1.2
reportlab==4.3.1
Spire.Doc==13.1.0
SQLAlchemy==2.0.38
typing_extensions==4.12.2
Werkzeug==3.1.3
WTForms==3.2.1

-------------
D:\publication-system\backend\run.py
from app import create_app

app = create_app()

if __name__ == "__main__":
    app.run(debug=True, host='0.0.0.0', port=5000)\
-----------------
D:\publication-system\frontend\src\components\AdminDashboard.js
import React, { useState, useEffect } from 'react';
import {
	Container,
	Typography,
	Tabs,
	Tab,
	Box,
	Table,
	TableHead,
	TableRow,
	TableCell,
	TableBody,
	Button,
	Collapse,
	Dialog,
	DialogTitle,
	DialogContent,
	DialogActions,
	TextField,
	IconButton,
	CircularProgress,
	Alert,
	Pagination,
	Fade,
} from '@mui/material';
import MenuItem from '@mui/material/MenuItem';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import DownloadIcon from '@mui/icons-material/Download';
import RefreshIcon from '@mui/icons-material/Refresh';
import Visibility from '@mui/icons-material/Visibility';
import VisibilityOff from '@mui/icons-material/VisibilityOff';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import axios from 'axios';
import { styled } from '@mui/system';

const AppleButton = styled(Button)(({ theme }) => ({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#0071E3',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': {
		backgroundColor: '#0066CC',
		boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
	},
	'&:disabled': {
		backgroundColor: '#D1D1D6',
		color: '#FFFFFF',
	},
}));

const AppleTextField = styled(TextField)(({ theme }) => ({
	'& .MuiOutlinedInput-root': {
		borderRadius: '12px',
		backgroundColor: '#F5F5F7',
		'& fieldset': {
			borderColor: '#D1D1D6',
		},
		'&:hover fieldset': {
			borderColor: '#0071E3',
		},
		'&.Mui-focused fieldset': {
			borderColor: '#0071E3',
		},
	},
	'& label': {
		color: '#6E6E73',
	},
	'& input': {
		color: '#1D1D1F',
	},
	'& .MuiSelect-select': {
		backgroundColor: '#F5F5F7',
	},
}));

const AppleTable = styled(Table)(({ theme }) => ({
	borderRadius: '16px',
	overflow: 'hidden',
	backgroundColor: '#FFFFFF',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
}));

const AppleCard = styled(Box)(({ theme }) => ({
	borderRadius: '16px',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	backgroundColor: '#F5F5F7',
	padding: '16px',
}));

const CancelButton = styled(Button)(({ theme }) => ({
	borderRadius: '12px',
	color: '#0071E3',
	textTransform: 'none',
	backgroundColor: 'transparent',
	'&:hover': {
		color: '#FFFFFF',
		backgroundColor: '#0071E3',
	},
}));

function AdminDashboard() {
	const [value, setValue] = useState(0);
	const [users, setUsers] = useState([]);
	const [publications, setPublications] = useState([]);
	const [currentPageUsers, setCurrentPageUsers] = useState(1);
	const [totalPagesUsers, setTotalPagesUsers] = useState(1);
	const [currentPagePublications, setCurrentPagePublications] = useState(1);
	const [totalPagesPublications, setTotalPagesPublications] = useState(1);
	const [loadingInitial, setLoadingInitial] = useState(true);
	const [searchQuery, setSearchQuery] = useState('');
	const [filterType, setFilterType] = useState('all');
	const [filterStatus, setFilterStatus] = useState('all');
	const [error, setError] = useState('');
	const [success, setSuccess] = useState('');
	const [openError, setOpenError] = useState(false);
	const [openSuccess, setOpenSuccess] = useState(false);
	const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
	const [userToDelete, setUserToDelete] = useState(null);
	const [publicationToDelete, setPublicationToDelete] = useState(null);
	const [editUser, setEditUser] = useState(null);
	const [editPublication, setEditPublication] = useState(null);
	const [editUsername, setEditUsername] = useState('');
	const [editRole, setEditRole] = useState('');
	const [editLastName, setEditLastName] = useState('');
	const [editFirstName, setEditFirstName] = useState('');
	const [editMiddleName, setEditMiddleName] = useState('');
	const [editNewPassword, setEditNewPassword] = useState('');
	const [showEditPassword, setShowEditPassword] = useState(false);
	const [editTitle, setEditTitle] = useState('');
	const [editAuthors, setEditAuthors] = useState('');
	const [editYear, setEditYear] = useState('');
	const [editType, setEditType] = useState('');
	const [editStatus, setEditStatus] = useState('');
	const [editFile, setEditFile] = useState(null);
	const [openEditDialog, setOpenEditDialog] = useState(false);
	const navigate = useNavigate();
	const { csrfToken } = useAuth();

	const [newUsername, setNewUsername] = useState('');
	const [newPassword, setNewPassword] = useState('');
	const [newLastName, setNewLastName] = useState('');
	const [newFirstName, setNewFirstName] = useState('');
	const [newMiddleName, setNewMiddleName] = useState('');
	const [showPassword, setShowPassword] = useState(false);

	useEffect(() => {
		const fetchData = async () => {
			setLoadingInitial(true);
			try {
				const usersResponse = await axios.get('http://localhost:5000/admin_api/admin/users', {
					withCredentials: true,
					params: { page: currentPageUsers, per_page: 10, search: searchQuery },
				});
				setUsers(usersResponse.data.users || []);
				setTotalPagesUsers(usersResponse.data.pages || 1);

				const publicationsResponse = await axios.get('http://localhost:5000/admin_api/admin/publications', {
					withCredentials: true,
					params: { page: currentPagePublications, per_page: 10, search: searchQuery, type: filterType, status: filterStatus },
				});
				setPublications(publicationsResponse.data.publications || []);
				setTotalPagesPublications(publicationsResponse.data.pages || 1);
			} catch (err) {
				setError('Ошибка загрузки данных. Попробуйте позже.');
				setOpenError(true);
			} finally {
				setLoadingInitial(false);
			}
		};

		fetchData();
	}, [currentPageUsers, currentPagePublications, searchQuery, filterType, filterStatus]);

	const handleTabChange = (event, newValue) => {
		setValue(newValue);
		setSearchQuery('');
		setFilterType('all');
		setFilterStatus('all');
		setCurrentPageUsers(1);
		setCurrentPagePublications(1);
	};

	const handlePageChangeUsers = (event, newPage) => {
		setCurrentPageUsers(newPage);
	};

	const handlePageChangePublications = (event, newPage) => {
		setCurrentPagePublications(newPage);
	};

	const handleSearchChange = async (e) => {
		setSearchQuery(e.target.value);
		setCurrentPageUsers(1);
		setCurrentPagePublications(1);
	};

	const handleFilterTypeChange = (e) => {
		setFilterType(e.target.value);
		setCurrentPagePublications(1);
	};

	const handleFilterStatusChange = (e) => {
		setFilterStatus(e.target.value);
		setCurrentPagePublications(1);
	};

	const handleDeleteClick = (type, item) => {
		if (type === 'user') {
			setUserToDelete(item);
		} else {
			setPublicationToDelete(item);
		}
		setOpenDeleteDialog(true);
	};

	const handleDeleteCancel = () => {
		setOpenDeleteDialog(false);
		setUserToDelete(null);
		setPublicationToDelete(null);
	};

	const handleDeleteConfirm = async () => {
		try {
			if (userToDelete) {
				await axios.delete(`http://localhost:5000/admin_api/admin/users/${userToDelete.id}`, {
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				});
				setUsers(users.filter((user) => user.id !== userToDelete.id));
				setSuccess('Пользователь успешно удалён.');
				setOpenSuccess(true);
			} else if (publicationToDelete) {
				await axios.delete(`http://localhost:5000/admin_api/admin/publications/${publicationToDelete.id}`, {
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				});
				setPublications(publications.filter((pub) => pub.id !== publicationToDelete.id));
				setSuccess('Публикация успешно удалена.');
				setOpenSuccess(true);
			}
		} catch (err) {
			setError('Ошибка при удалении. Попробуйте позже.');
			setOpenError(true);
		} finally {
			setOpenDeleteDialog(false);
			setUserToDelete(null);
			setPublicationToDelete(null);
		}
	};

	const handleEditClick = (type, item) => {
		if (type === 'user') {
			setEditUser(item);
			setEditUsername(item.username);
			setEditRole(item.role);
			setEditLastName(item.last_name);
			setEditFirstName(item.first_name);
			setEditMiddleName(item.middle_name || '');
			setEditNewPassword('');
			setShowEditPassword(false);
		} else {
			setEditPublication(item);
			setEditTitle(item.title);
			setEditAuthors(item.authors);
			setEditYear(item.year);
			setEditType(item.type);
			setEditStatus(item.status);
			setEditFile(null);
		}
		setOpenEditDialog(true);
	};

	const handleEditCancel = () => {
		setOpenEditDialog(false);
		setEditUser(null);
		setEditPublication(null);
		setEditUsername('');
		setEditRole('');
		setEditLastName('');
		setEditFirstName('');
		setEditMiddleName('');
		setEditNewPassword('');
		setShowEditPassword(false);
		setEditTitle('');
		setEditAuthors('');
		setEditYear('');
		setEditType('');
		setEditStatus('');
		setEditFile(null);
		setError('');
		setSuccess('');
		setOpenError(false);
		setOpenSuccess(false);
	};

	const handleEditSubmit = async (e) => {
		e.preventDefault();
		try {
			if (editUser) {
				const updatedUser = {
					username: editUsername,
					role: editRole,
					last_name: editLastName,
					first_name: editFirstName,
					middle_name: editMiddleName,
				};
				if (editNewPassword) {
					updatedUser.new_password = editNewPassword;
				}
				const response = await axios.put(`http://localhost:5000/admin_api/admin/users/${editUser.id}`, updatedUser, {
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				});
				setUsers(users.map((user) => (user.id === editUser.id ? response.data.user : user)));
				setSuccess('Пользователь успешно обновлён.');
				setOpenSuccess(true);
				setTimeout(() => handleEditCancel(), 2000);
			} else if (editPublication) {
				const formData = new FormData();
				formData.append('title', editTitle);
				formData.append('authors', editAuthors);
				formData.append('year', editYear);
				formData.append('type', editType);
				formData.append('status', editStatus);
				if (editFile) {
					formData.append('file', editFile);
				}

				const response = await axios.put(`http://localhost:5000/admin_api/admin/publications/${editPublication.id}`, formData, {
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken, 'Content-Type': 'multipart/form-data' },
				});
				setPublications(publications.map((pub) => (pub.id === editPublication.id ? response.data.publication : pub)));
				setSuccess('Публикация успешно обновлена.');
				setOpenSuccess(true);
				setTimeout(() => handleEditCancel(), 2000);
			}
		} catch (err) {
			setError(err.response?.data?.error || 'Ошибка при обновлении. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const generateUsername = async () => {
		if (!newLastName || !newFirstName || !newMiddleName) {
			setError('Для генерации логина необходимо заполнить ФИО.');
			setOpenError(true);
			return null;
		}

		const transliterate = (text) => {
			const ruToEn = {
				'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd',
				'е': 'e', 'ё': 'e', 'ж': 'zh', 'з': 'z', 'и': 'i',
				'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n',
				'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't',
				'у': 'u', 'ф': 'f', 'х': 'kh', 'ц': 'ts', 'ч': 'ch',
				'ш': 'sh', 'щ': 'sch', 'ъ': '', 'ы': 'y', 'ь': '',
				'э': 'e', 'ю': 'yu', 'я': 'ya'
			};
			return text.toLowerCase().split('').map(char => ruToEn[char] || char).join('');
		};

		const capitalizeFirstLetter = (string) => {
			if (!string) return '';
			return string.charAt(0).toUpperCase() + string.slice(1);
		};

		const baseUsername = `${capitalizeFirstLetter(transliterate(newLastName))}${capitalizeFirstLetter(transliterate(newFirstName[0]))}${capitalizeFirstLetter(transliterate(newMiddleName[0]))}`;
		let generatedUsername = baseUsername;
		let suffix = 1;

		while (true) {
			try {
				const response = await axios.post('http://localhost:5000/admin_api/admin/check-username', { username: generatedUsername }, {
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				});
				if (!response.data.exists) {
					break;
				}
				generatedUsername = `${baseUsername}${suffix}`;
				suffix++;
			} catch (err) {
				setError('Ошибка проверки логина. Попробуйте снова.');
				setOpenError(true);
				return null;
			}
		}

		return generatedUsername;
	};

	const generateCredentials = async () => {
		const generatedUsername = await generateUsername();
		if (!generatedUsername) return;

		try {
			const response = await axios.get('http://localhost:5000/admin_api/admin/generate-password', {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			const generatedPassword = response.data.password;

			setNewUsername(generatedUsername);
			setNewPassword(generatedPassword);
			setSuccess('Логин и пароль успешно сгенерированы.');
			setOpenSuccess(true);
		} catch (err) {
			setError('Ошибка генерации пароля. Попробуйте снова.');
			setOpenError(true);
		}
	};

	const handleCreateUser = async (e) => {
		e.preventDefault();
		if (!newUsername || !newPassword || !newLastName || !newFirstName || !newMiddleName) {
			setError('Все поля обязательны для заполнения.');
			setOpenError(true);
			return;
		}

		try {
			console.log('Sending registration request with data:', {
				username: newUsername,
				password: newPassword,
				last_name: newLastName,
				first_name: newFirstName,
				middle_name: newMiddleName,
			});
			const response = await axios.post('http://localhost:5000/admin_api/admin/register', {
				username: newUsername,
				password: newPassword,
				last_name: newLastName,
				first_name: newFirstName,
				middle_name: newMiddleName,
			}, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});

			console.log('Registration response:', response.data, response.status);
			if (response.status === 201 && response.data.message && response.data.message.includes('успешно зарегистрирован')) {
				console.log('Setting success state...');
				setSuccess('Пользователь успешно создан.');
				setOpenSuccess(true);
				setNewUsername('');
				setNewPassword('');
				setNewLastName('');
				setNewFirstName('');
				setNewMiddleName('');
				const usersResponse = await axios.get('http://localhost:5000/admin_api/admin/users', {
					withCredentials: true,
					params: { page: currentPageUsers, per_page: 10, search: searchQuery },
				});
				setUsers(usersResponse.data.users || []);
				setTotalPagesUsers(usersResponse.data.pages || 1);
			}
		} catch (err) {
			console.error('Registration error:', err.response?.data || err.message, err.response?.status);
			setError(err.response?.data?.error || 'Ошибка при создании пользователя. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleTogglePasswordVisibility = () => {
		setShowPassword(!showPassword);
	};

	const handleToggleEditPasswordVisibility = () => {
		setShowEditPassword(!showEditPassword);
	};

	const handleCopyToClipboard = () => {
		const dataToCopy = `Фамилия: ${newLastName}, Имя: ${newFirstName}, Отчество: ${newMiddleName}, Логин: ${newUsername}, Пароль: ${newPassword}`;
		navigator.clipboard.writeText(dataToCopy)
			.then(() => {
				setSuccess('Данные скопированы в буфер обмена.');
				setOpenSuccess(true);
			})
			.catch(() => {
				setError('Ошибка при копировании данных.');
				setOpenError(true);
			});
	};

	const renderStatus = (status) => {
		let statusText = '';
		switch (status) {
			case 'draft':
				statusText = 'Черновик';
				break;
			case 'needs_review':
				statusText = 'Нуждается в проверке';
				break;
			case 'published':
				statusText = 'Опубликованные';
				break;
			default:
				statusText = status;
		}
		return <Typography variant="body2" sx={{ color: '#1D1D1F' }}>{statusText}</Typography>;
	};

	return (
		<Container maxWidth="lg" sx={{ mt: 8, mb: 4 }}>
			<AppleCard sx={{ p: 4, backgroundColor: '#FFFFFF', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
				<Typography variant="h4" gutterBottom sx={{ color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
					Панель администратора
				</Typography>
				<Tabs
					value={value}
					onChange={handleTabChange}
					centered
					sx={{
						mb: 4,
						'& .MuiTab-root': { color: '#6E6E73', fontWeight: 600 },
						'& .MuiTab-root.Mui-selected': { color: '#0071E3' },
						'& .MuiTabs-indicator': { backgroundColor: '#0071E3' },
					}}
				>
					<Tab label="Пользователи" />
					<Tab label="Все публикации" />
				</Tabs>

				{loadingInitial ? (
					<Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
						<CircularProgress sx={{ color: '#0071E3' }} />
					</Box>
				) : (
					<>
						{value === 0 && (
							<>
								<Typography
									variant="h5"
									gutterBottom
									sx={{
										mt: 4,
										color: '#1D1D1F',
										fontWeight: 600,
										textAlign: 'center',
									}}
								>
									Создание нового пользователя
								</Typography>
								<AppleCard sx={{ mb: 4, p: 3, backgroundColor: '#F5F5F7', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<form onSubmit={handleCreateUser}>
										<AppleTextField
											fullWidth
											label="Фамилия"
											value={newLastName}
											onChange={(e) => setNewLastName(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="family-name"
										/>
										<AppleTextField
											fullWidth
											label="Имя"
											value={newFirstName}
											onChange={(e) => setNewFirstName(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="given-name"
										/>
										<AppleTextField
											fullWidth
											label="Отчество"
											value={newMiddleName}
											onChange={(e) => setNewMiddleName(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="additional-name"
										/>
										<AppleTextField
											fullWidth
											label="Логин"
											value={newUsername}
											onChange={(e) => setNewUsername(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="username"
										/>
										<AppleTextField
											fullWidth
											label="Пароль"
											type={showPassword ? 'text' : 'password'}
											value={newPassword}
											onChange={(e) => setNewPassword(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="new-password"
											InputProps={{
												endAdornment: (
													<IconButton onClick={handleTogglePasswordVisibility}>
														{showPassword ? <VisibilityOff /> : <Visibility />}
													</IconButton>
												),
											}}
										/>
										<Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
											<AppleButton startIcon={<RefreshIcon />} onClick={generateCredentials}>
												Сгенерировать логин и пароль
											</AppleButton>
											<AppleButton startIcon={<ContentCopyIcon />} onClick={handleCopyToClipboard}>
												Скопировать в буфер обмена
											</AppleButton>
											<AppleButton type="submit">Создать</AppleButton>
										</Box>
										<Collapse in={openError}>
											{error && (
												<Alert
													severity="error"
													sx={{
														mt: 2,
														borderRadius: '12px',
														backgroundColor: '#FFF1F0',
														color: '#1D1D1F',
														boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
													}}
													onClose={() => setOpenError(false)}
												>
													{error}
												</Alert>
											)}
										</Collapse>
										<Collapse in={openSuccess}>
											{success && (
												<Alert
													severity="success"
													sx={{
														mt: 2,
														borderRadius: '12px',
														backgroundColor: '#E7F8E7',
														color: '#1D1D1F',
														boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
													}}
													onClose={() => setOpenSuccess(false)}
												>
													{success}
												</Alert>
											)}
										</Collapse>
									</form>
								</AppleCard>

								<Typography
									variant="h5"
									gutterBottom
									sx={{
										mt: 4,
										color: '#1D1D1F',
										fontWeight: 600,
										textAlign: 'center',
									}}
								>
									Управление пользователями
								</Typography>
								<AppleCard sx={{ mt: 2, mb: 2, p: 2, backgroundColor: '#F5F5F7', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<AppleTextField
										fullWidth
										label="Поиск по логину или ФИО"
										value={searchQuery}
										onChange={handleSearchChange}
										margin="normal"
										variant="outlined"
										InputProps={{
											endAdornment: <IconButton sx={{ color: '#0071E3' }}>{/* Можно добавить иконку поиска */}</IconButton>,
										}}
									/>
								</AppleCard>
								<AppleTable sx={{ mt: 2, boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<TableHead>
										<TableRow sx={{ backgroundColor: '#0071E3' }}>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', borderRadius: '12px 0 0 0' }}>ID</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Логин</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Роль</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Фамилия</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Имя</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Отчество</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', textAlign: 'center', borderRadius: '0 12px 0 0' }}>
												Действия
											</TableCell>
										</TableRow>
									</TableHead>
									<Fade in={true} timeout={500}>
										<TableBody>
											{users.length > 0 ? (
												users.map((user) => (
													<TableRow
														key={user.id}
														sx={{
															'&:hover': { backgroundColor: '#F5F5F7', transition: 'background-color 0.3s ease' },
														}}
													>
														<TableCell sx={{ color: '#1D1D1F' }}>{user.id}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{user.username}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{user.role}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{user.last_name}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{user.first_name}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{user.middle_name || '-'}</TableCell>
														<TableCell sx={{ textAlign: 'center' }}>
															<Box sx={{ display: 'flex', justifyContent: 'center', gap: 1 }}>
																<IconButton
																	aria-label="edit"
																	onClick={() => handleEditClick('user', user)}
																	sx={{
																		color: '#0071E3',
																		borderRadius: '8px',
																		'&:hover': {
																			color: '#FFFFFF',
																			backgroundColor: '#0071E3',
																			boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																		},
																	}}
																>
																	<EditIcon />
																</IconButton>
																<IconButton
																	aria-label="delete"
																	onClick={() => handleDeleteClick('user', user)}
																	sx={{
																		color: '#0071E3',
																		borderRadius: '8px',
																		'&:hover': {
																			color: '#FFFFFF',
																			backgroundColor: '#0071E3',
																			boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																		},
																	}}
																>
																	<DeleteIcon />
																</IconButton>
															</Box>
														</TableCell>
													</TableRow>
												))
											) : (
												<TableRow>
													<TableCell colSpan={7} sx={{ textAlign: 'center', color: '#6E6E73' }}>
														Нет пользователей.
													</TableCell>
												</TableRow>
											)}
										</TableBody>
									</Fade>
								</AppleTable>
								<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
									<Pagination
										count={totalPagesUsers}
										page={currentPageUsers}
										onChange={handlePageChangeUsers}
										color="primary"
										sx={{
											'& .MuiPaginationItem-root': {
												borderRadius: 20,
												transition: 'all 0.3s ease',
												'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
												'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
											},
										}}
									/>
								</Box>
							</>
						)}

						{value === 1 && (
							<>
								<Typography
									variant="h5"
									gutterBottom
									sx={{
										mt: 4,
										color: '#1D1D1F',
										fontWeight: 600,
										textAlign: 'center',
									}}
								>
									Управление всеми публикациями
								</Typography>
								<AppleCard sx={{ mt: 2, mb: 2, p: 2, backgroundColor: '#F5F5F7', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<AppleTextField
										fullWidth
										label="Поиск по названию, авторам или году"
										value={searchQuery}
										onChange={handleSearchChange}
										margin="normal"
										variant="outlined"
										InputProps={{
											endAdornment: <IconButton sx={{ color: '#0071E3' }}>{/* Можно добавить иконку поиска */}</IconButton>,
										}}
									/>
									<Box sx={{ mt: 2, display: 'flex', gap: 2 }}>
										<AppleTextField
											select
											label="Тип публикации"
											value={filterType}
											onChange={handleFilterTypeChange}
											margin="normal"
											variant="outlined"
										>
											<MenuItem value="all">Все</MenuItem>
											<MenuItem value="article">Статья</MenuItem>
											<MenuItem value="monograph">Монография</MenuItem>
											<MenuItem value="conference">Доклад/конференция</MenuItem>
										</AppleTextField>
										<AppleTextField
											select
											label="Статус"
											value={filterStatus}
											onChange={handleFilterStatusChange}
											margin="normal"
											variant="outlined"
										>
											<MenuItem value="all">Все</MenuItem>
											<MenuItem value="draft">Черновик</MenuItem>
											<MenuItem value="needs_review">Нуждается в проверке</MenuItem>
											<MenuItem value="published">Опубликованные</MenuItem>
										</AppleTextField>
									</Box>
								</AppleCard>
								<AppleTable sx={{ mt: 2, boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<TableHead>
										<TableRow sx={{ backgroundColor: '#0071E3' }}>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', borderRadius: '12px 0 0 0' }}>ID</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Название</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Авторы</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Год</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Тип</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Статус</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Пользователь</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', textAlign: 'center', borderRadius: '0 12px 0 0' }}>
												Действия
											</TableCell>
										</TableRow>
									</TableHead>
									<Fade in={true} timeout={500}>
										<TableBody>
											{publications.length > 0 ? (
												publications.map((pub) => (
													<TableRow
														key={pub.id}
														sx={{
															'&:hover': { backgroundColor: '#F5F5F7', transition: 'background-color 0.3s ease' },
														}}
													>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.id}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															<Typography
																sx={{
																	color: '#0071E3',
																	textDecoration: 'underline',
																	cursor: 'pointer',
																	'&:hover': { textDecoration: 'none' },
																}}
																onClick={() => navigate(`/publication/${pub.id}`)}
															>
																{pub.title}
															</Typography>
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.authors}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.year}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															{pub.type === 'article'
																? 'Статья'
																: pub.type === 'monograph'
																	? 'Монография'
																	: pub.type === 'conference'
																		? 'Доклад/конференция'
																		: 'Неизвестный тип'}
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															{renderStatus(pub.status)}
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															{pub.user?.full_name || 'Не указан'}
														</TableCell>
														<TableCell sx={{ textAlign: 'center' }}>
															<Box sx={{ display: 'flex', justifyContent: 'center', gap: 1 }}>
																<IconButton
																	aria-label="edit"
																	onClick={() => handleEditClick('publication', pub)}
																	sx={{
																		color: '#0071E3',
																		borderRadius: '8px',
																		'&:hover': {
																			color: '#FFFFFF',
																			backgroundColor: '#0071E3',
																			boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																		},
																	}}
																>
																	<EditIcon />
																</IconButton>
																<IconButton
																	aria-label="delete"
																	onClick={() => handleDeleteClick('publication', pub)}
																	sx={{
																		color: '#0071E3',
																		borderRadius: '8px',
																		'&:hover': {
																			color: '#FFFFFF',
																			backgroundColor: '#0071E3',
																			boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																		},
																	}}
																>
																	<DeleteIcon />
																</IconButton>
																{pub.file_url && (
																	<IconButton
																		aria-label="download"
																		onClick={() => {
																			const link = document.createElement('a');
																			link.href = `http://localhost:5000${pub.file_url}`;
																			link.download = pub.file_url.split('/').pop();
																			document.body.appendChild(link);
																			link.click();
																			document.body.removeChild(link);
																		}}
																		sx={{
																			color: '#0071E3',
																			borderRadius: '8px',
																			'&:hover': {
																				color: '#FFFFFF',
																				backgroundColor: '#0071E3',
																				boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																			},
																		}}
																	>
																		<DownloadIcon />
																	</IconButton>
																)}
															</Box>
														</TableCell>
													</TableRow>
												))
											) : (
												<TableRow>
													<TableCell colSpan={8} sx={{ textAlign: 'center', color: '#6E6E73' }}>
														Нет публикаций.
													</TableCell>
												</TableRow>
											)}
										</TableBody>
									</Fade>
								</AppleTable>
								<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
									<Pagination
										count={totalPagesPublications}
										page={currentPagePublications}
										onChange={handlePageChangePublications}
										color="primary"
										sx={{
											'& .MuiPaginationItem-root': {
												borderRadius: 20,
												transition: 'all 0.3s ease',
												'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
												'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
											},
										}}
									/>
								</Box>
							</>
						)}
						<Dialog
							open={openDeleteDialog}
							onClose={handleDeleteCancel}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Подтвердите удаление
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<Typography sx={{ color: '#6E6E73' }}>
									Вы уверены, что хотите удалить{' '}
									{userToDelete ? `пользователя «${userToDelete.username}»` : `публикацию «${publicationToDelete?.title}»`}?
								</Typography>
							</DialogContent>
							<DialogActions sx={{ padding: '16px 24px', borderTop: '1px solid #E5E5EA' }}>
								<CancelButton onClick={handleDeleteCancel}>Отмена</CancelButton>
								<AppleButton onClick={handleDeleteConfirm}>Удалить</AppleButton>
							</DialogActions>
						</Dialog>

						<Dialog
							open={openEditDialog}
							onClose={handleEditCancel}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								{editUser ? 'Редактировать пользователя' : 'Редактировать публикацию'}
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<form onSubmit={handleEditSubmit}>
									{editUser ? (
										<>
											<AppleTextField
												fullWidth
												label="Логин"
												value={editUsername}
												onChange={(e) => setEditUsername(e.target.value)}
												margin="normal"
												variant="outlined"
												autoComplete="username"
											/>
											<AppleTextField
												fullWidth
												select
												label="Роль"
												value={editRole}
												onChange={(e) => setEditRole(e.target.value)}
												margin="normal"
												variant="outlined"
											>
												<MenuItem value="user">Пользователь</MenuItem>
												<MenuItem value="admin">Администратор</MenuItem>
												<MenuItem value="manager">Управляющий</MenuItem> {/* Добавляем новую роль */}
											</AppleTextField>
											<AppleTextField
												fullWidth
												label="Фамилия"
												value={editLastName}
												onChange={(e) => setEditLastName(e.target.value)}
												margin="normal"
												variant="outlined"
												autoComplete="family-name"
											/>
											<AppleTextField
												fullWidth
												label="Имя"
												value={editFirstName}
												onChange={(e) => setEditFirstName(e.target.value)}
												margin="normal"
												variant="outlined"
												autoComplete="given-name"
											/>
											<AppleTextField
												fullWidth
												label="Отчество"
												value={editMiddleName}
												onChange={(e) => setEditMiddleName(e.target.value)}
												margin="normal"
												variant="outlined"
												autoComplete="additional-name"
											/>
											<AppleTextField
												fullWidth
												label="Новый пароль (если нужно изменить)"
												type={showEditPassword ? 'text' : 'password'}
												value={editNewPassword}
												onChange={(e) => setEditNewPassword(e.target.value)}
												margin="normal"
												variant="outlined"
												autoComplete="new-password"
												InputProps={{
													endAdornment: (
														<IconButton onClick={handleToggleEditPasswordVisibility}>
															{showEditPassword ? <VisibilityOff /> : <Visibility />}
														</IconButton>
													),
												}}
											/>
										</>
									) : (
										<>
											<AppleTextField
												fullWidth
												label="Название"
												value={editTitle}
												onChange={(e) => setEditTitle(e.target.value)}
												margin="normal"
												variant="outlined"
											/>
											<AppleTextField
												fullWidth
												label="Авторы"
												value={editAuthors}
												onChange={(e) => setEditAuthors(e.target.value)}
												margin="normal"
												variant="outlined"
											/>
											<AppleTextField
												fullWidth
												label="Год"
												type="number"
												value={editYear}
												onChange={(e) => setEditYear(e.target.value)}
												margin="normal"
												variant="outlined"
											/>
											<AppleTextField
												fullWidth
												select
												label="Тип публикации"
												value={editType}
												onChange={(e) => setEditType(e.target.value)}
												margin="normal"
												variant="outlined"
											>
												<MenuItem value="article">Статья</MenuItem>
												<MenuItem value="monograph">Монография</MenuItem>
												<MenuItem value="conference">Доклад/конференция</MenuItem>
											</AppleTextField>
											<AppleTextField
												fullWidth
												select
												label="Статус"
												value={editStatus}
												onChange={(e) => setEditStatus(e.target.value)}
												margin="normal"
												variant="outlined"
												disabled={!editPublication?.file_url && !editFile}
											>
												<MenuItem value="draft">Черновик</MenuItem>
												<MenuItem value="needs_review">Нуждается в проверке</MenuItem>
												<MenuItem value="published" disabled={!editPublication?.file_url && !editFile}>
													Опубликовано
												</MenuItem>
											</AppleTextField>
											<Box sx={{ mt: 2 }}>
												<Typography variant="body2" sx={{ color: '#6E6E73', mb: 1 }}>
													Текущий файл: {editPublication?.file_url || 'Нет файла'}
												</Typography>
												<input
													type="file"
													accept=".pdf,.docx"
													onChange={(e) => setEditFile(e.target.files[0])}
													style={{ display: 'none' }}
													id="edit-upload-file"
												/>
												<label htmlFor="edit-upload-file">
													<AppleButton sx={{ border: '1px solid #D1D1D6', backgroundColor: '#F5F5F7', color: '#1D1D1F' }} component="span">
														Выбрать файл
													</AppleButton>
												</label>
												{editFile && <Typography sx={{ mt: 1, color: '#6E6E73' }}>{editFile.name}</Typography>}
											</Box>
										</>
									)}
									<Collapse in={openError}>
										{error && (
											<Alert
												severity="error"
												sx={{
													mt: 2,
													borderRadius: '12px',
													backgroundColor: '#FFF1F0',
													color: '#1D1D1F',
													boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
												}}
												onClose={() => setOpenError(false)}
											>
												{error}
											</Alert>
										)}
									</Collapse>
									<Collapse in={openSuccess}>
										{success && (
											<Alert
												severity="success"
												sx={{
													mt: 2,
													borderRadius: '12px',
													backgroundColor: '#E7F8E7',
													color: '#1D1D1F',
													boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
												}}
												onClose={() => setOpenSuccess(false)}
											>
												{success}
											</Alert>
										)}
									</Collapse>
									<DialogActions sx={{ padding: '16px 0', borderTop: '1px solid #E5E5EA' }}>
										<CancelButton onClick={handleEditCancel}>Отмена</CancelButton>
										<AppleButton type="submit">Сохранить</AppleButton>
									</DialogActions>
								</form>
							</DialogContent>
						</Dialog>
					</>
				)}
			</AppleCard>
		</Container>
	);
}

export default AdminDashboard;
-----------
D:\publication-system\frontend\src\components\CommentSection.js
import React, { useState } from 'react';
import {
	Box,
	Typography,
	TextField,
	IconButton,
	List,
	ListItem,
	Divider,
} from '@mui/material';
import { styled } from '@mui/system';
import SendIcon from '@mui/icons-material/Send';
import ReplyIcon from '@mui/icons-material/Reply';
import axios from 'axios';
import { useAuth } from '../contexts/AuthContext';

const AppleTextField = styled(TextField)({
	'& .MuiOutlinedInput-root': {
		borderRadius: '12px',
		backgroundColor: '#F5F5F7',
		'& fieldset': { borderColor: '#D1D1D6' },
		'&:hover fieldset': { borderColor: '#0071E3' },
		'&.Mui-focused fieldset': { borderColor: '#0071E3' },
	},
	'& label': { color: '#6E6E73' },
	'& input': { color: '#1D1D1F' },
});

const AppleButton = styled(IconButton)({
	color: '#0071E3',
	'&:hover': {
		color: '#FFFFFF',
		backgroundColor: '#0071E3',
	},
});

const CommentSection = ({ comments, publicationId, onCommentAdded }) => {
	const [newComment, setNewComment] = useState('');
	const [replyComment, setReplyComment] = useState('');
	const [replyingTo, setReplyingTo] = useState(null);
	const { csrfToken } = useAuth();

	const handleAddComment = async (parentId = null) => {
		const content = parentId ? replyComment : newComment;
		if (!content.trim()) return;

		try {
			const response = await axios.post(
				`http://localhost:5000/api/publications/${publicationId}/comments`,
				{ content, parent_id: parentId },
				{
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				}
			);
			if (onCommentAdded) {
				onCommentAdded(response.data.comment);
			}
			setNewComment('');
			setReplyComment('');
			setReplyingTo(null);
		} catch (err) {
			console.error('Error adding comment:', err);
		}
	};

	const renderComment = (comment, depth = 0) => (
		<React.Fragment key={comment.id}>
			<ListItem sx={{ pl: depth * 4 }}>
				<Box sx={{ width: '100%' }}>
					<Typography variant="body2" sx={{ color: '#6E6E73' }}>
						{comment.user.full_name} ({comment.user.role}) • {new Date(comment.created_at).toLocaleString()}
					</Typography>
					<Typography variant="body1" sx={{ color: '#1D1D1F', mt: 1 }}>
						{comment.content}
					</Typography>
					<Box sx={{ mt: 1 }}>
						<AppleButton
							onClick={() => setReplyingTo(comment.id)}
							sx={{ fontSize: '0.875rem' }}
						>
							<ReplyIcon fontSize="small" />
							<Typography variant="body2" sx={{ ml: 0.5 }}>
								Ответить
							</Typography>
						</AppleButton>
					</Box>
					{replyingTo === comment.id && (
						<Box sx={{ mt: 2, mb: 2 }}>
							<AppleTextField
								fullWidth
								value={replyComment}
								onChange={(e) => setReplyComment(e.target.value)}
								placeholder="Введите ваш ответ..."
								variant="outlined"
								multiline
								rows={2}
								sx={{ mb: 1 }}
							/>
							<AppleButton onClick={() => handleAddComment(comment.id)}>
								<SendIcon />
							</AppleButton>
							<AppleButton
								onClick={() => {
									setReplyingTo(null);
									setReplyComment('');
								}}
							>
								<Typography variant="body2">Отмена</Typography>
							</AppleButton>
						</Box>
					)}
				</Box>
			</ListItem>
			{comment.replies.length > 0 && (
				<List sx={{ pl: 4 }}>
					{comment.replies.map((reply) => renderComment(reply, depth + 1))}
				</List>
			)}
			<Divider sx={{ my: 1 }} />
		</React.Fragment>
	);

	return (
		<Box>
			<List>{comments.map((comment) => renderComment(comment))}</List>
			<AppleTextField
				fullWidth
				value={newComment}
				onChange={(e) => setNewComment(e.target.value)}
				placeholder="Добавьте комментарий..."
				variant="outlined"
				multiline
				rows={3}
				sx={{ mb: 2 }}
			/>
			<AppleButton onClick={() => handleAddComment()} disabled={!newComment.trim()}>
				<SendIcon />
			</AppleButton>
		</Box>
	);
};

export default CommentSection;
---------------
D:\publication-system\frontend\src\components\Dashboard.js
import React, { useState, useEffect, useRef } from 'react';
import { Line } from 'react-chartjs-2';
import { Chart as ChartJS, CategoryScale, LinearScale, PointElement, LineElement, BarElement, Title, Tooltip, Legend, Filler } from 'chart.js';
import {
	Container,
	Typography,
	Table,
	TableHead,
	TableRow,
	TableCell,
	TableBody,
	Grid,
	Card,
	CardContent,
	Button,
	TextField,
	Box,
	MenuItem,
	Alert,
	Collapse,
	Dialog,
	DialogTitle,
	DialogContent,
	DialogActions,
	IconButton,
	LinearProgress, // Добавляем шкалу прогресса
	Tabs,
	Tab,
	Accordion,
	AccordionSummary,
	AccordionDetails,
	Pagination,
	Fade,
	CircularProgress,
	Autocomplete,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import AddIcon from '@mui/icons-material/Add';
import { useNavigate } from 'react-router-dom';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import SaveIcon from '@mui/icons-material/Save';
import PublishIcon from '@mui/icons-material/Publish';
import LinkIcon from '@mui/icons-material/Link'; // Добавляем иконку для привязки
import UnlinkIcon from '@mui/icons-material/LinkOff';
import AttachFileIcon from '@mui/icons-material/AttachFile';
import DownloadIcon from '@mui/icons-material/Download';
import Visibility from '@mui/icons-material/Visibility';
import VisibilityOff from '@mui/icons-material/VisibilityOff';
import WarningAmberIcon from '@mui/icons-material/WarningAmber';
import { styled } from '@mui/system';
import axios from 'axios';
import { useAuth } from '../contexts/AuthContext';
import StatusChip from './StatusChip'; // Заменяем PlanStatusChip на StatusChip

ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, BarElement, Title, Tooltip, Legend, Filler);

// Кастомные стили в стиле Apple
const AppleButton = styled(Button)(({ theme }) => ({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#0071E3',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': {
		backgroundColor: '#0066CC',
		boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
	},
	'&:disabled': {
		backgroundColor: '#D1D1D6',
		color: '#FFFFFF',
	},
}));

const GreenButton = styled(Button)(({ theme }) => ({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: 'green',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': {
		backgroundColor: '#2EBB4A',
		boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
	},
	'&:disabled': {
		backgroundColor: '#D1D1D6',
		color: '#FFFFFF',
	},
}));

const AppleTextField = styled(TextField)(({ theme }) => ({
	'& .MuiOutlinedInput-root': {
		borderRadius: '12px',
		backgroundColor: '#F5F5F7',
		'& fieldset': {
			borderColor: '#D1D1D6',
		},
		'&:hover fieldset': {
			borderColor: '#0071E3',
		},
		'&.Mui-focused fieldset': {
			borderColor: '#0071E3',
		},
	},
	'& label': {
		color: '#6E6E73',
	},
	'& input': {
		color: '#1D1D1F',
	},
	'& .MuiSelect-select': {
		backgroundColor: '#F5F5F7',
	},
}));

const AppleCard = styled(Card)(({ theme }) => ({
	borderRadius: '16px',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	backgroundColor: '#FFFFFF',
}));

const AppleTable = styled(Table)(({ theme }) => ({
	borderRadius: '16px',
	overflow: 'hidden',
	backgroundColor: '#FFFFFF',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
}));

const PlanTable = styled(Table)(({ theme }) => ({
	borderRadius: '16px',
	overflow: 'hidden',
	backgroundColor: '#FFFFFF',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	marginBottom: '16px',
}));

const CancelButton = styled(Button)(({ theme }) => ({
	borderRadius: '12px',
	color: '#0071E3',
	textTransform: 'none',
	backgroundColor: 'transparent',
	'&:hover': {
		color: '#FFFFFF',
		backgroundColor: '#0071E3',
	},
}));

const DetailsButton = styled(Button)(({ theme }) => ({
	borderRadius: '12px',
	border: '1px solid #D1D1D6',
	color: '#1D1D1F',
	textTransform: 'none',
	backgroundColor: 'transparent',
	transition: 'all 0.3s ease',
	'&:hover': {
		borderColor: '#0071E3',
		color: '#0071E3',
		backgroundColor: 'transparent',
	},
}));

function Dashboard() {
	const { user, csrfToken, setCsrfToken, setUser } = useAuth();
	const [loadingUser, setLoadingUser] = useState(true);
	const [showCurrentPassword, setShowCurrentPassword] = useState(false);
	const [showNewPassword, setShowNewPassword] = useState(false);
	const [showDetailedAnalytics, setShowDetailedAnalytics] = useState(false);
	const [value, setValue] = useState(0);
	const [publications, setPublications] = useState([]);
	const [filteredPublications, setFilteredPublications] = useState([]);
	const [analytics, setAnalytics] = useState([]);
	const [uploadType, setUploadType] = useState('file');
	const [title, setTitle] = useState('');
	const [authors, setAuthors] = useState('');
	const [year, setYear] = useState('');
	const [type, setType] = useState('article');
	const [file, setFile] = useState(null);
	const [error, setError] = useState('');
	const [success, setSuccess] = useState('');
	const [openError, setOpenError] = useState(false);
	const [openSuccess, setOpenSuccess] = useState(false);
	const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
	const [publicationToDelete, setPublicationToDelete] = useState(null);
	const [planToDelete, setPlanToDelete] = useState(null); // Новое состояние для плана
	const [openEditDialog, setOpenEditDialog] = useState(false);
	const [editPublication, setEditPublication] = useState(null);
	const [editTitle, setEditTitle] = useState('');
	const [editAuthors, setEditAuthors] = useState('');
	const [editYear, setEditYear] = useState('');
	const [editType, setEditType] = useState('article');
	const [editFile, setEditFile] = useState(null);
	const [openEditUserDialog, setOpenEditUserDialog] = useState(false);
	const [editLastName, setEditLastName] = useState('');
	const [editFirstName, setEditFirstName] = useState('');
	const [editMiddleName, setEditMiddleName] = useState('');
	const [loadingInitial, setLoadingInitial] = useState(true);
	const [openAttachFileDialog, setOpenAttachFileDialog] = useState(false);
	const [publicationToAttach, setPublicationToAttach] = useState(null);
	const [attachFile, setAttachFile] = useState(null);
	const [attachError, setAttachError] = useState('');
	const [attachSuccess, setAttachSuccess] = useState('');
	const [openChangePasswordDialog, setOpenChangePasswordDialog] = useState(false);
	const [currentPassword, setCurrentPassword] = useState('');
	const [newPassword, setNewPassword] = useState('');
	const [pubTypes, setPubTypes] = useState({ article: 0, monograph: 0, conference: 0 });
	const [pubStatuses, setPubStatuses] = useState({ draft: 0, needs_review: 0, published: 0 });
	const [totalCitations, setTotalCitations] = useState(0);
	const [searchQuery, setSearchQuery] = useState('');
	const [filterType, setFilterType] = useState('all');
	const [filterStatus, setFilterStatus] = useState('all');
	const [linkDialogOpen, setLinkDialogOpen] = useState(false);
	const [selectedPlanEntry, setSelectedPlanEntry] = useState(null);
	const [filteredPublishedPublications, setFilteredPublishedPublications] = useState([]);
	const [linkSearchQuery, setLinkSearchQuery] = useState('');
	const [currentPage, setCurrentPage] = useState(1);
	const [totalPages, setTotalPages] = useState(1);
	const [publicationsTransitionKey, setPublicationsTransitionKey] = useState(0);
	const [plans, setPlans] = useState([]);
	const [openCreatePlanDialog, setOpenCreatePlanDialog] = useState(false);
	const [newPlan, setNewPlan] = useState({ year: new Date().getFullYear() + 1, expectedCount: 1 });
	const [editingPlanId, setEditingPlanId] = useState(null);
	const [planPage, setPlanPage] = useState(1);
	const [planTotalPages, setPlanTotalPages] = useState(1);
	const [publishedPublications, setPublishedPublications] = useState([]);
	const publicationsPerPage = 10;
	const plansPerPage = 10;
	const navigate = useNavigate();
	const chartRef = useRef(null);


	const validPublicationTypes = ['article', 'monograph', 'conference'];
	const validPlanStatuses = ['planned', 'in_progress', 'completed'];

	useEffect(() => {
		if (user !== null) {
			setLoadingUser(false);
			setEditLastName(user.last_name || '');
			setEditFirstName(user.first_name || '');
			setEditMiddleName(user.middle_name || '');
		}
	}, [user]);

	const handleTabChange = (event, newValue) => {
		setValue(newValue);
		if (newValue !== 2) setShowDetailedAnalytics(false);
	};

	const fetchAllPublications = async () => {
		try {
			const pubResponse = await axios.get('http://localhost:5000/api/publications', {
				withCredentials: true,
				params: {
					page: 1,
					per_page: 9999,
					search: '',
					type: 'all',
					status: 'published', // Фильтруем только опубликованные
				},
			});
			const allPubs = pubResponse.data.publications || [];
			setPublishedPublications(allPubs);
			setFilteredPublishedPublications(allPubs);
			return allPubs;
		} catch (err) {
			console.error('Ошибка загрузки всех публикаций:', err);
			setError('Произошла ошибка сервера. Попробуйте позже.');
			setOpenError(true);
			return [];
		}
	};

	const fetchData = async (page = 1, search = '', pubType = 'all', status = 'all') => {
		try {
			const pubResponse = await axios.get('http://localhost:5000/api/publications', {
				withCredentials: true,
				params: {
					page,
					per_page: publicationsPerPage,
					search,
					type: pubType,
					status,
				},
			});
			setPublications(pubResponse.data.publications);
			setFilteredPublications(pubResponse.data.publications);
			setCurrentPage(page);
			const total = pubResponse.data.total || 0;
			const calculatedTotalPages = Math.ceil(total / publicationsPerPage);
			setTotalPages(calculatedTotalPages);
			setPublicationsTransitionKey((prev) => prev + 1);

			if (page > calculatedTotalPages && calculatedTotalPages > 0) {
				setCurrentPage(1);
				fetchData(1, search, pubType, status);
				return;
			}

			const allPublications = await fetchAllPublications();
			updateAnalytics(allPublications);

			console.log('Server response for page', page, ':', pubResponse.data);
			setError('');
		} catch (err) {
			console.error('Ошибка загрузки данных:', err);
			setError('Произошла ошибка сервера. Попробуйте позже.');
			setOpenError(true);
		} finally {
			setLoadingInitial(false);
		}
	};

	const fetchPlans = async (page = 1) => {
		try {
			const response = await axios.get('http://localhost:5000/api/plans', {
				withCredentials: true,
				params: {
					page,
					per_page: plansPerPage,
				},
			});
			const sortedPlans = (response.data.plans || []).map(plan => ({
				...plan,
				isSaved: true,
				entries: plan.entries.map(entry => ({
					...entry,
					publication_id: entry.publication_id || null,
					isPostApproval: entry.isPostApproval || false, // Устанавливаем false для старых записей, если не указано
				})),
			})).sort((a, b) => b.year - a.year);
			console.log('Обновлённые планы:', sortedPlans); // Логируем для проверки
			setPlans(sortedPlans);
			setPlanPage(page);
			const total = response.data.total || 0;
			setPlanTotalPages(Math.ceil(total / plansPerPage));
			setError('');
		} catch (err) {
			console.error('Ошибка загрузки планов:', err);
			setError('Произошла ошибка сервера. Попробуйте позже.');
			setOpenError(true);
		}
	};
	const updateAnalytics = (allPublications) => {
		const types = { article: 0, monograph: 0, conference: 0 };
		const statuses = { draft: 0, needs_review: 0, published: 0 };
		let citations = 0;

		allPublications.forEach((pub) => {
			const pubType = validPublicationTypes.includes(pub.type) ? pub.type : 'article';
			types[pubType] = (types[pubType] || 0) + 1;
			statuses[pub.status] = (statuses[pub.status] || 0) + 1;
			if (pub.citations) citations += pub.citations;
		});

		setPubTypes(types);
		setPubStatuses(statuses);
		setTotalCitations(citations);

		const yearlyAnalytics = allPublications.reduce((acc, pub) => {
			acc[pub.year] = (acc[pub.year] || 0) + 1;
			return acc;
		}, {});
		const analyticsData = Object.entries(yearlyAnalytics).map(([year, count]) => ({ year: parseInt(year), count }));
		analyticsData.sort((a, b) => a.year - b.year);
		setAnalytics(analyticsData);
	};

	useEffect(() => {
		fetchData(1, searchQuery, filterType, filterStatus);
		fetchPlans(1);
		fetchAllPublications(); // Добавляем вызов 
	}, [navigate, searchQuery, filterType, filterStatus]);

	const currentPublications = filteredPublications;

	const handlePageChange = (event, newPage) => {
		fetchData(newPage, searchQuery, filterType, filterStatus);
	};

	const handlePlanPageChange = (event, newPage) => {
		fetchPlans(newPage);
	};

	const handleChangePasswordClick = () => {
		setOpenChangePasswordDialog(true);
		setCurrentPassword('');
		setNewPassword('');
		setShowCurrentPassword(false);
		setShowNewPassword(false);
	};

	const handleChangePasswordSubmit = async (e) => {
		e.preventDefault();
		try {
			await refreshCsrfToken();
			console.log('Changing password for user:', user?.username);
			const response = await axios.put(
				'http://localhost:5000/api/user/password',
				{
					current_password: currentPassword,
					new_password: newPassword,
				},
				{
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				}
			);

			setSuccess('Пароль успешно обновлен!'); // Устанавливаем глобальное состояние успеха
			setOpenSuccess(true); // Показываем уведомление
			setError(''); // Сбрасываем ошибку
			setOpenChangePasswordDialog(false); // Закрываем диалог
			setCurrentPassword('');
			setNewPassword('');
			setShowCurrentPassword(false);
			setShowNewPassword(false);
		} catch (err) {
			console.error('Ошибка изменения пароля:', err);
			if (err.response) {
				setError(
					`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте введенные данные.'}`
				); // Устанавливаем глобальное состояние ошибки
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true); // Показываем уведомление об ошибке
			setSuccess(''); // Сбрасываем успех
		}
	};

	const handleChangePasswordCancel = () => {
		setOpenChangePasswordDialog(false);
		setCurrentPassword('');
		setNewPassword('');

		setShowCurrentPassword(false);
		setShowNewPassword(false);
	};

	const handleToggleCurrentPasswordVisibility = () => {
		setShowCurrentPassword(!showCurrentPassword);
	};

	const handleToggleNewPasswordVisibility = () => {
		setShowNewPassword(!showNewPassword);
	};



	const handleFileUpload = async (e) => {
		e.preventDefault();
		if (!file) {
			setError('Пожалуйста, выберите файл для загрузки.');
			setOpenError(true);
			return;
		}
		if (!title.trim() || !authors.trim() || !year) {
			setError('Пожалуйста, заполните все обязательные поля (название, авторы, год).');
			setOpenError(true);
			return;
		}

		const fileExtension = file.name.split('.').pop().toLowerCase();
		if (!['pdf', 'docx'].includes(fileExtension)) {
			setError('Разрешены только файлы в форматах PDF или DOCX.');
			setOpenError(true);
			return;
		}

		if (isNaN(year) || year < 1900 || year > new Date().getFullYear()) {
			setError('Год должен быть числом и находиться в разумных пределах (например, 1900–' + new Date().getFullYear() + ').');
			setOpenError(true);
			return;
		}

		const formData = new FormData();
		formData.append('file', file);
		formData.append('title', title.trim());
		formData.append('authors', authors.trim());
		formData.append('year', parseInt(year, 10));
		formData.append('type', type);

		try {
			await refreshCsrfToken();
			console.log('Uploading file with data:', { title, authors, year, type });
			const response = await axios.post('http://localhost:5000/api/publications/upload-file', formData, {
				withCredentials: true,
				headers: {
					'Content-Type': 'multipart/form-data',
					'X-CSRFToken': csrfToken,
				},
			});
			setSuccess('Публикация успешно загружена!');
			setOpenSuccess(true);
			setError('');
			setTitle('');
			setAuthors('');
			setYear('');
			setType('article');
			setFile(null);
			await fetchData();
		} catch (err) {
			console.error('Ошибка загрузки файла:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте введенные поля и файл.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
			setSuccess('');
		}
	};

	const handleBibtexUpload = async (e) => {
		e.preventDefault();
		if (!file) {
			setError('Пожалуйста, выберите BibTeX-файл для загрузки.');
			setOpenError(true);
			return;
		}

		const fileExtension = file.name.split('.').pop().toLowerCase();
		if (fileExtension !== 'bib') {
			setError('Разрешены только файлы в формате .bib.');
			setOpenError(true);
			return;
		}

		const formData = new FormData();
		formData.append('file', file);

		try {
			await refreshCsrfToken();
			console.log('Uploading BibTeX file');
			const response = await axios.post('http://localhost:5000/api/publications/upload-bibtex', formData, {
				withCredentials: true,
				headers: {
					'Content-Type': 'multipart/form-data',
					'X-CSRFToken': csrfToken,
				},
			});
			setSuccess(`Загружено ${response.data.message.split(' ')[1]} публикаций!`);
			setOpenSuccess(true);
			setError('');
			setFile(null);
			await fetchData();
		} catch (err) {
			console.error('Ошибка загрузки BibTeX:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте формат BibTeX.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
			setSuccess('');
		}
	};

	const handleEditClick = (publication) => {
		console.log('Editing publication:', publication.id);
		setEditPublication(publication || {});
		setEditTitle(publication?.title || '');
		setEditAuthors(publication?.authors || '');
		setEditYear(publication?.year || '');
		setEditType(validPublicationTypes.includes(publication?.type) ? publication.type : 'article');
		setEditFile(null);
		setOpenEditDialog(true);
	};

	const handleEditSubmit = async (e) => {
		e.preventDefault();
		if (!editPublication) return;

		let data;
		let headers = {};
		if (editFile) {
			data = new FormData();
			data.append('file', editFile);
			data.append('title', editTitle.trim() || '');
			data.append('authors', editAuthors.trim() || '');
			data.append('year', editYear ? parseInt(editYear, 10) : '');
			data.append('type', editType || 'article');
			data.append('status', 'draft');
			headers['Content-Type'] = 'multipart/form-data';
			headers['X-CSRFToken'] = csrfToken;
		} else {
			data = {
				title: editTitle.trim() || '',
				authors: editAuthors.trim() || '',
				year: editYear ? parseInt(editYear, 10) : '',
				type: editType || 'article',
				status: 'draft',
			};
			headers['Content-Type'] = 'application/json';
			headers['X-CSRFToken'] = csrfToken;
		}

		try {
			await refreshCsrfToken();
			console.log('Updating publication with:', {
				title: editTitle,
				authors: editAuthors,
				year: editYear,
				type: editType,
				status: 'draft',
				file: editFile ? editFile.name : 'No new file',
			});
			const response = await axios.put(`http://localhost:5000/api/publications/${editPublication.id || ''}`, data, {
				withCredentials: true,
				headers,
			});
			setSuccess('Публикация успешно отредактирована!');
			setOpenSuccess(true);
			setError('');
			await fetchData();
			setOpenEditDialog(false);
		} catch (err) {
			console.error('Ошибка редактирования публикации:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте введенные поля.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
			setSuccess('');
		}
	};

	const handleSubmitForReview = async (publicationId) => {
		try {
			await refreshCsrfToken();
			const response = await axios.post(
				`http://localhost:5000/api/publications/${publicationId}/submit-for-review`,
				{},
				{
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				}
			);
			setSuccess('Публикация отправлена на проверку!');
			setOpenSuccess(true);
			await fetchData();
		} catch (err) {
			console.error('Ошибка отправки на проверку:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте файл и права доступа.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
		}
	};

	const handleSaveAndSubmitForReview = async (e) => {
		e.preventDefault();
		await handleEditSubmit(e);
		if (!error) {
			await handleSubmitForReview(editPublication.id);
			setOpenEditDialog(false);
		}
	};

	const handleEditCancel = () => {
		setOpenEditDialog(false);
		setEditPublication(null);
		setEditTitle('');
		setEditAuthors('');
		setEditYear('');
		setEditType('article');
		setEditFile(null);
	};

	const handleDeleteClick = (publication) => {
		console.log('Deleting publication:', publication.id);
		setPublicationToDelete(publication);
		setPlanToDelete(null); // Сбрасываем planToDelete
		setOpenDeleteDialog(true);
	};

	const handleDeleteConfirm = async () => {
		if (!publicationToDelete) return;

		try {
			await refreshCsrfToken();
			console.log('Confirming deletion of publication:', publicationToDelete.id);
			const response = await axios.delete(`http://localhost:5000/api/publications/${publicationToDelete.id}`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setSuccess('Публикация успешно удалена!');
			setOpenSuccess(true);
			setError('');
			await fetchData();
		} catch (err) {
			console.error('Ошибка удаления публикации:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте права доступа.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
			setSuccess('');
		}
		setOpenDeleteDialog(false);
		setPublicationToDelete(null);
	};

	const handleDeleteCancel = () => {
		setOpenDeleteDialog(false);
		setPublicationToDelete(null);
		setPlanToDelete(null);
	};

	const handleEditUserClick = () => {
		setOpenEditUserDialog(true);
	};

	const handleEditUserSubmit = async (e) => {
		e.preventDefault();
		try {
			await refreshCsrfToken();
			console.log('Updating user data:', { last_name: editLastName, first_name: editFirstName, middle_name: editMiddleName });
			const response = await axios.put(
				'http://localhost:5000/api/user',
				{
					last_name: editLastName.trim() || null,
					first_name: editFirstName.trim() || null,
					middle_name: editMiddleName.trim() || null,
				},
				{
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				}
			);
			// Обновляем данные пользователя в контексте
			setUser({
				...user,
				last_name: response.data.user.last_name,
				first_name: response.data.user.first_name,
				middle_name: response.data.user.middle_name,
			});
			// Устанавливаем сообщение об успехе для отображения в карточке
			setSuccess('Личные данные успешно обновлены!');
			setOpenSuccess(true);
			setError('');
			setOpenEditUserDialog(false); // Закрываем диалог сразу после успешного сохранения
		} catch (err) {
			console.error('Ошибка редактирования данных:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте введенные поля.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
			setSuccess('');
		}
	};

	const handleEditUserCancel = () => {
		setOpenEditUserDialog(false);
	};

	const handleAttachFileClick = (publication) => {
		console.log('Attaching file to publication:', publication.id);
		setPublicationToAttach(publication);
		setOpenAttachFileDialog(true);
		setAttachFile(null);
		setAttachError('');
		setAttachSuccess('');
	};

	const handleAttachFileSubmit = async (e) => {
		e.preventDefault();
		if (!attachFile) {
			setAttachError('Пожалуйста, выберите файл для прикрепления.');
			return;
		}

		const formData = new FormData();
		formData.append('file', attachFile);

		try {
			await refreshCsrfToken();
			console.log('Sending attach file request for publication:', publicationToAttach.id);
			const response = await axios.post(
				`http://localhost:5000/api/publications/${publicationToAttach.id}/attach-file`,
				formData,
				{
					withCredentials: true,
					headers: {
						'Content-Type': 'multipart/form-data',
						'X-CSRFToken': csrfToken,
					},
				}
			);
			setAttachSuccess('Файл успешно прикреплен!');
			setAttachError('');
			await fetchData();
			setOpenAttachFileDialog(false);
		} catch (err) {
			console.error('Ошибка прикрепления файла:', err.response?.data || err);
			if (err.response) {
				setAttachError(
					`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте файл и права доступа.'}`
				);
			} else {
				setAttachError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setAttachSuccess('');
		}
	};

	const handleAttachFileCancel = () => {
		setOpenAttachFileDialog(false);
		setPublicationToAttach(null);
		setAttachFile(null);
		setAttachError('');
		setAttachSuccess('');
	};

	const handleDownloadClick = (publication) => {
		console.log('Downloading file for publication:', publication.id);
		if (!publication.file_url) {
			setError('Файл не прикреплен к этой публикации.');
			setOpenError(true);
			return;
		}
		const normalizedUrl = publication.file_url.replace(/^.*uploads/, 'uploads');
		const link = document.createElement('a');
		link.href = `http://localhost:5000/${normalizedUrl}`;
		link.download = normalizedUrl.split('/').pop();
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	};

	useEffect(() => {
		if (openError || openSuccess) {
			const timer = setTimeout(() => {
				setOpenError(false);
				setOpenSuccess(false);
				setError('');
				setSuccess('');
			}, 5000);
			return () => clearTimeout(timer);
		}
	}, [openError, openSuccess]);

	useEffect(() => {
		if (attachError || attachSuccess) {
			const timer = setTimeout(() => {
				setAttachError('');
				setAttachSuccess('');
			}, 5000);
			return () => clearTimeout(timer);
		}
	}, [attachError, attachSuccess]);

	const handleExportBibTeX = async () => {
		try {
			await refreshCsrfToken();
			const response = await axios.get('http://localhost:5000/api/publications/export-bibtex', {
				withCredentials: true,
			});
			const blob = new Blob([response.data], { type: 'application/x-bibtex' });
			const url = window.URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.href = url;
			link.download = 'publications.bib';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			window.URL.revokeObjectURL(url);
		} catch (err) {
			console.error('Ошибка выгрузки в BibTeX:', err.response?.data || err.message);
			alert(`Не удалось экспортировать публикации в BibTeX: ${err.response?.data?.error || 'Внутренняя ошибка сервера'}`);
		}
	};

	const chartData = {
		labels: analytics.map((item) => item.year),
		datasets: [
			{
				label: 'Количество публикаций',
				data: analytics.map((item) => item.count),
				backgroundColor: 'rgba(0, 120, 255, 0.5)',
				borderColor: 'rgba(0, 120, 255, 1)',
				borderWidth: 1,
				fill: true,
				tension: 0.4,
			},
		],
	};

	const chartOptions = {
		responsive: true,
		maintainAspectRatio: false,
		plugins: {
			legend: { position: 'top', labels: { color: '#1D1D1F' } },
			title: { display: false },
			tooltip: { backgroundColor: 'rgba(0, 0, 0, 0.8)', titleColor: '#FFFFFF', bodyColor: '#FFFFFF' },
		},
		scales: {
			x: { title: { display: false }, ticks: { color: '#1D1D1F' } },
			y: { title: { display: false }, beginAtZero: true, ticks: { color: '#1D1D1F' } },
		},
		animation: { duration: 1000 },
	};

	const handleCreatePlan = async () => {
		if (!newPlan.year || !newPlan.expectedCount || newPlan.expectedCount < 1) {
			setError('Пожалуйста, укажите год и количество ожидаемых публикаций (минимум 1).');
			setOpenError(true);
			return;
		}

		try {
			await refreshCsrfToken();
			const planData = {
				year: newPlan.year,
				expectedCount: newPlan.expectedCount,
				fillType: 'manual',
				entries: Array.from({ length: newPlan.expectedCount }, () => ({
					title: '',
					type: 'article',
					status: 'planned',
				})),
			};
			console.log('Creating plan with:', planData);
			const response = await axios.post('http://localhost:5000/api/plans', planData, {
				withCredentials: true,
				headers: {
					'X-CSRFToken': csrfToken,
					'Content-Type': 'application/json',
				},
			});
			setSuccess('План успешно создан!');
			setOpenSuccess(true);
			setError('');
			setOpenCreatePlanDialog(false);
			setNewPlan({ year: new Date().getFullYear() + 1, expectedCount: 1 });
			await fetchPlans(planPage);
		} catch (err) {
			console.error('Ошибка создания плана:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте введенные поля.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
			setSuccess('');
		}
	};

	const handleEditPlanClick = (planId) => {
		setEditingPlanId(planId);
		setPlans(prevPlans =>
			prevPlans.map(plan =>
				plan.id === planId ? { ...plan, isSaved: false } : plan
			)
		);
	};

	const handleAddPlanEntry = (planId) => {
		setPlans(prevPlans =>
			prevPlans.map(plan =>
				plan.id === planId
					? {
						...plan,
						entries: [
							...plan.entries,
							{
								title: '',
								type: 'article',
								status: 'planned',
								isPostApproval: true // Новая запись после утверждения
							},
						],
					}
					: plan
			)
		);
	};

	const handleDeletePlanEntry = (planId, index) => {
		setPlans(prevPlans =>
			prevPlans.map(plan =>
				plan.id === planId
					? {
						...plan,
						entries: plan.entries.filter((_, i) => i !== index),
						isSaved: false,
					}
					: plan
			)
		);
	};
	const handleSavePlan = async (plan) => {
		try {
			await refreshCsrfToken();
			const planData = {
				year: plan.year,
				expectedCount: plan.expectedCount,
				fillType: 'manual',
				entries: plan.entries.map(entry => ({
					id: entry.id || undefined, // Сохраняем id для существующих записей
					title: entry.title || '',
					type: entry.type || 'article',
					status: entry.status || 'planned',
					publication_id: entry.publication_id || null,
					isPostApproval: entry.isPostApproval || false, // Сохраняем флаг
				})),
			};
			console.log('Saving plan with:', planData);
			const response = await axios.put(`http://localhost:5000/api/plans/${plan.id}`, planData, {
				withCredentials: true,
				headers: {
					'X-CSRFToken': csrfToken,
					'Content-Type': 'application/json',
				},
			});
			setSuccess('План успешно сохранён!');
			setOpenSuccess(true);
			setError('');
			setEditingPlanId(null);
			setPlans(prevPlans =>
				prevPlans.map(p =>
					p.id === plan.id ? { ...p, entries: response.data.plan.entries, isSaved: true } : p
				)
			);
			await fetchPlans(planPage);
		} catch (err) {
			console.error('Ошибка сохранения плана:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте введенные поля.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
			setSuccess('');
		}
	};

	const handleSubmitPlanForReview = async (plan) => {
		try {
			await refreshCsrfToken();
			const response = await axios.post(
				`http://localhost:5000/api/plans/${plan.id}/submit-for-review`,
				{},
				{
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				}
			);
			setSuccess('План отправлен на проверку!');
			setOpenSuccess(true);
			setError('');
			setEditingPlanId(null);
			await fetchPlans(planPage);
		} catch (err) {
			console.error('Ошибка отправки плана на проверку:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте права доступа.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
			setSuccess('');
		}
	};

	const handleDeletePlanClick = (plan) => {
		console.log('Deleting plan:', plan.id);
		setPlanToDelete(plan);
		setPublicationToDelete(null); // Сбрасываем publicationToDelete
		setOpenDeleteDialog(true);
	};

	const handleDeletePlanConfirm = async () => {
		if (!planToDelete) return;

		try {
			await refreshCsrfToken();
			console.log('Confirming deletion of plan:', planToDelete.id);
			const response = await axios.delete(`http://localhost:5000/api/plans/${planToDelete.id}`, {
				withCredentials: true,
				headers: {
					'X-CSRFToken': csrfToken,
				},
			});
			setSuccess('План успешно удалён!');
			setOpenSuccess(true);
			setError('');
			await fetchPlans(planPage);
		} catch (err) {
			console.error('Ошибка удаления плана:', err.response?.data || err);
			if (err.response) {
				setError(`Ошибка: ${err.response.status} - ${err.response.data?.error || 'Проверьте права доступа.'}`);
			} else {
				setError('Ошибка сети. Проверьте подключение и сервер.');
			}
			setOpenError(true);
			setSuccess('');
		}
		setOpenDeleteDialog(false);
		setPlanToDelete(null);
	};

	const handleLinkSearch = (query) => {
		setLinkSearchQuery(query);

		// Собираем все publication_id из записей всех планов
		const linkedPublicationIds = new Set(
			plans.flatMap(plan =>
				plan.entries
					.filter(entry => entry.publication_id)
					.map(entry => entry.publication_id)
			)
		);

		// Фильтруем публикации, исключая уже привязанные
		const availablePublications = publishedPublications.filter(
			pub => !linkedPublicationIds.has(pub.id)
		);

		// Применяем поиск по отфильтрованным данным
		const filtered = availablePublications.filter(
			(pub) =>
				pub.title.toLowerCase().includes(query.toLowerCase()) ||
				pub.authors.toLowerCase().includes(query.toLowerCase())
		);
		setFilteredPublishedPublications(filtered);
	};

	const handleOpenLinkDialog = (planId, entry) => {
		// Собираем все publication_id из записей всех планов
		const linkedPublicationIds = new Set(
			plans.flatMap(plan =>
				plan.entries
					.filter(entry => entry.publication_id) // Фильтруем записи с publication_id
					.map(entry => entry.publication_id)
			)
		);

		// Фильтруем только те публикации, которые ещё не привязаны
		const availablePublications = publishedPublications.filter(
			pub => !linkedPublicationIds.has(pub.id)
		);

		setSelectedPlanEntry({ planId, ...entry });
		setLinkDialogOpen(true);
		setLinkSearchQuery('');
		setFilteredPublishedPublications(availablePublications);
	};

	// Функция привязки публикации
	const handleLinkPublication = async (planId, entryId, publicationId) => {
		try {
			await refreshCsrfToken();
			console.log('Отправка запроса привязки:', { planId, entryId, publicationId });
			const response = await axios.post(
				`http://localhost:5000/api/plans/${planId}/entries/${entryId}/link`,
				{ publication_id: publicationId },
				{
					withCredentials: true,
					headers: {
						'X-CSRFToken': csrfToken,
						'Content-Type': 'application/json',
					},
				}
			);
			console.log('Ответ сервера:', response.data);
			setSuccess('Публикация успешно привязана!');
			setOpenSuccess(true);
			await Promise.all([fetchPlans(planPage), fetchAllPublications()]);
			setLinkDialogOpen(false);
		} catch (err) {
			console.error('Ошибка привязки:', err.response?.data || err.message);
			setError(err.response?.data?.error || 'Не удалось привязать публикацию.');
			setOpenError(true);
		}
	};


	// Функция отвязки публикации
	const handleUnlinkPublication = async (planId, entryId) => {
		try {
			await refreshCsrfToken();
			await axios.post(
				`http://localhost:5000/api/plans/${planId}/entries/${entryId}/unlink`,
				{},
				{
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				}
			);
			setSuccess('Публикация успешно отвязана!');
			setOpenSuccess(true);
			fetchPlans(planPage);
		} catch (err) {
			setError(err.response?.data?.error || 'Не удалось отвязать публикацию.');
			setOpenError(true);
		}
	};

	// Функция вычисления прогресса выполнения плана
	const calculateProgress = (plan) => {
		const completed = plan.entries.filter((entry) => entry.publication_id).length;
		const total = plan.expectedCount;
		return total > 0 ? (completed / total) * 100 : 0;
	};

	const handlePlanEntryChange = (planId, index, field, value) => {
		setPlans(prevPlans =>
			prevPlans.map(plan =>
				plan.id === planId
					? {
						...plan,
						entries: plan.entries.map((entry, i) =>
							i === index ? { ...entry, [field]: value } : entry
						),
					}
					: plan
			)
		);
	};

	const areAllTitlesFilled = (plan) => {
		return plan.entries.every(entry => entry.title && entry.title.trim() !== '');
	};

	const refreshCsrfToken = async () => {
		try {
			const response = await axios.get('http://localhost:5000/api/csrf-token', {
				withCredentials: true,
			});
			setCsrfToken(response.data.csrf_token);
			console.log('CSRF Token обновлён:', response.data.csrf_token);
		} catch (err) {
			console.error('Ошибка обновления CSRF Token:', err);
		}
	};

	if (loadingUser) {
		return (
			<Container maxWidth="lg" sx={{ mt: 4, display: 'flex', justifyContent: 'center' }}>
				<CircularProgress sx={{ color: '#0071E3' }} />
			</Container>
		);
	}

	return (
		<Container
			maxWidth="lg"
			sx={{
				mt: 4,
				backgroundColor: '#FFFFFF',
				borderRadius: '16px',
				boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
				fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
			}}
		>
			<AppleCard sx={{ p: 4, borderRadius: '16px', backgroundColor: '#FFFFFF', boxShadow: 'none' }}>
				<CardContent>
					<Typography
						variant="h4"
						gutterBottom
						sx={{
							color: '#1D1D1F',
							fontWeight: 600,
							textAlign: 'center',
						}}
					>
						Личный кабинет
					</Typography>

					<Tabs
						value={value}
						onChange={handleTabChange}
						sx={{
							mb: 4,
							'& .MuiTab-root': {
								color: '#6E6E73',
								fontSize: '1.1rem',
								textTransform: 'none',
								borderRadius: '12px',
								'&:hover': { color: '#0071E3', backgroundColor: '#F5F5F7' },
								'&.Mui-selected': { color: '#1D1D1F', backgroundColor: '#F5F5F7' },
							},
							'& .MuiTabs-indicator': { backgroundColor: '#0071E3' },
						}}
					>
						<Tab label="Личные данные" />
						<Tab label="Публикации" />
						<Tab label="Аналитика" />
						<Tab label="План" />
						<Tab label="Экспорт" />
					</Tabs>

					{loadingInitial ? (
						<Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
							<CircularProgress sx={{ color: '#0071E3' }} />
						</Box>
					) : (
						<>
							{value === 0 && (
								<Accordion
									defaultExpanded
									sx={{
										boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
										borderRadius: '16px',
										backgroundColor: '#FFFFFF',
									}}
								>
									<AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#FFFFFF' }} />} sx={{ backgroundColor: '#0071E3', borderRadius: '16px' }}>
										<Typography variant="h5" sx={{ color: '#FFFFFF' }}>
											Личные данные
										</Typography>
									</AccordionSummary>
									<AccordionDetails sx={{ p: 3 }}>
										{user ? (
											<Box>
												<Typography variant="body1" sx={{ color: '#1D1D1F', mb: 2 }}>
													ФИО: {user.last_name} {user.first_name} {user.middle_name || ''}
												</Typography>
												<Typography variant="body1" sx={{ color: '#1D1D1F', mb: 2 }}>
													Логин: {user.username}
												</Typography>
												<Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
													<AppleButton onClick={handleEditUserClick}>Редактировать данные</AppleButton>
													<AppleButton onClick={handleChangePasswordClick}>Изменить пароль</AppleButton>
												</Box>
												{/* Добавляем уведомление об успехе или ошибке внизу карточки */}
												<Collapse in={openSuccess}>
													{success && (
														<Alert
															severity="success"
															sx={{
																mt: 2,
																borderRadius: '12px',
																backgroundColor: '#E7F8E7',
																color: '#1D1D1F',
																boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
															}}
															onClose={() => setOpenSuccess(false)}
														>
															{success}
														</Alert>
													)}
												</Collapse>
												<Collapse in={openError}>
													{error && (
														<Alert
															severity="error"
															sx={{
																mt: 2,
																borderRadius: '12px',
																backgroundColor: '#FFF1F0',
																color: '#1D1D1F',
																boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
															}}
															onClose={() => setOpenError(false)}
														>
															{error}
														</Alert>
													)}
												</Collapse>
											</Box>
										) : (
											<Typography sx={{ color: '#6E6E73' }}>Данные пользователя не найдены.</Typography>
										)}
									</AccordionDetails>
								</Accordion>
							)}

							{value === 1 && (
								<>
									<Typography
										variant="h5"
										gutterBottom
										sx={{
											mt: 4,
											color: '#1D1D1F',
											fontWeight: 600,
											textAlign: 'center',
										}}
									>
										Загрузка публикаций
									</Typography>
									<AppleCard sx={{ mb: 4, p: 3, backgroundColor: '#F5F5F7', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
										<Box sx={{ mb: 2, display: 'flex', gap: 2 }}>
											<AppleButton
												onClick={() => setUploadType('file')}
												sx={{
													backgroundColor: uploadType === 'file' ? '#0071E3' : '#F5F5F7',
													color: uploadType === 'file' ? '#FFFFFF' : '#1D1D1F',
													border: '1px solid #D1D1D6',
												}}
											>
												Загрузить файл (PDF/DOCX)
											</AppleButton>
											<AppleButton
												onClick={() => setUploadType('bibtex')}
												sx={{
													backgroundColor: uploadType === 'bibtex' ? '#0071E3' : '#F5F5F7',
													color: uploadType === 'bibtex' ? '#FFFFFF' : '#1D1D1F',
													border: '1px solid #D1D1D6',
												}}
											>
												Загрузить BibTeX
											</AppleButton>
										</Box>

										{uploadType === 'file' ? (
											<form onSubmit={handleFileUpload}>
												<AppleTextField
													fullWidth
													label="Название"
													value={title}
													onChange={(e) => setTitle(e.target.value)}
													margin="normal"
													variant="outlined"
												/>
												<AppleTextField
													fullWidth
													label="Авторы"
													value={authors}
													onChange={(e) => setAuthors(e.target.value)}
													margin="normal"
													variant="outlined"
												/>
												<AppleTextField
													fullWidth
													label="Год"
													type="number"
													value={year}
													onChange={(e) => setYear(e.target.value)}
													margin="normal"
													variant="outlined"
												/>
												<AppleTextField
													fullWidth
													select
													label="Тип публикации"
													value={type}
													onChange={(e) => setType(e.target.value)}
													margin="normal"
													variant="outlined"
												>
													<MenuItem value="article">Статья</MenuItem>
													<MenuItem value="monograph">Монография</MenuItem>
													<MenuItem value="conference">Доклад/конференция</MenuItem>
												</AppleTextField>
												<Box sx={{ mt: 2 }}>
													<input
														type="file"
														accept=".pdf,.docx"
														onChange={(e) => setFile(e.target.files[0])}
														style={{ display: 'none' }}
														id="upload-file"
													/>
													<label htmlFor="upload-file">
														<AppleButton sx={{ border: '1px solid #D1D1D6', backgroundColor: '#F5F5F7', color: '#1D1D1F' }} component="span">
															Выбрать файл
														</AppleButton>
													</label>
													{file && <Typography sx={{ mt: 1, color: '#6E6E73' }}>{file.name}</Typography>}
												</Box>
												<Collapse in={openError}>
													{error && (
														<Alert
															severity="error"
															sx={{
																mt: 2,
																borderRadius: '12px',
																backgroundColor: '#FFF1F0',
																color: '#1D1D1F',
																boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
															}}
															onClose={() => setOpenError(false)}
														>
															{error}
														</Alert>
													)}
												</Collapse>
												<Collapse in={openSuccess}>
													{success && (
														<Alert
															severity="success"
															sx={{
																mt: 2,
																borderRadius: '12px',
																backgroundColor: '#E7F8E7',
																color: '#1D1D1F',
																boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
															}}
															onClose={() => setOpenSuccess(false)}
														>
															{success}
														</Alert>
													)}
												</Collapse>
												<AppleButton type="submit" sx={{ mt: 2 }}>
													Загрузить
												</AppleButton>
											</form>
										) : (
											<form onSubmit={handleBibtexUpload}>
												<Box sx={{ mb: 2 }}>
													<input
														type="file"
														accept=".bib"
														onChange={(e) => setFile(e.target.files[0])}
														style={{ display: 'none' }}
														id="upload-bibtex"
													/>
													<label htmlFor="upload-bibtex">
														<AppleButton sx={{ border: '1px solid #D1D1D6', backgroundColor: '#F5F5F7', color: '#1D1D1F' }} component="span">
															Выбрать BibTeX-файл
														</AppleButton>
													</label>
													{file && <Typography sx={{ mt: 1, color: '#6E6E73' }}>{file.name}</Typography>}
												</Box>
												<Collapse in={openError}>
													{error && (
														<Alert
															severity="error"
															sx={{
																mb: 2,
																borderRadius: '12px',
																backgroundColor: '#FFF1F0',
																color: '#1D1D1F',
																boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
															}}
															onClose={() => setOpenError(false)}
														>
															{error}
														</Alert>
													)}
												</Collapse>
												<Collapse in={openSuccess}>
													{success && (
														<Alert
															severity="success"
															sx={{
																mb: 2,
																borderRadius: '12px',
																backgroundColor: '#E7F8E7',
																color: '#1D1D1F',
																boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
															}}
															onClose={() => setOpenSuccess(false)}
														>
															{success}
														</Alert>
													)}
												</Collapse>
												<AppleButton type="submit" sx={{ mt: 2 }}>
													Загрузить
												</AppleButton>
											</form>
										)}
									</AppleCard>
									<Typography
										variant="h5"
										gutterBottom
										sx={{
											mt: 4,
											color: '#1D1D1F',
											fontWeight: 600,
											textAlign: 'center',
										}}
									>
										Ваши публикации
									</Typography>
									<AppleCard sx={{ mt: 2, mb: 2, p: 2, backgroundColor: '#F5F5F7', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
										<AppleTextField
											fullWidth
											label="Поиск по названию, авторам или году"
											value={searchQuery}
											onChange={(e) => setSearchQuery(e.target.value)}
											margin="normal"
											variant="outlined"
											InputProps={{
												endAdornment: <IconButton sx={{ color: '#0071E3' }}>{/* Можно добавить иконку поиска */}</IconButton>,
											}}
										/>
										<Box sx={{ mt: 2, display: 'flex', gap: 2 }}>
											<AppleTextField
												select
												label="Тип публикации"
												value={filterType}
												onChange={(e) => setFilterType(e.target.value)}
												margin="normal"
												variant="outlined"
											>
												<MenuItem value="all">Все</MenuItem>
												<MenuItem value="article">Статья</MenuItem>
												<MenuItem value="monograph">Монография</MenuItem>
												<MenuItem value="conference">Доклад/конференция</MenuItem>
											</AppleTextField>
											<AppleTextField
												select
												label="Статус"
												value={filterStatus}
												onChange={(e) => setFilterStatus(e.target.value)}
												margin="normal"
												variant="outlined"
											>
												<MenuItem value="all">Все</MenuItem>
												<MenuItem value="draft">Черновик</MenuItem>
												<MenuItem value="needs_review">Нуждается в проверке</MenuItem>
												<MenuItem value="published">Опубликованные</MenuItem>
											</AppleTextField>
										</Box>
									</AppleCard>
									<AppleTable sx={{ mt: 2, boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
										<TableHead>
											<TableRow sx={{ backgroundColor: '#0071E3' }}>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', borderRadius: '12px 0 0 0' }}>ID</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Название</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Авторы</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Год</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Тип</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Статус</TableCell>
												<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', textAlign: 'center', borderRadius: '0 12px 0 0' }}>
													Действия
												</TableCell>
											</TableRow>
										</TableHead>
										<Fade in={true} timeout={500} key={publicationsTransitionKey}>
											<TableBody>
												{currentPublications.length > 0 ? (
													currentPublications.map((pub) => (
														<TableRow
															key={pub.id}
															sx={{
																'&:hover': { backgroundColor: '#F5F5F7', transition: 'background-color 0.3s ease' },
															}}
														>
															<TableCell sx={{ color: '#1D1D1F' }}>{pub.id}</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>
																<Typography
																	sx={{
																		color: '#0071E3',
																		textDecoration: 'underline',
																		cursor: 'pointer',
																		'&:hover': { textDecoration: 'none' },
																	}}
																	onClick={() => navigate(`/publication/${pub.id}`)}
																>
																	{pub.title}
																</Typography>
															</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>{pub.authors}</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>{pub.year}</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>
																{pub.type === 'article'
																	? 'Статья'
																	: pub.type === 'monograph'
																		? 'Монография'
																		: pub.type === 'conference'
																			? 'Доклад/конференция'
																			: 'Неизвестный тип'}
															</TableCell>
															<TableCell sx={{ color: '#1D1D1F' }}>
																<StatusChip
																	status={
																		pub.status === 'draft' && pub.returned_for_revision
																			? 'returned'
																			: pub.status
																	}
																/>
															</TableCell>
															<TableCell sx={{ textAlign: 'center' }}>
																<Box sx={{ display: 'flex', justifyContent: 'center', gap: 1 }}>
																	{pub.status === 'draft' && (
																		<>
																			<IconButton
																				aria-label="edit"
																				onClick={() => handleEditClick(pub)}
																				sx={{
																					color: '#0071E3',
																					borderRadius: '8px',
																					'&:hover': {
																						color: '#FFFFFF',
																						backgroundColor: '#0071E3',
																						boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																					},
																				}}
																			>
																				<EditIcon />
																			</IconButton>
																			<IconButton
																				aria-label="delete"
																				onClick={() => handleDeleteClick(pub)}
																				sx={{
																					color: '#0071E3',
																					borderRadius: '8px',
																					'&:hover': {
																						color: '#FFFFFF',
																						backgroundColor: '#0071E3',
																						boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																					},
																				}}
																			>
																				<DeleteIcon />
																			</IconButton>
																			{pub.file_url && (
																				<IconButton
																					aria-label="submit-for-review"
																					onClick={() => handleSubmitForReview(pub.id)}
																					sx={{
																						color: 'green',
																						borderRadius: '8px',
																						'&:hover': {
																							color: '#FFFFFF',
																							backgroundColor: 'green',
																							boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																						},
																					}}
																				>
																					<PublishIcon />
																				</IconButton>
																			)}
																		</>
																	)}
																	{pub.file_url && pub.status !== 'draft' && (
																		<IconButton
																			aria-label="download"
																			onClick={() => handleDownloadClick(pub)}
																			sx={{
																				color: '#0071E3',
																				borderRadius: '8px',
																				'&:hover': {
																					color: '#FFFFFF',
																					backgroundColor: '#0071E3',
																					boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																				},
																			}}
																		>
																			<DownloadIcon />
																		</IconButton>
																	)}
																	{!pub.file_url && pub.status === 'draft' && (
																		<IconButton
																			aria-label="attach"
																			onClick={() => handleAttachFileClick(pub)}
																			sx={{
																				color: '#0071E3',
																				borderRadius: '8px',
																				'&:hover': {
																					color: '#FFFFFF',
																					backgroundColor: '#0071E3',
																					boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																				},
																			}}
																		>
																			<AttachFileIcon />
																		</IconButton>
																	)}
																</Box>
															</TableCell>
														</TableRow>
													))
												) : (
													<TableRow>
														<TableCell colSpan={7} sx={{ textAlign: 'center', color: '#6E6E73' }}>
															Нет доступных публикаций на этой странице.
														</TableCell>
													</TableRow>
												)}
											</TableBody>
										</Fade>
									</AppleTable>
									<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
										<Pagination
											count={totalPages}
											page={currentPage}
											onChange={handlePageChange}
											color="primary"
											sx={{
												'& .MuiPaginationItem-root': {
													borderRadius: 20,
													transition: 'all 0.3s ease',
													'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
													'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
												},
											}}
										/>
									</Box>
								</>
							)}

							{value === 2 && (
								<Box sx={{ mt: 4 }}>
									<Typography
										variant="h5"
										gutterBottom
										sx={{
											mt: 4,
											color: '#1D1D1F',
											fontWeight: 600,
											textAlign: 'center',
										}}
									>
										Аналитика публикаций
									</Typography>
									{analytics.length === 0 ? (
										<AppleCard elevation={2} sx={{ p: 4, mt: 2, borderRadius: '16px', backgroundColor: '#FFFFFF', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
											<Typography variant="body1" sx={{ color: '#6E6E73', textAlign: 'center' }}>
												У вас ещё нет ни одной публикации.{' '}
												<AppleButton
													variant="text"
													onClick={() => setUploadType('file')}
													sx={{
														p: 0.5,
														textTransform: 'none',
														color: '#0071E3',
														backgroundColor: 'transparent',
														'&:hover': { color: '#0066CC', backgroundColor: 'transparent' },
													}}
												>
													Загрузите публикации
												</AppleButton>
												, чтобы вести аналитику по своим работам.
											</Typography>
										</AppleCard>
									) : (
										<AppleCard elevation={2} sx={{ p: 4, mt: 2, borderRadius: '16px', backgroundColor: '#FFFFFF', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
											<CardContent>
												<Typography variant="h6" sx={{ color: '#1D1D1F', mb: 2 }}>
													Динамика публикаций
												</Typography>
												<Box sx={{ mb: 4, height: '300px' }}>
													<Line data={chartData} options={chartOptions} ref={chartRef} key={analytics.map((item) => item.year).join('-')} />
												</Box>

												<DetailsButton onClick={() => setShowDetailedAnalytics(!showDetailedAnalytics)} sx={{ mb: 2 }}>
													{showDetailedAnalytics ? 'Свернуть' : 'Подробнее'}
												</DetailsButton>

												<Collapse in={showDetailedAnalytics}>
													<>
														<Typography variant="h6" sx={{ color: '#1D1D1F', mb: 2 }}>
															Типы публикаций
														</Typography>
														<Grid container spacing={2} sx={{ mb: 4 }}>
															{Object.entries(pubTypes).map(([type, count]) => (
																<Grid item xs={12} sm={4} key={type}>
																	<AppleCard elevation={1} sx={{ p: 2, borderRadius: '12px', backgroundColor: '#FFFFFF', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}>
																		<CardContent>
																			<Typography variant="body1" sx={{ color: '#1D1D1F' }}>
																				{type === 'article' ? 'Статьи' : type === 'monograph' ? 'Монографии' : 'Доклады'}: {count}
																			</Typography>
																		</CardContent>
																	</AppleCard>
																</Grid>
															))}
														</Grid>

														<Typography variant="h6" sx={{ color: '#1D1D1F', mb: 2 }}>
															Статусы публикаций
														</Typography>
														<Grid container spacing={2} sx={{ mb: 4 }}>
															{Object.entries(pubStatuses).map(([status, count]) => (
																<Grid item xs={12} sm={4} key={status}>
																	<AppleCard elevation={1} sx={{ p: 2, borderRadius: '12px', backgroundColor: '#FFFFFF', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)' }}>
																		<CardContent>
																			<Typography variant="body1" sx={{ color: '#1D1D1F' }}>
																				{status === 'draft' ? 'Черновики' : status === 'needs_review' ? 'Нуждается в проверке' : 'Опубликованные'}: {count}
																			</Typography>
																		</CardContent>
																	</AppleCard>
																</Grid>
															))}
														</Grid>

														<Typography variant="h6" sx={{ color: '#1D1D1F', mb: 2 }}>
															Общая статистика
														</Typography>
														<Typography variant="body1" sx={{ color: '#6E6E73' }}>
															Всего публикаций: {analytics.reduce((sum, item) => sum + item.count, 0)}
															{totalCitations > 0 && ` | Общее количество цитирований: ${totalCitations}`}
														</Typography>
													</>
												</Collapse>
											</CardContent>
										</AppleCard>
									)}
								</Box>
							)}

							{value === 3 && (
								<>
									<Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
										<Typography
											variant="h5"
											sx={{
												color: '#1D1D1F',
												fontWeight: 600,
											}}
										>
											Ваши планы
										</Typography>
										<AppleButton
											startIcon={<AddIcon />}
											onClick={() => setOpenCreatePlanDialog(true)}
										>
											Создать план
										</AppleButton>
									</Box>

									{plans.map((plan) => {
										// Сортировка записей плана
										const sortedEntries = [...plan.entries].sort((a, b) => {
											// Сначала сортируем по наличию publication_id (с публикациями выше)
											if (a.publication_id && !b.publication_id) return -1;
											if (!a.publication_id && b.publication_id) return 1;
											// Если оба с publication_id или оба без, сортируем по времени создания (позже добавленные ниже)
											// Если нет created_at, используем порядок в массиве (предполагаем, что новые добавляются в конец)
											return (b.created_at || 0) - (a.created_at || 0); // Если created_at нет, используем 0
										});

										// Разделяем на утвержденные (до утверждения) и дополнительные (после утверждения)
										const preApprovalEntries = sortedEntries.filter(entry => !entry.isPostApproval);
										const postApprovalEntries = sortedEntries.filter(entry => entry.isPostApproval);

										return (
											<Accordion
												key={plan.id}
												sx={{
													mb: 2,
													borderRadius: '16px',
													boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
												}}
											>
												<AccordionSummary expandIcon={<ExpandMoreIcon />}>
													<Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
														<Typography variant="h6" sx={{ color: '#1D1D1F' }}>
															План на {plan.year} год (Ожидаемое количество: {plan.expectedCount} | Текущее количество: {plan.entries.length})
														</Typography>
														<Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
															<StatusChip status={plan.status} />
															{(plan.status === 'draft' || plan.status === 'returned') && (
																<>
																	<IconButton
																		onClick={(e) => {
																			e.stopPropagation();
																			handleEditPlanClick(plan.id);
																		}}
																		sx={{ color: '#0071E3' }}
																	>
																		<EditIcon />
																	</IconButton>
																	<IconButton
																		onClick={(e) => {
																			e.stopPropagation();
																			handleDeletePlanClick(plan);
																		}}
																		sx={{ color: '#FF3B30' }}
																	>
																		<DeleteIcon />
																	</IconButton>
																	<IconButton
																		onClick={(e) => {
																			e.stopPropagation();
																			handleSubmitPlanForReview(plan);
																		}}
																		sx={{ color: '#0071E3' }}
																		disabled={!areAllTitlesFilled(plan)}
																		title={areAllTitlesFilled(plan) ? 'Отправить на проверку' : 'Заполните все заголовки'}
																	>
																		<PublishIcon />
																	</IconButton>
																</>
															)}
														</Box>
													</Box>
												</AccordionSummary>
												<AccordionDetails>
													{editingPlanId === plan.id ? (
														<>
															<PlanTable>
																<TableHead>
																	<TableRow>
																		<TableCell>Название</TableCell>
																		<TableCell>Тип</TableCell>
																		<TableCell>Статус</TableCell>
																		<TableCell>Действия</TableCell>
																	</TableRow>
																</TableHead>
																<TableBody>
																	{plan.entries.map((entry, index) => (
																		<TableRow key={index}>
																			<TableCell>
																				<AppleTextField
																					value={entry.title}
																					onChange={(e) => handlePlanEntryChange(plan.id, index, 'title', e.target.value)}
																					fullWidth
																					variant="outlined"
																				/>
																			</TableCell>
																			<TableCell>
																				<AppleTextField
																					select
																					value={entry.type}
																					onChange={(e) => handlePlanEntryChange(plan.id, index, 'type', e.target.value)}
																					fullWidth
																					variant="outlined"
																				>
																					<MenuItem value="article">Статья</MenuItem>
																					<MenuItem value="monograph">Монография</MenuItem>
																					<MenuItem value="conference">Доклад/конференция</MenuItem>
																				</AppleTextField>
																			</TableCell>
																			<TableCell>
																				<StatusChip status={entry.status} />
																			</TableCell>
																			<TableCell>
																				<IconButton
																					onClick={() => handleDeletePlanEntry(plan.id, index)}
																					sx={{ color: '#FF3B30' }}
																				>
																					<DeleteIcon />
																				</IconButton>
																			</TableCell>
																		</TableRow>
																	))}
																</TableBody>
															</PlanTable>
															<Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
																<AppleButton
																	startIcon={<AddIcon />}
																	onClick={() => handleAddPlanEntry(plan.id)}
																>
																	Добавить запись
																</AppleButton>
																<GreenButton
																	startIcon={<SaveIcon />}
																	onClick={() => handleSavePlan(plan)}
																	disabled={!areAllTitlesFilled(plan)}
																>
																	Сохранить
																</GreenButton>
															</Box>
														</>
													) : (
														<>
															<Typography sx={{ mb: 1 }}>Прогресс выполнения:</Typography>
															<Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
																<LinearProgress
																	variant="determinate"
																	value={Math.min(calculateProgress(plan), 100)}
																	sx={{
																		height: 8,
																		borderRadius: 4,
																		flexGrow: 1,
																		backgroundColor: '#E5E5EA',
																		'& .MuiLinearProgress-bar': { backgroundColor: '#34C759' },
																	}}
																/>
																<Typography
																	variant="body2"
																	sx={{
																		minWidth: '50px',
																		textAlign: 'right',
																		color: calculateProgress(plan) > 100 ? '#FF9500' : '#1D1D1F',
																	}}
																>
																	{Math.round(calculateProgress(plan))}%
																</Typography>
															</Box>
															<PlanTable>
																<TableHead>
																	<TableRow>
																		<TableCell>Название</TableCell>
																		<TableCell>Тип</TableCell>
																		<TableCell>Статус</TableCell>
																		<TableCell>Привязанная публикация</TableCell>
																		{plan.status === 'approved' && <TableCell>Действия</TableCell>}
																	</TableRow>
																</TableHead>
																<TableBody>
																	{/* Утверждённые работы (до утверждения плана) */}
																	{preApprovalEntries.map((entry) => (
																		<TableRow key={entry.id}>
																			<TableCell>{entry.title}</TableCell>
																			<TableCell>{entry.type}</TableCell>
																			<TableCell><StatusChip status={entry.status} /></TableCell>
																			<TableCell>
																				{entry.publication_id ? (
																					<Typography
																						sx={{
																							color: '#0071E3',
																							textDecoration: 'underline',
																							cursor: 'pointer',
																							'&:hover': { textDecoration: 'none' },
																						}}
																						onClick={() => navigate(`/publication/${entry.publication_id}`)}
																					>
																						{publishedPublications.find(pub => pub.id === entry.publication_id)?.title || 'Неизвестно'}
																					</Typography>
																				) : (
																					'Не привязана'
																				)}
																			</TableCell>
																			{plan.status === 'approved' && (
																				<TableCell>
																					{entry.publication_id ? (
																						<IconButton
																							onClick={() => handleUnlinkPublication(plan.id, entry.id)}
																							sx={{ color: '#FF3B30' }}
																							title="Отвязать публикацию"
																						>
																							<UnlinkIcon />
																						</IconButton>
																					) : (
																						<IconButton
																							onClick={() => handleOpenLinkDialog(plan.id, entry)}
																							sx={{ color: '#0071E3' }}
																							title="Привязать публикацию"
																						>
																							<LinkIcon />
																						</IconButton>
																					)}
																				</TableCell>
																			)}
																		</TableRow>
																	))}
																	{/* Дополнительные работы (после утверждения) */}
																	{postApprovalEntries.length > 0 && (
																		<TableRow>
																			<TableCell colSpan={5} sx={{ fontWeight: 600, color: '#6E6E73', padding: '16px 20px' }}>
																				Дополнительные работы (добавлены после утверждения)
																			</TableCell>
																		</TableRow>
																	)}
																	{postApprovalEntries.map((entry) => (
																		<TableRow key={entry.id}>
																			<TableCell>{entry.title}</TableCell>
																			<TableCell>{entry.type}</TableCell>
																			<TableCell><StatusChip status={entry.status} /></TableCell>
																			<TableCell>
																				{entry.publication_id ? (
																					<Typography
																						sx={{
																							color: '#0071E3',
																							textDecoration: 'underline',
																							cursor: 'pointer',
																							'&:hover': { textDecoration: 'none' },
																						}}
																						onClick={() => navigate(`/publication/${entry.publication_id}`)}
																					>
																						{publishedPublications.find(pub => pub.id === entry.publication_id)?.title || 'Неизвестно'}
																					</Typography>
																				) : (
																					'Не привязана'
																				)}
																			</TableCell>
																			{plan.status === 'approved' && (
																				<TableCell>
																					{entry.publication_id ? (
																						<IconButton
																							onClick={() => handleUnlinkPublication(plan.id, entry.id)}
																							sx={{ color: '#FF3B30' }}
																							title="Отвязать публикацию"
																						>
																							<UnlinkIcon />
																						</IconButton>
																					) : (
																						<IconButton
																							onClick={() => handleOpenLinkDialog(plan.id, entry)}
																							sx={{ color: '#0071E3' }}
																							title="Привязать публикацию"
																						>
																							<LinkIcon />
																						</IconButton>
																					)}
																				</TableCell>
																			)}
																		</TableRow>
																	))}
																</TableBody>
															</PlanTable>
															{plan.status === 'approved' && (
																<AppleButton
																	startIcon={<AddIcon />}
																	onClick={() => handleEditPlanClick(plan.id)}
																	sx={{ mt: 2 }}
																>
																	Добавить запись
																</AppleButton>
															)}
															{plan.return_comment && plan.status !== 'approved' && (
																<Typography
																	sx={{
																		mt: 2,
																		color: '#000000',
																		fontWeight: 600,
																		display: 'flex',
																		alignItems: 'center',
																		gap: 1,
																	}}
																>
																	<WarningAmberIcon sx={{ color: '#FF3B30' }} />
																	Комментарий при возврате: {plan.return_comment}
																</Typography>
															)}
														</>
													)}
												</AccordionDetails>
											</Accordion>
										);
									})}

									<Pagination
										count={planTotalPages}
										page={planPage}
										onChange={handlePlanPageChange}
										sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}
									/>
								</>
							)}

							{value === 4 && (
								<Box sx={{ mt: 4 }}>
									<Typography
										variant="h5"
										gutterBottom
										sx={{
											mt: 4,
											color: '#1D1D1F',
											fontWeight: 600,
											textAlign: 'center',
										}}
									>
										Экспорт публикаций
									</Typography>
									<AppleCard sx={{ p: 4, borderRadius: '16px', backgroundColor: '#FFFFFF', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
										<CardContent>
											<Typography variant="body1" sx={{ color: '#6E6E73', mb: 2 }}>
												Вы можете экспортировать свои публикации в формате BibTeX.
											</Typography>
											<AppleButton onClick={handleExportBibTeX}>Экспортировать в BibTeX</AppleButton>
										</CardContent>
									</AppleCard>
								</Box>
							)}
						</>
					)}
				</CardContent>
			</AppleCard>

			{/* Диалог редактирования пользователя */}
			<Dialog
				open={openEditUserDialog}
				onClose={handleEditUserCancel}
				maxWidth="sm"
				fullWidth
				PaperProps={{
					sx: {
						borderRadius: '16px',
						boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
						backgroundColor: '#FFFFFF',
					},
				}}
			>
				<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600 }}>Редактировать личные данные</DialogTitle>
				<DialogContent>
					<form onSubmit={handleEditUserSubmit}>
						<AppleTextField
							fullWidth
							label="Фамилия"
							value={editLastName}
							onChange={(e) => setEditLastName(e.target.value)}
							margin="normal"
							variant="outlined"
						/>
						<AppleTextField
							fullWidth
							label="Имя"
							value={editFirstName}
							onChange={(e) => setEditFirstName(e.target.value)}
							margin="normal"
							variant="outlined"
						/>
						<AppleTextField
							fullWidth
							label="Отчество"
							value={editMiddleName}
							onChange={(e) => setEditMiddleName(e.target.value)}
							margin="normal"
							variant="outlined"
						/>
					</form>
				</DialogContent>
				<DialogActions sx={{ p: 2 }}>
					<CancelButton onClick={handleEditUserCancel}>Отмена</CancelButton>
					<AppleButton onClick={handleEditUserSubmit}>Сохранить</AppleButton>
				</DialogActions>
			</Dialog>

			{/* Диалог изменения пароля */}
			<Dialog
				open={openChangePasswordDialog}
				onClose={handleChangePasswordCancel}
				maxWidth="sm"
				fullWidth
				PaperProps={{
					sx: {
						borderRadius: '16px',
						boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
						backgroundColor: '#FFFFFF',
					},
				}}
			>
				<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600 }}>Изменить пароль</DialogTitle>
				<DialogContent>
					<form onSubmit={handleChangePasswordSubmit}>
						<AppleTextField
							fullWidth
							label="Текущий пароль"
							type={showCurrentPassword ? 'text' : 'password'}
							value={currentPassword}
							onChange={(e) => setCurrentPassword(e.target.value)}
							margin="normal"
							variant="outlined"
							InputProps={{
								endAdornment: (
									<IconButton onClick={handleToggleCurrentPasswordVisibility} sx={{ color: '#0071E3' }}>
										{showCurrentPassword ? <VisibilityOff /> : <Visibility />}
									</IconButton>
								),
							}}
						/>
						<AppleTextField
							fullWidth
							label="Новый пароль"
							type={showNewPassword ? 'text' : 'password'}
							value={newPassword}
							onChange={(e) => setNewPassword(e.target.value)}
							margin="normal"
							variant="outlined"
							InputProps={{
								endAdornment: (
									<IconButton onClick={handleToggleNewPasswordVisibility} sx={{ color: '#0071E3' }}>
										{showNewPassword ? <VisibilityOff /> : <Visibility />}
									</IconButton>
								),
							}}
						/>
					</form>
				</DialogContent>
				<DialogActions sx={{ p: 2 }}>
					<CancelButton onClick={handleChangePasswordCancel}>Отмена</CancelButton>
					<AppleButton onClick={handleChangePasswordSubmit}>Сохранить</AppleButton>
				</DialogActions>
			</Dialog>

			{/* Диалог редактирования публикации */}
			<Dialog
				open={openEditDialog}
				onClose={handleEditCancel}
				maxWidth="sm"
				fullWidth
				PaperProps={{
					sx: {
						borderRadius: '16px',
						boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
						backgroundColor: '#FFFFFF',
					},
				}}
			>
				<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600 }}>Редактировать публикацию</DialogTitle>
				<DialogContent>
					<form onSubmit={handleEditSubmit}>
						<AppleTextField
							fullWidth
							label="Название"
							value={editTitle}
							onChange={(e) => setEditTitle(e.target.value)}
							margin="normal"
							variant="outlined"
						/>
						<AppleTextField
							fullWidth
							label="Авторы"
							value={editAuthors}
							onChange={(e) => setEditAuthors(e.target.value)}
							margin="normal"
							variant="outlined"
						/>
						<AppleTextField
							fullWidth
							label="Год"
							type="number"
							value={editYear}
							onChange={(e) => setEditYear(e.target.value)}
							margin="normal"
							variant="outlined"
						/>
						<AppleTextField
							fullWidth
							select
							label="Тип публикации"
							value={editType}
							onChange={(e) => setEditType(e.target.value)}
							margin="normal"
							variant="outlined"
						>
							<MenuItem value="article">Статья</MenuItem>
							<MenuItem value="monograph">Монография</MenuItem>
							<MenuItem value="conference">Доклад/конференция</MenuItem>
						</AppleTextField>
						<Box sx={{ mt: 2 }}>
							<input
								type="file"
								accept=".pdf,.docx"
								onChange={(e) => setEditFile(e.target.files[0])}
								style={{ display: 'none' }}
								id="edit-file"
							/>
							<label htmlFor="edit-file">
								<AppleButton sx={{ border: '1px solid #D1D1D6', backgroundColor: '#F5F5F7', color: '#1D1D1F' }} component="span">
									Выбрать файл
								</AppleButton>
							</label>
							{editFile && <Typography sx={{ mt: 1, color: '#6E6E73' }}>{editFile.name}</Typography>}
						</Box>
						<Collapse in={openError}>
							{error && (
								<Alert
									severity="error"
									sx={{
										mt: 2,
										borderRadius: '12px',
										backgroundColor: '#FFF1F0',
										color: '#1D1D1F',
										boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
									}}
									onClose={() => setOpenError(false)}
								>
									{error}
								</Alert>
							)}
						</Collapse>
						<Collapse in={openSuccess}>
							{success && (
								<Alert
									severity="success"
									sx={{
										mt: 2,
										borderRadius: '12px',
										backgroundColor: '#E7F8E7',
										color: '#1D1D1F',
										boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
									}}
									onClose={() => setOpenSuccess(false)}
								>
									{success}
								</Alert>
							)}
						</Collapse>
					</form>
				</DialogContent>
				<DialogActions sx={{ p: 2 }}>
					<CancelButton onClick={handleEditCancel}>Отмена</CancelButton>
					<AppleButton onClick={handleEditSubmit}>Сохранить</AppleButton>
					{editPublication?.file_url && (
						<GreenButton onClick={handleSaveAndSubmitForReview}>Сохранить и отправить на проверку</GreenButton>
					)}
				</DialogActions>
			</Dialog>

			{/* Диалог прикрепления файла */}
			<Dialog
				open={openAttachFileDialog}
				onClose={handleAttachFileCancel}
				maxWidth="sm"
				fullWidth
				PaperProps={{
					sx: {
						borderRadius: '16px',
						boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
						backgroundColor: '#FFFFFF',
					},
				}}
			>
				<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600 }}>Прикрепить файл</DialogTitle>
				<DialogContent>
					<form onSubmit={handleAttachFileSubmit}>
						<Box sx={{ mt: 2 }}>
							<input
								type="file"
								accept=".pdf,.docx"
								onChange={(e) => setAttachFile(e.target.files[0])}
								style={{ display: 'none' }}
								id="attach-file"
							/>
							<label htmlFor="attach-file">
								<AppleButton sx={{ border: '1px solid #D1D1D6', backgroundColor: '#F5F5F7', color: '#1D1D1F' }} component="span">
									Выбрать файл
								</AppleButton>
							</label>
							{attachFile && <Typography sx={{ mt: 1, color: '#6E6E73' }}>{attachFile.name}</Typography>}
						</Box>
						<Collapse in={attachError !== ''}>
							<Alert
								severity="error"
								sx={{
									mt: 2,
									borderRadius: '12px',
									backgroundColor: '#FFF1F0',
									color: '#1D1D1F',
									boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
								}}
							>
								{attachError}
							</Alert>
						</Collapse>
						<Collapse in={attachSuccess !== ''}>
							<Alert
								severity="success"
								sx={{
									mt: 2,
									borderRadius: '12px',
									backgroundColor: '#E7F8E7',
									color: '#1D1D1F',
									boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
								}}
							>
								{attachSuccess}
							</Alert>
						</Collapse>
					</form>
				</DialogContent>
				<DialogActions sx={{ p: 2 }}>
					<CancelButton onClick={handleAttachFileCancel}>Отмена</CancelButton>
					<AppleButton onClick={handleAttachFileSubmit}>Прикрепить</AppleButton>
				</DialogActions>
			</Dialog>

			{/* Диалог удаления публикации или плана */}
			<Dialog
				open={openDeleteDialog}
				onClose={handleDeleteCancel}
				maxWidth="sm"
				fullWidth
				PaperProps={{
					sx: {
						borderRadius: '16px',
						boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
						backgroundColor: '#FFFFFF',
					},
				}}
			>
				<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600 }}>Подтверждение удаления</DialogTitle>
				<DialogContent>
					<Typography sx={{ color: '#1D1D1F' }}>
						Вы уверены, что хотите удалить {publicationToDelete?.title || planToDelete?.title || 'этот объект'}?
					</Typography>
				</DialogContent>
				<DialogActions sx={{ p: 2 }}>
					<CancelButton onClick={handleDeleteCancel}>Отмена</CancelButton>
					<AppleButton
						onClick={publicationToDelete ? handleDeleteConfirm : planToDelete ? handleDeletePlanConfirm : () => { }}
						sx={{ backgroundColor: '#FF3B30', '&:hover': { backgroundColor: '#FF2D1A' } }}
						disabled={!publicationToDelete && !planToDelete}
					>
						Удалить
					</AppleButton>
				</DialogActions>
			</Dialog>

			{/* Диалог создания плана */}
			<Dialog
				open={openCreatePlanDialog}
				onClose={() => setOpenCreatePlanDialog(false)}
				sx={{ '& .MuiDialog-paper': { borderRadius: '16px', p: 2 } }}
			>
				<DialogTitle>Создать новый план</DialogTitle>
				<DialogContent>
					<AppleTextField
						label="Год"
						type="number"
						value={newPlan.year}
						onChange={(e) => setNewPlan({ ...newPlan, year: parseInt(e.target.value) || '' })}
						fullWidth
						margin="normal"
						variant="outlined"
					/>
					<AppleTextField
						label="Ожидаемое количество публикаций"
						type="number"
						value={newPlan.expectedCount}
						onChange={(e) => setNewPlan({ ...newPlan, expectedCount: parseInt(e.target.value) || 1 })}
						fullWidth
						margin="normal"
						variant="outlined"
					/>
				</DialogContent>
				<DialogActions>
					<CancelButton onClick={() => setOpenCreatePlanDialog(false)}>Отмена</CancelButton>
					<AppleButton onClick={handleCreatePlan}>Создать</AppleButton>
				</DialogActions>
			</Dialog>
			<Dialog
				open={linkDialogOpen}
				onClose={() => setLinkDialogOpen(false)}
				sx={{ '& .MuiDialog-paper': { borderRadius: '16px', p: 2, minWidth: '500px' } }}
			>
				<DialogTitle>Привязать публикацию</DialogTitle>
				<DialogContent>
					<AppleTextField
						fullWidth
						label="Поиск публикации"
						value={linkSearchQuery}
						onChange={(e) => handleLinkSearch(e.target.value)}
						margin="normal"
						variant="outlined"
					/>
					<Table>
						<TableHead>
							<TableRow>
								<TableCell>Название</TableCell>
								<TableCell>Авторы</TableCell>
								<TableCell>Действия</TableCell>
							</TableRow>
						</TableHead>
						<TableBody>
							{filteredPublishedPublications.map((pub) => (
								<TableRow key={pub.id}>
									<TableCell>{pub.title}</TableCell>
									<TableCell>{pub.authors}</TableCell>
									<TableCell>
										<AppleButton
											onClick={() => handleLinkPublication(selectedPlanEntry.planId, selectedPlanEntry.id, pub.id)}
										>
											Привязать
										</AppleButton>
									</TableCell>
								</TableRow>
							))}
						</TableBody>
					</Table>
				</DialogContent>
				<DialogActions>
					<CancelButton onClick={() => setLinkDialogOpen(false)}>Отмена</CancelButton>
				</DialogActions>
			</Dialog>
		</Container>
	);
}

export default Dashboard;
----------------
D:\publication-system\frontend\src\components\Footer.js
import React from 'react';
import { Container, Typography, Link, Grid, Box } from '@mui/material';
import FacebookIcon from '@mui/icons-material/Facebook';
import TwitterIcon from '@mui/icons-material/Twitter';
import InstagramIcon from '@mui/icons-material/Instagram';

function Footer() {
  return (
    <Box sx={{ backgroundColor: '#f5f5f5', py: 4, mt: 8 }}>
      <Container maxWidth="lg">
        <Grid container spacing={4}>
          <Grid item xs={12} sm={4}>
            <Typography variant="h6" gutterBottom sx={{ color: '#1976D2' }}>
              Система Публикаций
            </Typography>
            <Typography variant="body2" sx={{ color: '#757575' }}>
              Эффективно управляйте научными публикациями.
            </Typography>
          </Grid>
          <Grid item xs={12} sm={4}>
            <Typography variant="h6" gutterBottom sx={{ color: '#1976D2' }}>
              Ссылки
            </Typography>
            <Link href="#" color="#757575" sx={{ display: 'block', mb: 1 }}>
              О нас
            </Link>
            <Link href="#" color="#757575" sx={{ display: 'block', mb: 1 }}>
              Поддержка
            </Link>
            <Link href="#" color="#757575" sx={{ display: 'block', mb: 1 }}>
              Конфиденциальность
            </Link>
          </Grid>
          <Grid item xs={12} sm={4}>
            <Typography variant="h6" gutterBottom sx={{ color: '#1976D2' }}>
              Следите за нами
            </Typography>
            <Box sx={{ display: 'flex', gap: 2 }}>
              <Link href="#" color="#757575">
                <FacebookIcon />
              </Link>
              <Link href="#" color="#757575">
                <TwitterIcon />
              </Link>
              <Link href="#" color="#757575">
                <InstagramIcon />
              </Link>
            </Box>
          </Grid>
        </Grid>
        <Typography variant="body2" align="center" sx={{ mt: 4, color: '#757575' }}>
          © 2025 Система Публикаций. Все права защищены.
        </Typography>
      </Container>
    </Box>
  );
}

export default React.memo(Footer); // Сохраняем React.memo для оптимизации

-----------------
D:\publication-system\frontend\src\components\Header.js
import React from 'react';
import { AppBar, Toolbar, Typography, Button, Box } from '@mui/material';
import { Link, useNavigate } from 'react-router-dom';
import { styled } from '@mui/system';
import { useAuth } from '../contexts/AuthContext';
import logoPng from '../assets/logo_kai.png';

const StyledAppBar = styled(AppBar)({
	backgroundColor: 'white',
	boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
	transition: 'all 0.3s ease',
	'&:hover': {
		boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
	},
});

const Logo = styled('img')({
	height: '60px',
	marginLeft: '16px',
	transition: 'all 0.3s ease',
	'&:hover': {
		transform: 'scale(1.05)',
	},
});

function Header() {
	const { isAuthenticated, role, isLoading, logout } = useAuth();
	const navigate = useNavigate();

	// Используем role из localStorage как запасное значение, пока состояние не загрузится
	const storedUser = localStorage.getItem('user');
	const parsedUser = storedUser ? JSON.parse(storedUser) : null;
	const effectiveRole = role || parsedUser?.role || 'user';

	console.log('Header.js: isAuthenticated:', isAuthenticated, 'Role:', role, 'Effective Role:', effectiveRole, 'isLoading:', isLoading);

	const handleLogout = async () => {
		try {
			await logout();
			navigate('/login', { replace: true });
		} catch (err) {
			console.error('Header.js: Ошибка при выходе:', err);
		}
	};

	if (isLoading) {
		return null;
	}

	// Определяем маршрут и текст кнопки в зависимости от роли
	let dashboardPath = '/dashboard';
	let dashboardLabel = 'Личный кабинет';
	if (effectiveRole === 'admin') {
		dashboardPath = '/admin';
		dashboardLabel = 'Панель администратора';
	} else if (effectiveRole === 'manager') {
		dashboardPath = '/manager';
		dashboardLabel = 'Панель управляющего';
	}

	return (
		<StyledAppBar position="fixed">
			<Toolbar sx={{ justifyContent: 'space-between', alignItems: 'center' }}>
				<Box sx={{ display: 'flex', alignItems: 'center' }}>
					<Typography
						variant="h6"
						component={Link}
						to="/"
						sx={{
							color: '#115293',
							textDecoration: 'none',
							'&:hover': { textDecoration: 'underline' },
							mr: 2,
							transition: 'all 0.3s ease',
							fontWeight: '700',
							fontSize: '1.5rem',
						}}
					>
						Система Публикаций
					</Typography>
					<Logo src={logoPng} alt="КАИ Logo" />
				</Box>
				<Box sx={{ display: 'flex', gap: 2 }}>
					{!isAuthenticated ? (
						<Button
							component={Link}
							to="/login"
							variant="contained"
							color="primary"
							sx={{
								borderRadius: 16,
								transition: 'all 0.3s ease',
								'&:hover': { transform: 'scale(1.05)', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)' },
							}}
						>
							Войти
						</Button>
					) : (
						<>
							<Button
								component={Link}
								to={dashboardPath}
								variant="contained"
								color="primary"
								sx={{
									borderRadius: 16,
									transition: 'all 0.3s ease',
									'&:hover': { transform: 'scale(1.05)', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)' },
								}}
							>
								{dashboardLabel}
							</Button>
							<Button
								onClick={handleLogout}
								variant="contained"
								color="primary"
								sx={{
									borderRadius: 16,
									transition: 'all 0.3s ease',
									'&:hover': { transform: 'scale(1.05)', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)' },
								}}
							>
								Выйти
							</Button>
						</>
					)}
				</Box>
			</Toolbar>
		</StyledAppBar>
	);
}

export default Header;
---------------
D:\publication-system\frontend\src\components\Home.js
import React, { useState, useEffect, useMemo } from 'react';
import {
	Container,
	Typography,
	TextField,
	Box,
	Grid,
	Card,
	Button,
	Select,
	MenuItem,
	FormControl,
	InputLabel,
	IconButton,
	Alert,
	Collapse,
	List,
	ListItem,
	ListItemText,
	Pagination,
} from '@mui/material';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';
import SearchIcon from '@mui/icons-material/Search';
import { styled } from '@mui/system';

const SearchInput = styled(TextField)({
	'& .MuiInputBase-root': {
		borderRadius: 16,
		height: '48px',
		width: '100%',
		boxShadow: '0 2px 8px rgba(0, 0, 0, 0.05)',
	},
	'& .MuiInputBase-input': {
		padding: '8px 16px',
		fontSize: '16px',
	},
	'&:hover': {
		boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
		transition: 'all 0.3s ease',
	},
});

function Home() {
	const [searchTerm, setSearchTerm] = useState('');
	const [filterType, setFilterType] = useState('');
	const [filterYear, setFilterYear] = useState('');
	const [publications, setPublications] = useState([]);
	const [allPublications, setAllPublications] = useState([]);
	const [filteredPublications, setFilteredPublications] = useState([]);
	const [error, setError] = useState('');
	const [success, setSuccess] = useState('');
	const [openError, setOpenError] = useState(false);
	const [openSuccess, setOpenSuccess] = useState(false);
	const [currentPage, setCurrentPage] = useState(1);
	const [totalPages, setTotalPages] = useState(1);
	const publicationsPerPage = 10;
	const navigate = useNavigate();

	const formatTimeAgo = (dateStr) => {
		if (!dateStr) return 'Неизвестное время';

		const date = new Date(dateStr);
		const now = new Date();
		const diffMs = now - date;
		const diffMinutes = Math.floor(diffMs / 60000);
		const diffHours = Math.floor(diffMs / 3600000);
		const diffDays = Math.floor(diffMs / 86400000);

		if (diffMinutes < 60) {
			if (diffMinutes === 1) return '1 минуту назад';
			if (diffMinutes >= 2 && diffMinutes <= 4) return `${diffMinutes} минуты назад`;
			if (diffMinutes >= 5 && diffMinutes <= 20) return `${diffMinutes} минут назад`;
			if (diffMinutes % 10 === 1 && diffMinutes !== 11) return `${diffMinutes} минуту назад`;
			if (diffMinutes % 10 >= 2 && diffMinutes % 10 <= 4 && (diffMinutes < 10 || diffMinutes > 20))
				return `${diffMinutes} минуты назад`;
			return `${diffMinutes} минут назад`;
		}

		if (diffHours < 24) {
			if (diffHours === 1) return '1 час назад';
			if (diffHours >= 2 && diffHours <= 4) return `${diffHours} часа назад`;
			return `${diffHours} часов назад`;
		}

		if (diffDays === 1) return '1 день назад';
		return `${diffDays} дней назад`;
	};

	useEffect(() => {
		const fetchPublishedPublications = async (page = 1) => {
			try {
				const response = await axios.get('http://localhost:5000/api/public/publications', {
					withCredentials: true,
					params: {
						page: 1,
						per_page: 9999,
						search: searchTerm,
						type: filterType || undefined,
						year: filterYear || undefined,
					},
				});
				console.log('Server response for all publications:', response.data);
				setAllPublications(response.data.publications || []);
				setPublications(response.data.publications || []);
				const total = response.data.total || response.data.publications.length;
				setTotalPages(Math.ceil(total / publicationsPerPage));
			} catch (err) {
				console.error('Ошибка загрузки публикаций:', err);
				setError('Произошла ошибка при загрузке данных. Попробуйте позже.');
				setOpenError(true);
			}
		};

		fetchPublishedPublications();
	}, [searchTerm, filterType, filterYear]);

	const filteredPublicationsMemo = useMemo(() => {
		return allPublications.filter(
			(pub) =>
				(pub.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
					pub.authors.toLowerCase().includes(searchTerm.toLowerCase())) &&
				(!filterType || pub.type === filterType) &&
				(!filterYear || pub.year.toString() === filterYear)
		);
	}, [searchTerm, filterType, filterYear, allPublications]);

	useEffect(() => {
		setTotalPages(Math.ceil(filteredPublicationsMemo.length / publicationsPerPage));
	}, [filteredPublicationsMemo]);

	const paginatedPublications = useMemo(() => {
		const startIndex = (currentPage - 1) * publicationsPerPage;
		const endIndex = startIndex + publicationsPerPage;
		return filteredPublicationsMemo.slice(startIndex, endIndex);
	}, [currentPage, filteredPublicationsMemo]);

	const handlePageChange = (event, newPage) => {
		setCurrentPage(newPage);
	};

	const handleFilterChange = () => {
		setCurrentPage(1);
	};

	return (
		<Container maxWidth="lg" sx={{ mt: 4, minHeight: 'calc(100vh - 64px)', backgroundColor: 'white', borderRadius: 20, boxShadow: '0 12px 32px rgba(0, 0, 0, 0.15)' }}>
			<Box sx={{ p: 4 }}>
				<Typography variant="h2" gutterBottom sx={{ color: '#212121', fontWeight: 700, textAlign: 'center', mb: 2 }}>
					Добро пожаловать в Систему Публикаций
				</Typography>
				<Typography variant="body1" sx={{ color: '#757575', textAlign: 'center', mb: 4 }}>
					Эффективно управляйте научными публикациями и отслеживайте академическую активность.
				</Typography>

				<Box sx={{ mb: 4, p: 3, backgroundColor: 'grey.50', borderRadius: 16, boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
					<SearchInput
						fullWidth
						label="Поиск научных работ"
						value={searchTerm}
						onChange={(e) => setSearchTerm(e.target.value)}
						variant="outlined"
						InputProps={{
							endAdornment: (
								<IconButton sx={{ color: '#1976D2', transition: 'all 0.3s ease', '&:hover': { transform: 'scale(1.1)', boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)' } }}>
									<SearchIcon />
								</IconButton>
							),
						}}
						sx={{ mb: 2 }}
					/>

					<Grid container spacing={2} sx={{ mb: 2 }}>
						<Grid item xs={12} sm={4}>
							<FormControl fullWidth variant="outlined" sx={{ borderRadius: 16, boxShadow: '0 2px 8px rgba(0, 0, 0, 0.05)' }}>
								<InputLabel>Тип</InputLabel>
								<Select
									value={filterType}
									onChange={(e) => setFilterType(e.target.value)}
									label="Тип"
									sx={{ borderRadius: 16, '&:hover': { boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' } }}
								>
									<MenuItem value="">Все</MenuItem>
									<MenuItem value="article">Статья</MenuItem>
									<MenuItem value="monograph">Монография</MenuItem>
									<MenuItem value="conference">Доклад/конференция</MenuItem>
								</Select>
							</FormControl>
						</Grid>
						<Grid item xs={12} sm={4}>
							<FormControl fullWidth variant="outlined" sx={{ borderRadius: 16, bgcolor: 'grey.100', boxShadow: '0 2px 8px rgba(0, 0, 0, 0.05)' }}>
								<InputLabel>Статус</InputLabel>
								<Select
									value="published"
									disabled
									label="Статус"
									sx={{ borderRadius: 16, '& .MuiSelect-select': { color: '#212121' }, '&:hover': { boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' } }}
								>
									<MenuItem value="published">Опубликовано</MenuItem>
								</Select>
							</FormControl>
						</Grid>
						<Grid item xs={12} sm={4}>
							<TextField
								fullWidth
								label="Год"
								type="number"
								value={filterYear}
								onChange={(e) => setFilterYear(e.target.value)}
								variant="outlined"
								sx={{ boxShadow: '0 2px 8px rgba(0, 0, 0, 0.05)', borderRadius: 16, '&:hover': { boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' } }}
							/>
						</Grid>
						<Grid item xs={12}>
							<Button
								variant="contained"
								color="primary"
								onClick={handleFilterChange}
								sx={{ mt: 2, borderRadius: 16, transition: 'all 0.3s ease', '&:hover': { transform: 'scale(1.05)', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' } }}
							>
								Применить фильтры
							</Button>
						</Grid>
					</Grid>
				</Box>

				<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#212121', fontWeight: 600, textAlign: 'center' }}>
					Последние опубликованные работы
				</Typography>
				<Card sx={{ mt: 2, mb: 4, borderRadius: 20, boxShadow: '0 12px 32px rgba(0, 0, 0, 0.15)', backgroundColor: 'white' }}>
					{paginatedPublications.length === 0 ? (
						<Box sx={{ p: 3, textAlign: 'center', color: '#757575' }}>
							<Typography variant="h6" sx={{ fontWeight: 500 }}>
								Увы, ничего не нашлось
							</Typography>
						</Box>
					) : (
						<List sx={{ width: '100%', backgroundColor: 'white', p: 3 }}>
							{paginatedPublications.map((pub) => (
								<ListItem
									key={pub.id}
									sx={{
										borderRadius: 5,
										padding: 3,
										borderBottom: '1px solid',
										borderColor: '#e0e0e0',
										'&:hover': { backgroundColor: 'grey.50', transition: 'all 0.3s ease', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
									}}
								>
									<ListItemText
										primary={
											<Typography variant="h6" sx={{ color: '#1976D2', fontWeight: 500 }}>
												{pub.title}
											</Typography>
										}
										secondary={
											<React.Fragment>
												<Typography variant="body2" component="span" sx={{ color: '#757575', display: 'block', mt: 0.5 }}>
													Год: {pub.year}
												</Typography>
												<Typography variant="body2" component="span" sx={{ color: '#757575', display: 'block', mt: 0.5 }}>
													Автор: {pub.authors}
												</Typography>
												<Typography variant="body2" component="span" sx={{ color: '#757575', display: 'block', mt: 0.5 }}>
													Опубликовал: {pub.user?.full_name || 'Не указан'}
												</Typography>
												<Typography variant="body2" component="span" sx={{ color: '#757575', display: 'block', mt: 0.5 }}>
													Опубликовано: {formatTimeAgo(pub.published_at || pub.updated_at)}
												</Typography>
											</React.Fragment>
										}
									/>
								</ListItem>
							))}
						</List>
					)}
				</Card>

				{filteredPublicationsMemo.length > 0 && (
					<Box sx={{ display: 'flex', justifyContent: 'center', mt: 4, mb: 4 }}>
						<Pagination
							count={totalPages}
							page={currentPage}
							onChange={handlePageChange}
							color="primary"
							sx={{
								'& .MuiPaginationItem-root': {
									borderRadius: 20,
									transition: 'all 0.3s ease',
									'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
									'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
								},
							}}
						/>
					</Box>
				)}

				<Collapse in={openError}>
					{error && (
						<Alert severity="error" sx={{ mt: 2, borderRadius: 20, boxShadow: '0 6px 16px rgba(0, 0, 0, 0.15)' }} onClose={() => setOpenError(false)}>
							{error}
						</Alert>
					)}
				</Collapse>
				<Collapse in={openSuccess}>
					{success && (
						<Alert severity="success" sx={{ mt: 2, borderRadius: 20, boxShadow: '0 6px 16px rgba(0, 0, 0, 0.15)' }} onClose={() => setOpenSuccess(false)}>
							{success}
						</Alert>
					)}
				</Collapse>
			</Box>
		</Container>
	);
}

export default Home;
----------
D:\publication-system\frontend\src\components\Layout.js
import React from 'react';
import { Outlet, useNavigate } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import Header from './Header';
import Footer from './Footer';
import axios from 'axios';
import { useAuth } from '../contexts/AuthContext';

function Layout() {
	const navigate = useNavigate();
	const { isAuthenticated, isLoading, logout, csrfToken, setCsrfToken } = useAuth();

	console.log('Layout.js: Рендеринг, isAuthenticated:', isAuthenticated, 'isLoading:', isLoading);

	const handleLogout = async () => {
		try {
			let token = csrfToken;
			if (!token) {
				const tokenResponse = await axios.get('http://localhost:5000/api/csrf-token', {
					withCredentials: true,
				});
				token = tokenResponse.data.csrf_token;
				setCsrfToken(token);
				console.log('Layout.js: CSRF Token получен перед выходом:', token);
			}

			await axios.post('http://localhost:5000/api/logout', {}, {
				withCredentials: true,
				headers: {
					'X-CSRFToken': token,
				},
			});

			console.log('Layout.js: Успешный выход, вызываем logout...');
			logout();
			navigate('/login', { replace: true });
		} catch (err) {
			console.error('Layout.js: Ошибка выхода:', err);
			logout();
			navigate('/login', { replace: true });
		}
	};

	if (isLoading) {
		console.log('Layout.js: Ожидание проверки аутентификации...');
		return <div>Загрузка...</div>;
	}

	return (
		<Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
			<CssBaseline />
			<Header /> {/* Убираем передачу isAuthenticated и onLogout */}
			<Box component="main" sx={{ flexGrow: 1, p: 3, mt: '64px' }}>
				<Outlet />
			</Box>
			<Footer />
		</Box>
	);
}

export default Layout;
--------------
D:\publication-system\frontend\src\components\Login.js
import React, { useState } from 'react';
import { TextField, Button, Container, Typography, Box, Card, CardContent, Alert } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import axios from 'axios';

function Login() {
	const [username, setUsername] = useState('');
	const [password, setPassword] = useState('');
	const [error, setError] = useState('');
	const [isLoading, setIsLoading] = useState(false);
	const navigate = useNavigate();
	const { login, setCsrfToken } = useAuth(); // Убираем updateAuthState

	const handleSubmit = async (e) => {
		e.preventDefault();
		if (isLoading) return;
		setIsLoading(true);
		setError('');

		try {
			const response = await axios.post('http://localhost:5000/api/login', {
				username,
				password,
			}, { withCredentials: true });

			if (response.data.message === 'Успешная авторизация') {
				const userData = {
					id: response.data.user.id,
					username: response.data.user.username,
					role: response.data.user.role || 'user',
					last_name: response.data.user.last_name || '',
					first_name: response.data.user.first_name || '',
					middle_name: response.data.user.middle_name || '',
				};
				localStorage.setItem('user', JSON.stringify(userData));
				login(userData); // Используем только login для обновления состояния
				console.log('User logged in, role:', userData.role);

				// Получаем CSRF-токен после логина
				try {
					const tokenResponse = await axios.get('http://localhost:5000/api/csrf-token', {
						withCredentials: true,
					});
					setCsrfToken(tokenResponse.data.csrf_token);
					console.log('CSRF Token сохранён после логина:', tokenResponse.data.csrf_token);
				} catch (err) {
					console.error('Ошибка получения CSRF-токена после логина:', err);
				}

				navigate(userData.role === 'admin' ? '/admin' : '/dashboard', { replace: true });
			}
		} catch (err) {
			if (err.response && err.response.data.error === 'Неверное имя пользователя или пароль') {
				setError('Неверные учетные данные. Проверьте имя пользователя и пароль.');
			} else {
				setError('Произошла ошибка при входе. Попробуйте позже.');
			}
			console.error('Login error:', err);
		} finally {
			setIsLoading(false);
		}
	};

	return (
		<Container maxWidth="sm" sx={{ mt: 8 }}>
			<Card elevation={4} sx={{ p: 4, borderRadius: 16, backgroundColor: 'white', boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)' }}>
				<CardContent>
					<Typography variant="h4" gutterBottom align="center" sx={{ mb: 3, color: '#1976D2' }}>
						Вход в Систему Публикаций
					</Typography>
					{error && (
						<Alert severity="error" sx={{ mb: 2, borderRadius: 8 }} onClose={() => setError('')}>
							{error}
						</Alert>
					)}
					<form onSubmit={handleSubmit}>
						<TextField
							fullWidth
							label="Логин"
							value={username}
							onChange={(e) => setUsername(e.target.value)}
							margin="normal"
							variant="outlined"
							sx={{ mb: 2, borderRadius: 8 }}
							autoComplete="username"
							disabled={isLoading}
						/>
						<TextField
							fullWidth
							label="Пароль"
							type="password"
							value={password}
							onChange={(e) => setPassword(e.target.value)}
							margin="normal"
							variant="outlined"
							sx={{ borderRadius: 8 }}
							autoComplete="current-password"
							disabled={isLoading}
						/>
						<Button
							type="submit"
							variant="contained"
							fullWidth
							sx={{ mt: 3, py: 1.5, borderRadius: 16, transition: 'all 0.3s ease', '&:hover': { transform: 'scale(1.05)' } }}
							disabled={isLoading}
						>
							{isLoading ? 'Вход...' : 'Войти'}
						</Button>
					</form>
				</CardContent>
			</Card>
		</Container>
	);
}

export default Login;
-------------
D:\publication-system\frontend\src\components\ManagerDashboard.js
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
	Container,
	Typography,
	Card as AppleCard,
	Tabs,
	Tab,
	Box,
	CircularProgress,
	Table,
	TableBody,
	TableCell,
	TableHead,
	TableRow,
	IconButton,
	Dialog,
	DialogTitle,
	DialogContent,
	DialogActions,
	TextField,
	Collapse,
	Alert,
	Pagination,
	Fade,
	MenuItem,
	Button,
	Accordion,
	AccordionSummary,
	AccordionDetails,
	LinearProgress,
} from '@mui/material';
import { styled } from '@mui/system';
import DeleteIcon from '@mui/icons-material/Delete';
import DownloadIcon from '@mui/icons-material/Download';
import CheckIcon from '@mui/icons-material/Check';
import ReplayIcon from '@mui/icons-material/Replay';
import RefreshIcon from '@mui/icons-material/Refresh';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import Visibility from '@mui/icons-material/Visibility';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import WarningAmberIcon from '@mui/icons-material/WarningAmber';
import VisibilityOff from '@mui/icons-material/VisibilityOff';
import axios from 'axios';
import { useAuth } from '../contexts/AuthContext';
import StatusChip from './StatusChip';

const AppleTextField = styled(TextField)({
	'& .MuiOutlinedInput-root': {
		borderRadius: '12px',
		backgroundColor: '#F5F5F7',
		'& fieldset': { borderColor: '#D1D1D6' },
		'&:hover fieldset': { borderColor: '#0071E3' },
		'&.Mui-focused fieldset': { borderColor: '#0071E3' },
	},
	'& .MuiInputLabel-root': { color: '#6E6E73' },
	'& .MuiInputLabel-root.Mui-focused': { color: '#0071E3' },
});

const AppleTable = styled(Table)({
	borderCollapse: 'separate',
	borderSpacing: '0 8px',
});

const PlanTable = styled(Table)(({ theme }) => ({
	borderRadius: '16px',
	overflow: 'hidden',
	backgroundColor: '#FFFFFF',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	marginBottom: '16px',
}));

const AppleButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#0071E3',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#0066CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const GreenButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: 'green',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#2EBB4A', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const CancelButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#D1D1D6',
	color: '#1D1D1F',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#C7C7CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

function ManagerDashboard() {
	const { user, csrfToken, isAuthenticated } = useAuth();
	const navigate = useNavigate();
	const [value, setValue] = useState(0);
	const [needsReviewPublications, setNeedsReviewPublications] = useState([]);
	const [plans, setPlans] = useState([]);
	const [currentPageNeedsReview, setCurrentPageNeedsReview] = useState(1);
	const [currentPagePlans, setCurrentPagePlans] = useState(1);
	const [totalPagesNeedsReview, setTotalPagesNeedsReview] = useState(1);
	const [totalPagesPlans, setTotalPagesPlans] = useState(1);
	const [searchQuery, setSearchQuery] = useState('');
	const [loadingInitial, setLoadingInitial] = useState(true);
	const [openEditDialog, setOpenEditDialog] = useState(false);
	const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
	const [publicationToDelete, setPublicationToDelete] = useState(null);
	const [editPublication, setEditPublication] = useState(null);
	const [editTitle, setEditTitle] = useState('');
	const [editAuthors, setEditAuthors] = useState('');
	const [editYear, setEditYear] = useState('');
	const [editType, setEditType] = useState('article');
	const [editStatus, setEditStatus] = useState('needs_review');
	const [editFile, setEditFile] = useState(null);
	const [error, setError] = useState('');
	const [success, setSuccess] = useState('');
	const [openError, setOpenError] = useState(false);
	const [openSuccess, setOpenSuccess] = useState(false);
	const [newLastName, setNewLastName] = useState('');
	const [newFirstName, setNewFirstName] = useState('');
	const [newMiddleName, setNewMiddleName] = useState('');
	const [newUsername, setNewUsername] = useState('');
	const [newPassword, setNewPassword] = useState('');
	const [showPassword, setShowPassword] = useState(false);
	const [openReturnDialog, setOpenReturnDialog] = useState(false);
	const [selectedPlan, setSelectedPlan] = useState(null);
	const [returnComment, setReturnComment] = useState('');



	const handleDownload = async (fileUrl, fileName) => {
		// Проверяем, что fileUrl существует и является строкой
		if (!fileUrl || typeof fileUrl !== 'string' || fileUrl.trim() === '') {
			console.error('Некорректный fileUrl:', fileUrl);
			setError('Некорректный URL файла. Обратитесь к администратору.');
			setOpenError(true);
			return;
		}

		// Убеждаемся, что fileUrl начинается с '/', если это относительный путь
		const normalizedFileUrl = fileUrl.startsWith('/') ? fileUrl : `/${fileUrl}`;
		const fullUrl = `http://localhost:5000${normalizedFileUrl}`;
		console.log('Попытка скачать файл с URL:', fullUrl);

		try {
			const response = await axios.get(fullUrl, {
				responseType: 'blob',
				withCredentials: true,
				headers: {
					'X-CSRFToken': csrfToken,
				},
			});

			const blob = new Blob([response.data]);
			const url = window.URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.href = url;
			link.download = fileName || normalizedFileUrl.split('/').pop();
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			window.URL.revokeObjectURL(url);
		} catch (err) {
			console.error('Ошибка при скачивании файла:', err);
			if (err.response) {
				setError(`Ошибка сервера: ${err.response.status}. Не удалось скачать файл.`);
			} else {
				setError('Не удалось скачать файл. Проверьте подключение или URL.');
			}
			setOpenError(true);
		}
	};

	useEffect(() => {
		if (!isAuthenticated || user.role !== 'manager') navigate('/login');
		fetchNeedsReviewPublications(currentPageNeedsReview);
		fetchPlans(currentPagePlans);
		setLoadingInitial(false);
	}, [isAuthenticated, user, navigate, currentPageNeedsReview, currentPagePlans]);

	const fetchNeedsReviewPublications = async (page) => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/publications/needs-review?page=${page}&per_page=10&search=${searchQuery}`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setNeedsReviewPublications(response.data.publications);
			setTotalPagesNeedsReview(response.data.pages);
		} catch (err) {
			console.error('Ошибка загрузки публикаций:', err);
			setError('Не удалось загрузить публикации. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const fetchPlans = async (page) => {
		try {
			const response = await axios.get(`http://localhost:5000/admin_api/admin/plans/needs-review?page=${page}&per_page=10`, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			console.log('Данные планов с сервера:', response.data.plans); // Логируем данные для проверки
			setPlans(response.data.plans);
			setTotalPagesPlans(response.data.pages);
		} catch (err) {
			console.error('Ошибка загрузки планов:', err);
			setError('Не удалось загрузить планы. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleTabChange = (event, newValue) => {
		setValue(newValue);
	};

	const handleSearchChange = (event) => {
		setSearchQuery(event.target.value);
		fetchNeedsReviewPublications(1);
	};

	const handlePageChangeNeedsReview = (event, value) => {
		setCurrentPageNeedsReview(value);
		fetchNeedsReviewPublications(value);
	};

	const handlePageChangePlans = (event, value) => {
		setCurrentPagePlans(value);
		fetchPlans(value);
	};

	const handleEditClick = (publication) => {
		setEditPublication(publication);
		setEditTitle(publication.title);
		setEditAuthors(publication.authors);
		setEditYear(publication.year);
		setEditType(publication.type);
		setEditStatus(publication.status);
		setEditFile(null);
		setOpenEditDialog(true);
	};

	const handleEditCancel = () => {
		setOpenEditDialog(false);
		setEditPublication(null);
		setEditTitle('');
		setEditAuthors('');
		setEditYear('');
		setEditType('article');
		setEditStatus('needs_review');
		setEditFile(null);
		setError('');
		setSuccess('');
	};

	const handleEditSubmit = async (event) => {
		event.preventDefault();
		if (!editTitle.trim() || !editAuthors.trim() || !editYear || editYear < 1900 || editYear > new Date().getFullYear()) {
			setError('Проверьте поля: название, авторы и год должны быть заполнены корректно.');
			setOpenError(true);
			return;
		}

		const formData = new FormData();
		formData.append('title', editTitle);
		formData.append('authors', editAuthors);
		formData.append('year', editYear);
		formData.append('type', editType);
		formData.append('status', editStatus);
		if (editFile) formData.append('file', editFile);

		try {
			const response = await axios.put(`http://localhost:5000/admin_api/admin/publications/${editPublication.id}`, formData, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken, 'Content-Type': 'multipart/form-data' },
			});
			setSuccess('Публикация успешно обновлена!');
			setOpenSuccess(true);
			fetchNeedsReviewPublications(currentPageNeedsReview);
			handleEditCancel();
		} catch (err) {
			console.error('Ошибка обновления публикации:', err);
			setError('Не удалось обновить публикацию. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleDeletePlanClick = (publication) => {
		setPublicationToDelete(publication);
		setOpenDeleteDialog(true);
	};

	const handleDeletePlanConfirm = async () => {
		if (publicationToDelete) {
			try {
				await axios.delete(`http://localhost:5000/admin_api/admin/publications/${publicationToDelete.id}`, {
					withCredentials: true,
					headers: { 'X-CSRFToken': csrfToken },
				});
				setSuccess('Публикация успешно удалена!');
				setOpenSuccess(true);
				fetchNeedsReviewPublications(currentPageNeedsReview);
				setOpenDeleteDialog(false);
				setPublicationToDelete(null);
			} catch (err) {
				console.error('Ошибка удаления публикации:', err);
				setError('Не удалось удалить публикацию. Попробуйте позже.');
				setOpenError(true);
			}
		}
	};

	const handleApprovePlan = async (plan) => {
		try {
			await axios.post(`http://localhost:5000/admin_api/admin/plans/${plan.id}/approve`, {}, {
				withCredentials: true,
				headers: { 'X-CSRFToken': csrfToken },
			});
			setSuccess('План утверждён!');
			setOpenSuccess(true);
			fetchPlans(currentPagePlans);
		} catch (err) {
			console.error('Ошибка утверждения плана:', err);
			setError('Не удалось утвердить план. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const handleOpenReturnDialog = (plan) => {
		setSelectedPlan(plan);
		setReturnComment('');
		setOpenReturnDialog(true);
	};

	const handleReturnForRevision = async () => {
		if (!returnComment.trim()) {
			setError('Комментарий обязателен.');
			setOpenError(true);
			return;
		}
		try {
			await axios.post(
				`http://localhost:5000/admin_api/admin/plans/${selectedPlan.id}/return-for-revision`,
				{ comment: returnComment },
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			setSuccess('План возвращён на доработку!');
			setOpenSuccess(true);
			fetchPlans(currentPagePlans);
			setOpenReturnDialog(false);
		} catch (err) {
			console.error('Ошибка возврата плана:', err);
			setError('Не удалось вернуть план. Попробуйте позже.');
			setOpenError(true);
		}
	};

	const calculateProgress = (plan) => {
		const completed = plan.entries.filter((entry) => entry.publication_id).length;
		const total = plan.expectedCount;
		return total > 0 ? (completed / total) * 100 : 0;
	};

	return (
		<Container maxWidth="lg" sx={{ mt: 8, mb: 4 }}>
			<AppleCard elevation={4} sx={{ p: 4, borderRadius: '16px', backgroundColor: '#FFFFFF' }}>
				<Typography variant="h4" sx={{ color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
					Панель управляющего
				</Typography>
				<Tabs
					value={value}
					onChange={handleTabChange}
					centered
					sx={{
						mb: 4,
						'& .MuiTab-root': { color: '#6E6E73', fontWeight: 600 },
						'& .MuiTab-root.Mui-selected': { color: '#0071E3' },
						'& .MuiTabs-indicator': { backgroundColor: '#0071E3' },
					}}
				>
					<Tab label="Работы на проверке" />
					<Tab label="Статистика по кафедре" />
					<Tab label="Регистрация пользователей" />
					<Tab label="Работа с планами" />
				</Tabs>

				{loadingInitial ? (
					<Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
						<CircularProgress sx={{ color: '#0071E3' }} />
					</Box>
				) : (
					<>
						{value === 0 && (
							<>
								<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
									Работы на проверке
								</Typography>
								<AppleCard sx={{ mt: 2, mb: 2, p: 2, backgroundColor: '#F5F5F7', borderRadius: '16px', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<AppleTextField
										fullWidth
										label="Поиск по названию, авторам или году"
										value={searchQuery}
										onChange={handleSearchChange}
										margin="normal"
										variant="outlined"
										InputProps={{
											endAdornment: <IconButton sx={{ color: '#0071E3' }}></IconButton>,
										}}
									/>
								</AppleCard>
								<AppleTable sx={{ mt: 2, boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)' }}>
									<TableHead>
										<TableRow sx={{ backgroundColor: '#0071E3' }}>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', borderRadius: '12px 0 0 0' }}>ID</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Название</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Авторы</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Год</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Тип</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Статус</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF' }}>Пользователь</TableCell>
											<TableCell sx={{ fontWeight: 600, color: '#FFFFFF', textAlign: 'center', borderRadius: '0 12px 0 0' }}>
												Действия
											</TableCell>
										</TableRow>
									</TableHead>
									<Fade in={true} timeout={500}>
										<TableBody>
											{needsReviewPublications.length > 0 ? (
												needsReviewPublications.map((pub) => (
													<TableRow
														key={pub.id}
														sx={{
															'&:hover': { backgroundColor: '#F5F5F7', transition: 'background-color 0.3s ease' },
														}}
													>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.id}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															<Typography
																sx={{
																	color: '#0071E3',
																	textDecoration: 'underline',
																	cursor: 'pointer',
																	'&:hover': { textDecoration: 'none' },
																}}
																onClick={() => navigate(`/publication/${pub.id}`)}
															>
																{pub.title}
															</Typography>
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.authors}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.year}</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															{pub.type === 'article'
																? 'Статья'
																: pub.type === 'monograph'
																	? 'Монография'
																	: pub.type === 'conference'
																		? 'Доклад/конференция'
																		: 'Неизвестный тип'}
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>
															<StatusChip status={pub.status} />
														</TableCell>
														<TableCell sx={{ color: '#1D1D1F' }}>{pub.user?.full_name || 'Не указан'}</TableCell>
														<TableCell sx={{ textAlign: 'center' }}>
															<Box sx={{ display: 'flex', justifyContent: 'center', gap: 1 }}>
																{pub.file_url && pub.file_url.trim() !== '' && (
																	<IconButton
																		aria-label="download"
																		onClick={() => handleDownload(pub.file_url, pub.file_url.split('/').pop())}
																		sx={{
																			color: '#0071E3',
																			borderRadius: '8px',
																			'&:hover': {
																				color: '#FFFFFF',
																				backgroundColor: '#0071E3',
																				boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
																			},
																		}}
																	>
																		<DownloadIcon />
																	</IconButton>
																)}
															</Box>
														</TableCell>
													</TableRow>
												))
											) : (
												<TableRow>
													<TableCell colSpan={8} sx={{ textAlign: 'center', color: '#6E6E73' }}>
														Нет публикаций, ожидающих проверки.
													</TableCell>
												</TableRow>
											)}
										</TableBody>
									</Fade>
								</AppleTable>
								<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
									<Pagination
										count={totalPagesNeedsReview}
										page={currentPageNeedsReview}
										onChange={handlePageChangeNeedsReview}
										color="primary"
										sx={{
											'& .MuiPaginationItem-root': {
												borderRadius: 20,
												transition: 'all 0.3s ease',
												'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
												'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
											},
										}}
									/>
								</Box>
							</>
						)}

						{value === 1 && (
							<Typography
								variant="h5"
								gutterBottom
								sx={{
									mt: 4,
									color: '#1D1D1F',
									fontWeight: 600,
									textAlign: 'center',
								}}
							>
								Статистика по кафедре
							</Typography>
						)}

						{value === 2 && (
							<>
								<Typography
									variant="h5"
									gutterBottom
									sx={{ mt: 4, color: "#1D1D1F", fontWeight: 600, textAlign: "center" }}
								>
									Регистрация нового пользователя
								</Typography>
								<AppleCard sx={{ maxWidth: "none", mx: "auto", mt: 2, p: 4 }}>
									<form onSubmit={(e) => { e.preventDefault(); }}>
										<AppleTextField
											fullWidth
											label="Фамилия"
											value={newLastName}
											onChange={(e) => setNewLastName(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="family-name"
										/>
										<AppleTextField
											fullWidth
											label="Имя"
											value={newFirstName}
											onChange={(e) => setNewFirstName(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="given-name"
										/>
										<AppleTextField
											fullWidth
											label="Отчество"
											value={newMiddleName}
											onChange={(e) => setNewMiddleName(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="additional-name"
										/>
										<AppleTextField
											fullWidth
											label="Логин"
											value={newUsername}
											onChange={(e) => setNewUsername(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="username"
										/>
										<AppleTextField
											fullWidth
											label="Пароль"
											type={showPassword ? "text" : "password"}
											value={newPassword}
											onChange={(e) => setNewPassword(e.target.value)}
											margin="normal"
											variant="outlined"
											autoComplete="new-password"
											InputProps={{
												endAdornment: (
													<IconButton onClick={() => setShowPassword(!showPassword)}>
														{showPassword ? <VisibilityOff /> : <Visibility />}
													</IconButton>
												),
											}}
										/>
										<Box sx={{ display: "flex", gap: 2, mt: 2 }}>
											<AppleButton
												startIcon={<RefreshIcon />}
												onClick={async () => {
													// Функция генерации логина из AdminDashboard.js
													const generateUsername = async () => {
														if (!newLastName || !newFirstName || !newMiddleName) {
															setError('Для генерации логина необходимо заполнить ФИО.');
															setOpenError(true);
															return null;
														}

														const transliterate = (text) => {
															const ruToEn = {
																'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd',
																'е': 'e', 'ё': 'e', 'ж': 'zh', 'з': 'z', 'и': 'i',
																'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n',
																'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't',
																'у': 'u', 'ф': 'f', 'х': 'kh', 'ц': 'ts', 'ч': 'ch',
																'ш': 'sh', 'щ': 'sch', 'ъ': '', 'ы': 'y', 'ь': '',
																'э': 'e', 'ю': 'yu', 'я': 'ya'
															};
															return text.toLowerCase().split('').map(char => ruToEn[char] || char).join('');
														};

														const capitalizeFirstLetter = (string) => {
															if (!string) return '';
															return string.charAt(0).toUpperCase() + string.slice(1);
														};

														const baseUsername = `${capitalizeFirstLetter(transliterate(newLastName))}${capitalizeFirstLetter(transliterate(newFirstName[0]))}${capitalizeFirstLetter(transliterate(newMiddleName[0]))}`;
														let generatedUsername = baseUsername;
														let suffix = 1;

														while (true) {
															try {
																const response = await axios.post(
																	'http://localhost:5000/admin_api/admin/check-username',
																	{ username: generatedUsername },
																	{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
																);
																if (!response.data.exists) {
																	break;
																}
																generatedUsername = `${baseUsername}${suffix}`;
																suffix++;
															} catch (err) {
																setError('Ошибка проверки логина. Попробуйте снова.');
																setOpenError(true);
																return null;
															}
														}
														return generatedUsername;
													};

													const generatedUsername = await generateUsername();
													if (!generatedUsername) return;

													try {
														const response = await axios.get(
															'http://localhost:5000/admin_api/admin/generate-password',
															{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
														);
														setNewUsername(generatedUsername);
														setNewPassword(response.data.password);
														setSuccess('Логин и пароль успешно сгенерированы.');
														setOpenSuccess(true);
													} catch (err) {
														setError('Ошибка генерации пароля. Попробуйте снова.');
														setOpenError(true);
													}
												}}
											>
												Сгенерировать логин и пароль
											</AppleButton>
											<AppleButton
												startIcon={<ContentCopyIcon />}
												onClick={() => {
													navigator.clipboard.writeText(
														`Логин: ${newUsername}\nПароль: ${newPassword}`
													);
													setSuccess("Данные скопированы в буфер обмена!");
													setOpenSuccess(true);
												}}
											>
												Скопировать в буфер обмена
											</AppleButton>
											<AppleButton
												type="submit"
												onClick={async () => {
													if (
														!newUsername.trim() ||
														!newPassword.trim() ||
														!newLastName.trim() ||
														!newFirstName.trim() ||
														!newMiddleName.trim()
													) {
														setError("Все поля обязательны.");
														setOpenError(true);
														return;
													}
													try {
														await axios.post(
															"http://localhost:5000/admin_api/admin/register",
															{
																username: newUsername,
																password: newPassword,
																last_name: newLastName,
																first_name: newFirstName,
																middle_name: newMiddleName,
															},
															{ withCredentials: true, headers: { "X-CSRFToken": csrfToken } }
														);
														setSuccess("Пользователь успешно зарегистрирован!");
														setOpenSuccess(true);
														setNewLastName("");
														setNewFirstName("");
														setNewMiddleName("");
														setNewUsername("");
														setNewPassword("");
													} catch (err) {
														console.error("Ошибка регистрации:", err);
														setError(
															err.response?.data?.error || "Не удалось зарегистрировать пользователя."
														);
														setOpenError(true);
													}
												}}
											>
												Создать
											</AppleButton>
										</Box>
										<Collapse in={openError}>
											{error && (
												<Alert
													severity="error"
													sx={{
														mt: 2,
														borderRadius: "12px",
														backgroundColor: "#FFF1F0",
														color: "#1D1D1F",
														boxShadow: "0 2px 4px rgba(0, 0, 0, 0.05)",
													}}
													onClose={() => setOpenError(false)}
												>
													{error}
												</Alert>
											)}
										</Collapse>
										<Collapse in={openSuccess}>
											{success && (
												<Alert
													severity="success"
													sx={{
														mt: 2,
														borderRadius: "12px",
														backgroundColor: "#E7F8E7",
														color: "#1D1D1F",
														boxShadow: "0 2px 4px rgba(0, 0, 0, 0.05)",
													}}
													onClose={() => setOpenSuccess(false)}
												>
													{success}
												</Alert>
											)}
										</Collapse>
									</form>
								</AppleCard>
							</>
						)}

						{value === 3 && (
							<Box sx={{ mt: 4 }}>
								<Typography variant="h5" gutterBottom sx={{ mt: 4, color: '#1D1D1F', fontWeight: 600, textAlign: 'center' }}>
									Работа с планами
								</Typography>
								{plans.length > 0 ? (
									plans.map((plan) => (
										<Accordion
											key={plan.id}
											sx={{
												mb: 2,
												borderRadius: '16px',
												boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
											}}
										>
											<AccordionSummary expandIcon={<ExpandMoreIcon />}>
												<Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
													<Box>
														<Typography variant="h6" sx={{ color: '#1D1D1F' }}>
															План на {plan.year} год (Ожидаемое количество: {plan.expectedCount} | Текущее количество: {plan.entries.length})
														</Typography>
														<Typography variant="body2" sx={{ color: '#6E6E73', mt: 0.5 }}>
															{plan.user && plan.user.full_name
																? `${plan.user.full_name} (${plan.user.username || 'логин отсутствует'})`
																: 'Пользователь не указан'}
														</Typography>
													</Box>
													<StatusChip status={plan.status} />
												</Box>
											</AccordionSummary>
											<AccordionDetails>
												<>
													<PlanTable>
														<TableHead>
															<TableRow>
																<TableCell>Название</TableCell>
																<TableCell>Тип</TableCell>
																<TableCell>Статус</TableCell>
															</TableRow>
														</TableHead>
														<TableBody>
															{plan.entries.map((entry) => (
																<TableRow key={entry.id}>
																	<TableCell>{entry.title || 'Не указано'}</TableCell>
																	<TableCell>
																		{entry.type === 'article'
																			? 'Статья'
																			: entry.type === 'monograph'
																				? 'Монография'
																				: entry.type === 'conference'
																					? 'Доклад/конференция'
																					: entry.type || 'Не указано'}
																	</TableCell>
																	<TableCell>
																		<StatusChip status={entry.status} />
																	</TableCell>
																</TableRow>
															))}
														</TableBody>
													</PlanTable>
													{plan.return_comment && (
														<Typography
															sx={{
																mt: 2,
																color: '#000000',
																fontWeight: 600,
																display: 'flex',
																alignItems: 'center',
																gap: 1,
															}}
														>
															<WarningAmberIcon sx={{ color: '#FF3B30' }} />
															Комментарий при возврате: {plan.return_comment}
														</Typography>
													)}
													{plan.status === 'needs_review' && (
														<Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
															<GreenButton startIcon={<CheckIcon />} onClick={() => handleApprovePlan(plan)}>
																Утвердить
															</GreenButton>
															<AppleButton startIcon={<ReplayIcon />} onClick={() => handleOpenReturnDialog(plan)}>
																На доработку
															</AppleButton>
														</Box>
													)}
												</>
											</AccordionDetails>
										</Accordion>
									))
								) : (
									<Typography sx={{ textAlign: 'center', color: '#6E6E73', mt: 2 }}>
										Нет планов для проверки.
									</Typography>
								)}
								<Box sx={{ mt: 2, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
									<Pagination
										count={totalPagesPlans}
										page={currentPagePlans}
										onChange={handlePageChangePlans}
										color="primary"
										sx={{
											'& .MuiPaginationItem-root': {
												borderRadius: 20,
												'&:hover': { backgroundColor: 'grey.100' },
												'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white' },
											},
										}}
									/>
								</Box>
							</Box>
						)}

						<Dialog
							open={openDeleteDialog}
							onClose={() => { setOpenDeleteDialog(false); setPublicationToDelete(null); }}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Подтвердите удаление
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<Typography sx={{ color: '#6E6E73' }}>
									Вы уверены, что хотите удалить публикацию "{publicationToDelete?.title}"?
								</Typography>
							</DialogContent>
							<DialogActions sx={{ padding: '16px 24px', borderTop: '1px solid #E5E5EA' }}>
								<CancelButton onClick={() => { setOpenDeleteDialog(false); setPublicationToDelete(null); }}>Отмена</CancelButton>
								<AppleButton onClick={handleDeletePlanConfirm}>
									Удалить
								</AppleButton>
							</DialogActions>
						</Dialog>

						<Dialog
							open={openEditDialog}
							onClose={handleEditCancel}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Редактировать публикацию
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<form onSubmit={handleEditSubmit}>
									<AppleTextField
										fullWidth
										label="Название"
										value={editTitle}
										onChange={(e) => setEditTitle(e.target.value)}
										margin="normal"
										variant="outlined"
									/>
									<AppleTextField
										fullWidth
										label="Авторы"
										value={editAuthors}
										onChange={(e) => setEditAuthors(e.target.value)}
										margin="normal"
										variant="outlined"
									/>
									<AppleTextField
										fullWidth
										label="Год"
										type="number"
										value={editYear}
										onChange={(e) => setEditYear(e.target.value)}
										margin="normal"
										variant="outlined"
									/>
									<AppleTextField
										fullWidth
										select
										label="Тип публикации"
										value={editType}
										onChange={(e) => setEditType(e.target.value)}
										margin="normal"
										variant="outlined"
									>
										<MenuItem value="article">Статья</MenuItem>
										<MenuItem value="monograph">Монография</MenuItem>
										<MenuItem value="conference">Доклад/конференция</MenuItem>
									</AppleTextField>
									<AppleTextField
										fullWidth
										select
										label="Статус"
										value={editStatus}
										onChange={(e) => setEditStatus(e.target.value)}
										margin="normal"
										variant="outlined"
										disabled={!editPublication?.file_url && !editFile}
									>
										<MenuItem value="draft">Черновик</MenuItem>
										<MenuItem value="needs_review">Нуждается в проверке</MenuItem>
										<MenuItem value="published" disabled={!editPublication?.file_url && !editFile}>
											Опубликовано
										</MenuItem>
									</AppleTextField>
									<Box sx={{ mt: 2 }}>
										<Typography variant="body2" sx={{ color: '#6E6E73', mb: 1 }}>
											Текущий файл: {editPublication?.file_url || 'Нет файла'}
										</Typography>
										<input
											type="file"
											accept=".pdf,.docx"
											onChange={(e) => setEditFile(e.target.files[0])}
											style={{ display: 'none' }}
											id="edit-upload-file"
										/>
										<label htmlFor="edit-upload-file">
											<AppleButton sx={{ border: '1px solid #D1D1D6', backgroundColor: '#F5F5F7', color: '#1D1D1F' }} component="span">
												Выбрать файл
											</AppleButton>
										</label>
										{editFile && <Typography sx={{ mt: 1, color: '#6E6E73' }}>{editFile.name}</Typography>}
									</Box>
									<Collapse in={openError}>
										{error && (
											<Alert
												severity="error"
												sx={{
													mt: 2,
													borderRadius: '12px',
													backgroundColor: '#FFF1F0',
													color: '#1D1D1F',
													boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
												}}
												onClose={() => setOpenError(false)}
											>
												{error}
											</Alert>
										)}
									</Collapse>
									<Collapse in={openSuccess}>
										{success && (
											<Alert
												severity="success"
												sx={{
													mt: 2,
													borderRadius: '12px',
													backgroundColor: '#E7F8E7',
													color: '#1D1D1F',
													boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
												}}
												onClose={() => setOpenSuccess(false)}
											>
												{success}
											</Alert>
										)}
									</Collapse>
									<DialogActions sx={{ padding: '16px 0', borderTop: '1px solid #E5E5EA' }}>
										<CancelButton onClick={handleEditCancel}>Отмена</CancelButton>
										<AppleButton type="submit">Сохранить</AppleButton>
									</DialogActions>
								</form>
							</DialogContent>
						</Dialog>

						<Dialog
							open={openReturnDialog}
							onClose={() => setOpenReturnDialog(false)}
							sx={{
								'& .MuiDialog-paper': {
									backgroundColor: '#FFFFFF',
									boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
									borderRadius: '16px',
									fontFamily: "'SF Pro Display', 'Helvetica Neue', Arial, sans-serif",
									maxWidth: '400px',
								},
							}}
						>
							<DialogTitle sx={{ color: '#1D1D1F', fontWeight: 600, borderBottom: '1px solid #E5E5EA' }}>
								Вернуть план на доработку
							</DialogTitle>
							<DialogContent sx={{ padding: '24px' }}>
								<Typography sx={{ color: '#6E6E73', mb: 2 }}>
									Пожалуйста, укажите комментарий для пользователя:
								</Typography>
								<TextField
									autoFocus
									margin="dense"
									label="Комментарий"
									type="text"
									fullWidth
									multiline
									rows={3}
									value={returnComment}
									onChange={(e) => setReturnComment(e.target.value)}
									variant="outlined"
								/>
							</DialogContent>
							<DialogActions sx={{ padding: '16px 24px', borderTop: '1px solid #E5E5EA' }}>
								<CancelButton onClick={() => setOpenReturnDialog(false)}>Отмена</CancelButton>
								<AppleButton onClick={handleReturnForRevision}>Отправить</AppleButton>
							</DialogActions>
						</Dialog>

						<Collapse in={openError}>
							{error && (
								<Alert
									severity="error"
									sx={{
										mt: 2,
										borderRadius: '12px',
										backgroundColor: '#FFF1F0',
										color: '#1D1D1F',
										boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
									}}
									onClose={() => setOpenError(false)}
								>
									{error}
								</Alert>
							)}
						</Collapse>
						<Collapse in={openSuccess}>
							{success && (
								<Alert
									severity="success"
									sx={{
										mt: 2,
										borderRadius: '12px',
										backgroundColor: '#E7F8E7',
										color: '#1D1D1F',
										boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
									}}
									onClose={() => setOpenSuccess(false)}
								>
									{success}
								</Alert>
							)}
						</Collapse>
					</>
				)}
			</AppleCard>
		</Container>
	);
}

export default ManagerDashboard;
------------
D:\publication-system\frontend\src\components\Publication.js
import React, { useEffect, useState, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
	Container,
	Typography,
	Card,
	Button,
	CardContent,
	Box,
	Pagination,
} from '@mui/material';
import { styled } from '@mui/system';
import { Document, Page, pdfjs } from 'react-pdf';
import 'react-pdf/dist/Page/AnnotationLayer.css';
import 'react-pdf/dist/Page/TextLayer.css';
import axios from 'axios';
import DownloadIcon from '@mui/icons-material/Download';
import { useAuth } from '../contexts/AuthContext';
import CommentSection from './CommentSection';

pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.min.js`;

const AppleButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#0071E3',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': { backgroundColor: '#0066CC', boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)' },
});

const GreenButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: 'green',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': {
		backgroundColor: '#2EBB4A',
		boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
	},
	'&:disabled': {
		backgroundColor: '#D1D1D6',
		color: '#FFFFFF',
	},
});

const RedButton = styled(Button)({
	borderRadius: '12px',
	textTransform: 'none',
	backgroundColor: '#FF3B30',
	color: '#FFFFFF',
	padding: '8px 16px',
	fontSize: '14px',
	fontWeight: 600,
	boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
	'&:hover': {
		backgroundColor: '#E63935',
		boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
	},
	'&:disabled': {
		backgroundColor: '#D1D1D6',
		color: '#FFFFFF',
	},
});

const AppleCard = styled(Card)({
	borderRadius: '16px',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	backgroundColor: '#FFFFFF',
});

const DocumentViewer = styled(Box)({
	mb: 4,
	border: '1px solid #E5E5EA',
	borderRadius: '12px',
	overflow: 'hidden',
	backgroundColor: '#FFFFFF',
	boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
	width: '100%',
	height: '850px',
	display: 'flex',
	justifyContent: 'center',
	alignItems: 'flex-start',
	'&::-webkit-scrollbar': { display: 'none' },
	'-ms-overflow-style': 'none',
	'scrollbar-width': 'none',
});

function Publication() {
	const { id } = useParams();
	const [publication, setPublication] = useState(null);
	const [error, setError] = useState('');
	const [numPages, setNumPages] = useState(null);
	const [pageNumber, setPageNumber] = useState(1);
	const { user, isAuthenticated, csrfToken } = useAuth();
	const [hasReviewerComment, setHasReviewerComment] = useState(false);
	const [loadingUser, setLoadingUser] = useState(true);

	const fetchPublication = useCallback(async () => {
		try {
			const response = await axios.get(`http://localhost:5000/api/publications/${id}`, { withCredentials: true });
			setPublication(response.data);
			const reviewerComment = response.data.comments.some(
				(comment) =>
					['admin', 'manager'].includes(comment.user.role) ||
					comment.replies.some((reply) => ['admin', 'manager'].includes(reply.user.role))
			);
			setHasReviewerComment(reviewerComment);
		} catch (err) {
			console.error('Ошибка загрузки публикации:', err);
			setError('Не удалось загрузить публикацию. Попробуйте позже.');
		}
	}, [id]);

	useEffect(() => {
		fetchPublication();
	}, [fetchPublication]);

	useEffect(() => {
		if (user !== null) {
			setLoadingUser(false);
		}
	}, [user]);

	const onDocumentLoadSuccess = ({ numPages }) => {
		setNumPages(numPages);
	};

	const handleDownload = () => {
		if (publication && publication.file_url) {
			const fileUrl = `http://localhost:5000${publication.file_url}`;
			const link = document.createElement('a');
			link.href = fileUrl;
			link.download = publication.file_url.split('/').pop();
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		}
	};

	const handlePublish = async () => {
		try {
			const response = await axios.post(
				`http://localhost:5000/api/publications/${id}/publish`,
				{},
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			console.log('Publication response:', response.data);
			fetchPublication();
		} catch (err) {
			console.error('Ошибка при публикации:', err);
			setError('Не удалось опубликовать публикацию.');
		}
	};

	const handleReject = async () => {
		try {
			const response = await axios.post(
				`http://localhost:5000/api/publications/${id}/return-for-revision`,
				{},
				{ withCredentials: true, headers: { 'X-CSRFToken': csrfToken } }
			);
			console.log('Return for revision response:', response.data);
			fetchPublication();
		} catch (err) {
			console.error('Ошибка при отправке на доработку:', err);
			setError('Не удалось отправить на доработку. Убедитесь, что был добавлен комментарий.');
		}
	};

	const handleCommentAdded = (newComment) => {
		setPublication((prev) => {
			if (newComment.parent_id) {
				const updatedComments = prev.comments.map((comment) =>
					comment.id === newComment.parent_id
						? { ...comment, replies: [...comment.replies, newComment] }
						: comment
				);
				return { ...prev, comments: updatedComments };
			}
			return { ...prev, comments: [...prev.comments, newComment] };
		});
		if (['admin', 'manager'].includes(newComment.user.role)) {
			setHasReviewerComment(true);
		}
	};

	if (error) return <Typography color="error">{error}</Typography>;
	if (!publication || loadingUser) return <Typography sx={{ color: '#212121' }}>Загрузка...</Typography>;

	const fileUrl = publication.file_url ? `http://localhost:5000${publication.file_url}` : null;

	// Функция для отображения статуса с учётом локализации и цвета
	const renderStatus = (status, returnedForRevision, isReviewer) => {
		let statusText = '';
		let statusColor = '#757575'; // Цвет по умолчанию (серый)

		if (isReviewer) {
			// Для admin или manager
			switch (status) {
				case 'draft':
					statusText = 'Черновик';
					break;
				case 'needs_review':
					statusText = 'Нуждается в проверке';
					statusColor = '#FF3B30'; // Красный
					break;
				case 'published':
					statusText = 'Опубликованные';
					break;
				default:
					statusText = status;
			}
		} else {
			// Для пользователя
			if (status === 'needs_review' && !returnedForRevision) {
				statusText = 'На проверке';
			} else if (status === 'draft' && returnedForRevision) {
				statusText = 'Требуется доработка';
				statusColor = '#FF3B30'; // Красный
			} else if (status === 'draft' && !returnedForRevision) {
				statusText = 'Черновик';
			} else if (status === 'published') {
				statusText = 'Опубликованные';
			} else {
				statusText = status;
			}
		}

		return <Typography variant="body1" sx={{ color: statusColor, mb: 1 }}>{`Статус: ${statusText}`}</Typography>;
	};

	const isReviewer = ['admin', 'manager'].includes(user?.role);

	console.log('User:', user);
	console.log('User role:', user?.role);
	console.log('Publication status:', publication.status);
	console.log('Is reviewer and needs_review:', isReviewer && publication.status === 'needs_review');

	return (
		<Container maxWidth="lg" sx={{ mt: 8, mb: 4 }}>
			<AppleCard elevation={4}>
				<CardContent sx={{ pt: 4, pb: 4 }}>
					<Typography variant="h4" sx={{ color: '#1D1D1F', mb: 2, fontWeight: 600 }}>
						{publication.title}
					</Typography>
					<Typography variant="body1" sx={{ color: '#757575', mb: 1 }}>
						Авторы: {publication.authors}
					</Typography>
					<Typography variant="body1" sx={{ color: '#757575', mb: 1 }}>
						Год: {publication.year}
					</Typography>
					<Typography variant="body1" sx={{ color: '#757575', mb: 1 }}>
						Тип: {publication.type === 'article' ? 'Статья' : publication.type === 'monograph' ? 'Монография' : publication.type === 'conference' ? 'Доклад/конференция' : publication.type}
					</Typography>
					{renderStatus(publication.status, publication.returned_for_revision, isReviewer)}
					<Typography variant="body1" sx={{ color: '#757575', mb: 2 }}>
						Опубликовал: {publication.user.full_name}
					</Typography>

					<Typography variant="h6" sx={{ color: '#1D1D1F', mb: 2, fontWeight: 500 }}>
						Предпросмотр:
					</Typography>
					{fileUrl ? (
						fileUrl.endsWith('.pdf') ? (
							<>
								<DocumentViewer>
									<Document
										file={fileUrl}
										onLoadSuccess={onDocumentLoadSuccess}
										onLoadError={(err) => setError(`Ошибка загрузки PDF: ${err.message}`)}
									>
										<Page
											pageNumber={pageNumber}
											scale={1}
											renderTextLayer={false}
											renderAnnotationLayer={false}
										/>
									</Document>
								</DocumentViewer>
								{numPages > 1 && (
									<Box sx={{ display: 'flex', justifyContent: 'center', mt: 2, mb: 4 }}>
										<Pagination
											count={numPages}
											page={pageNumber}
											onChange={(event, newPage) => setPageNumber(newPage)}
											color="primary"
											sx={{
												'& .MuiPaginationItem-root': {
													borderRadius: 20,
													transition: 'all 0.3s ease',
													'&:hover': { backgroundColor: 'grey.100', boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)' },
													'&.Mui-selected': { backgroundColor: '#1976D2', color: 'white', boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)' },
												},
											}}
										/>
									</Box>
								)}
							</>
						) : fileUrl.endsWith('.docx') ? (
							<Typography sx={{ color: '#6E6E73', mb: 2 }}>
								Файл загружен в формате DOCX, предпросмотр недоступен.
							</Typography>
						) : (
							<Typography sx={{ color: '#6E6E73', mb: 2 }}>
								Формат файла не поддерживается для отображения (только PDF и DOCX).
							</Typography>
						)
					) : (
						<Typography sx={{ color: '#6E6E73', mb: 2 }}>
							Файл не прикреплен к этой публикации.
						</Typography>
					)}
					{fileUrl && (
						<Box sx={{ mb: 2 }}>
							<AppleButton startIcon={<DownloadIcon />} onClick={handleDownload}>
								Скачать
							</AppleButton>
						</Box>
					)}

					{isReviewer && publication.status === 'needs_review' && (
						<Box sx={{ mb: 2, display: 'flex', gap: 2 }}>
							<GreenButton onClick={handlePublish}>Опубликовать</GreenButton>
							<RedButton onClick={handleReject} disabled={!hasReviewerComment}>
								Отправить на доработку
							</RedButton>
						</Box>
					)}

					<Typography variant="h5" sx={{ color: '#1D1D1F', mb: 2, fontWeight: 600 }}>
						Комментарии
					</Typography>
					{publication.comments && (
						<CommentSection
							comments={publication.comments}
							publicationId={publication.id}
							onCommentAdded={handleCommentAdded}
						/>
					)}
				</CardContent>
			</AppleCard>
		</Container>
	);
}

export default Publication;
---------
D:\publication-system\frontend\src\components\Register.js
import React, { useState, useEffect } from 'react';
import { TextField, Button, Container, Typography, Box, Card, CardContent, Alert } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import axios from 'axios';

function Register() {
	const [username, setUsername] = useState('');
	const [password, setPassword] = useState('');
	const [lastName, setLastName] = useState('');
	const [firstName, setFirstName] = useState('');
	const [middleName, setMiddleName] = useState('');
	const [error, setError] = useState('');
	const [success, setSuccess] = useState('');
	const navigate = useNavigate();
	const { login, setCsrfToken } = useAuth(); // Добавляем setCsrfToken

	useEffect(() => {
		// Получаем CSRF-токен один раз при монтировании компонента
		let mounted = true; // Флаг для предотвращения обновлений после размонтирования

		const fetchCsrfToken = async () => {
			try {
				console.log('Fetching CSRF token from /api/csrf-token');
				const response = await axios.get('http://localhost:5000/api/csrf-token', { withCredentials: true });
				if (mounted) { // Проверяем, что компонент всё ещё смонтирован
					setCsrfToken(response.data.csrf_token);
					console.log('CSRF token received:', response.data.csrf_token);
				}
			} catch (err) {
				console.error('Ошибка получения CSRF-токена:', err);
				if (mounted) {
					setError('Не удалось получить CSRF-токен. Попробуйте позже.');
				}
			}
		};

		fetchCsrfToken();

		// Очистка при размонтировании
		return () => {
			mounted = false;
		};
	}, [setCsrfToken]); // Пустой массив зависимостей — запрос выполняется только один раз при монтировании

	const handleSubmit = async (e) => {
		e.preventDefault();
		// Проверка на пустые поля
		if (!username.trim() || !password.trim() || !lastName.trim() || !firstName.trim() || !middleName.trim()) {
			setError('Все поля обязательны для заполнения.');
			return;
		}

		try {
			console.log('Sending registration request with data:', {
				username,
				password,
				last_name: lastName,
				first_name: firstName,
				middle_name: middleName,
			});
			const response = await axios.post('http://localhost:5000/api/register', {
				username,
				password,
				last_name: lastName,
				first_name: firstName,
				middle_name: middleName,
			}, {
				withCredentials: true,
				headers: {
					'Content-Type': 'application/json',
					'X-CSRFToken': localStorage.getItem('csrfToken') || '', // Отправляем CSRF-токен
				}
			});

			if (response.data.message === 'Пользователь зарегистрирован') {
				setSuccess('Регистрация успешна! Теперь вы можете войти.');
				setError('');
				setTimeout(() => navigate('/login'), 2000);
				login({ username, role: response.data.user.role });
			}
		} catch (err) {
			console.error('Registration error:', err.response?.data || err.message, err.response?.status);
			setError(err.response?.data?.error || 'Произошла ошибка при регистрации. Попробуйте позже.');
			setSuccess('');
		}
	};

	return (
		<Container maxWidth="sm" sx={{ mt: 8 }}>
			<Card elevation={4} sx={{ p: 4, borderRadius: 16, backgroundColor: 'white', boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)' }}>
				<CardContent>
					<Typography variant="h4" gutterBottom align="center" sx={{ mb: 3, color: '#1976D2' }}>
						Регистрация в Системе Публикаций
					</Typography>
					{error && (
						<Alert severity="error" sx={{ mb: 2, borderRadius: 8 }} onClose={() => setError('')}>
							{error}
						</Alert>
					)}
					{success && (
						<Alert severity="success" sx={{ mb: 2, borderRadius: 8 }} onClose={() => setSuccess('')}>
							{success}
						</Alert>
					)}
					<form onSubmit={handleSubmit}>
						<TextField
							fullWidth
							label="Логин"
							value={username}
							onChange={(e) => setUsername(e.target.value)}
							margin="normal"
							variant="outlined"
							sx={{ mb: 2, borderRadius: 8 }}
							autoComplete="username"
							required
						/>
						<TextField
							fullWidth
							label="Пароль"
							type="password"
							value={password}
							onChange={(e) => setPassword(e.target.value)}
							margin="normal"
							variant="outlined"
							sx={{ mb: 2, borderRadius: 8 }}
							autoComplete="new-password"
							required
						/>
						<TextField
							fullWidth
							label="Фамилия"
							value={lastName}
							onChange={(e) => setLastName(e.target.value)}
							margin="normal"
							variant="outlined"
							sx={{ mb: 2, borderRadius: 8 }}
							autoComplete="family-name"
							required
						/>
						<TextField
							fullWidth
							label="Имя"
							value={firstName}
							onChange={(e) => setFirstName(e.target.value)}
							margin="normal"
							variant="outlined"
							sx={{ mb: 2, borderRadius: 8 }}
							autoComplete="given-name"
							required
						/>
						<TextField
							fullWidth
							label="Отчество"
							value={middleName}
							onChange={(e) => setMiddleName(e.target.value)}
							margin="normal"
							variant="outlined"
							sx={{ mb: 2, borderRadius: 8 }}
							autoComplete="additional-name"
							required
						/>
						<Button
							type="submit"
							variant="contained"
							fullWidth
							sx={{ mt: 3, py: 1.5, borderRadius: 16, transition: 'all 0.3s ease', '&:hover': { transform: 'scale(1.05)' } }}
						>
							Зарегистрироваться
						</Button>
					</form>
				</CardContent>
			</Card>
		</Container>
	);
}

export default Register;
--------------
D:\publication-system\frontend\src\components\StatusChip.js
import React from 'react';
import { Chip } from '@mui/material';

const StatusChip = ({ status }) => {
	let label = status; // Значение по умолчанию
	let backgroundColor = '#D1D1D6'; // Серый по умолчанию
	let textColor = '#1D1D1F'; // Черный текст по умолчанию

	// Определяем метки и цвета для статусов
	switch (status) {
		case 'draft':
		case 'planned':
			label = 'Черновик';
			backgroundColor = '#6E6E73';
			textColor = '#FFFFFF';
			break;
		case 'needs_review':
		case 'in_progress':
			label = 'На проверке';
			backgroundColor = '#FF9500';
			textColor = '#FFFFFF';
			break;
		case 'returned':
			label = 'Требуется доработка';
			backgroundColor = '#FF3B30';
			textColor = '#FFFFFF';
			break;
		case 'published':
		case 'completed':
		case 'approved':
			label = 'Успешно';
			backgroundColor = '#2EBB4A';
			textColor = '#FFFFFF';
			break;
		default:
			label = status; // Если статус неизвестен, оставляем как есть
			backgroundColor = '#D1D1D6';
			textColor = '#1D1D1F';
	}

	return (
		<Chip
			label={label}
			sx={{
				backgroundColor: backgroundColor,
				color: textColor,
				fontSize: '0.75rem',
				fontWeight: 600,
				borderRadius: '12px',
				padding: '2px 8px',
				height: '24px',
				'& .MuiChip-label': {
					padding: '0 4px',
				},
				// Унифицированный стиль для всех чипов
				transition: 'all 0.3s ease',
				'&:hover': {
					filter: 'brightness(1.1)',
				},
			}}
		/>
	);
};

export default StatusChip;
------------------
D:\publication-system\frontend\src\contexts\AuthContext.js
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';

const AuthContext = createContext();

export function AuthProvider({ children }) {
	const [authState, setAuthState] = useState(() => {
		const storedUser = localStorage.getItem('user');
		const storedCsrfToken = localStorage.getItem('csrfToken');
		const parsedUser = storedUser ? JSON.parse(storedUser) : null;
		console.log('AuthContext: Инициализация состояния:', {
			isAuthenticated: !!storedUser,
			user: parsedUser,
			role: parsedUser?.role || null,
			csrfToken: storedCsrfToken,
		});
		return {
			isAuthenticated: !!storedUser,
			user: parsedUser || null,
			role: parsedUser?.role || null,
			csrfToken: storedCsrfToken || null,
			isLoading: true,
		};
	});

	useEffect(() => {
		const checkAuthStatus = async () => {
			try {
				console.log('AuthContext: Проверка аутентификации на сервере...');
				const response = await axios.get('http://localhost:5000/api/user', {
					withCredentials: true,
				});
				console.log('AuthContext: Ответ от /api/user:', response.data);
				const userData = {
					id: response.data.id,
					username: response.data.username,
					role: response.data.role || 'user',
					first_name: response.data.first_name || '',
					last_name: response.data.last_name || '',
					middle_name: response.data.middle_name || '',
				};
				setAuthState({
					isAuthenticated: true,
					user: userData,
					role: userData.role,
					csrfToken: authState.csrfToken,
					isLoading: false,
				});
				localStorage.setItem('user', JSON.stringify(userData));

				const tokenResponse = await axios.get('http://localhost:5000/api/csrf-token', {
					withCredentials: true,
				});
				setCsrfToken(tokenResponse.data.csrf_token);
				console.log('AuthContext: CSRF Token обновлён:', tokenResponse.data.csrf_token);
			} catch (err) {
				console.error('AuthContext: Ошибка проверки состояния аутентификации:', err.response?.status, err.response?.data?.error || err.message);
				if (err.response && err.response.status === 401) {
					console.log('AuthContext: Пользователь не аутентифицирован (401), вызываем logout...');
					logout();
				} else {
					console.error('AuthContext: Другая ошибка при проверке аутентификации:', err);
				}
				setAuthState((prevState) => ({
					...prevState,
					isLoading: false,
				}));
			}
		};

		if (authState.isAuthenticated) {
			checkAuthStatus();
		} else {
			console.log('AuthContext: Пользователь не аутентифицирован в localStorage, пропускаем проверку.');
			setAuthState((prevState) => ({
				...prevState,
				isLoading: false,
			}));
		}
	}, [authState.isAuthenticated]);

	const login = (userData) => {
		const user = {
			id: userData.id,
			username: userData.username,
			role: userData.role,
			first_name: userData.first_name || '',
			last_name: userData.last_name || '',
			middle_name: userData.middle_name || '',
		};
		console.log('AuthContext: Пользователь вошёл:', user);
		setAuthState({
			isAuthenticated: true,
			user: user,
			role: user.role,
			csrfToken: authState.csrfToken,
			isLoading: false,
		});
		localStorage.setItem('user', JSON.stringify(user));
	};

	const logout = () => {
		console.log('AuthContext: Пользователь выходит...');
		setAuthState({
			isAuthenticated: false,
			user: null,
			role: null,
			csrfToken: null,
			isLoading: false,
		});
		localStorage.removeItem('user');
		localStorage.removeItem('csrfToken');
	};

	const setUser = (newUser) => {
		setAuthState((prevState) => ({
			...prevState,
			user: newUser,
		}));
		localStorage.setItem('user', JSON.stringify(newUser));
	};

	const setCsrfToken = (token) => {
		console.log('AuthContext: Установка CSRF Token:', token);
		setAuthState((prevState) => ({
			...prevState,
			csrfToken: token,
		}));
		localStorage.setItem('csrfToken', token);
	};

	return (
		<AuthContext.Provider value={{ ...authState, login, logout, setUser, setCsrfToken }}>
			{children}
		</AuthContext.Provider>
	);
}

export function useAuth() {
	return useContext(AuthContext);
}
----------------------
D:\publication-system\frontend\src\utils\auth.js
import axios from 'axios';

const API_BASE = 'http://localhost:5000';

export const makeAuthenticatedRequest = async (url, method = 'POST', data = {}, options = {}) => {
    try {
        const fullUrl = url.startsWith('http') ? url : `${API_BASE}${url}`;

        // Получаем CSRF-токен из localStorage
        const csrfToken = localStorage.getItem('csrfToken') || '';

        console.log('Отправка запроса:', {
            url: fullUrl,
            method,
            headers: {
                'Content-Type': options.headers?.['Content-Type'] || 'application/json',
                'X-CSRFToken': csrfToken, // Добавляем CSRF-токен
                ...options.headers
            }
        });

        const response = await axios({
            method,
            url: fullUrl,
            data,
            withCredentials: true,
            headers: {
                'Content-Type': options.headers?.['Content-Type'] || 'application/json',
                'X-CSRFToken': csrfToken, // Добавляем CSRF-токен в заголовки
                ...options.headers
            }
        });

        console.log('Response from server:', response.data, response.status, response.headers);
        return response;
    } catch (err) {
        console.error('Ошибка в makeAuthenticatedRequest:', err.response?.data || err, err.response?.status, err.response?.headers);
        throw err;
    }
};

export const login = async (username, password) => {
    try {
        const response = await makeAuthenticatedRequest('/api/login', 'POST', { username, password });
        return response.data;
    } catch (err) {
        console.error('Ошибка авторизации:', err.response?.data || err);
        throw err;
    }
};

export const logout = async () => {
    try {
        const response = await makeAuthenticatedRequest('/api/logout', 'POST');
        return response.data;
    } catch (err) {
        console.error('Ошибка выхода:', err.response?.data || err);
        throw err;
    }
};

export const isAuthenticated = () => {
    const token = localStorage.getItem('token');
    return !!token;
};
---------------
D:\publication-system\frontend\src\App.js
import React from 'react';
import { Route, Routes, Navigate } from 'react-router-dom';
import Home from './components/Home';
import Login from './components/Login';
import Dashboard from './components/Dashboard';
import Publication from './components/Publication';
import Layout from './components/Layout';
import AdminDashboard from './components/AdminDashboard';
import ManagerDashboard from './components/ManagerDashboard'; // Импортируем новый компонент
import { useAuth } from './contexts/AuthContext';

function App() {
	const { isAuthenticated, user, isLoading } = useAuth();

	// Используем role из user, если он доступен, иначе из localStorage
	const storedUser = localStorage.getItem('user');
	const parsedUser = storedUser ? JSON.parse(storedUser) : null;
	const role = user?.role || parsedUser?.role || 'user';

	console.log('App.js: isAuthenticated:', isAuthenticated, 'Role:', role);

	if (isLoading) {
		console.log('App.js: Загрузка состояния аутентификации...');
		return <div>Загрузка...</div>;
	}

	const handleDashboardRedirect = () => {
		if (!isAuthenticated) {
			console.log('App.js: Перенаправление на /login: isAuthenticated is false');
			return <Navigate to="/login" replace />;
		} else if (role === 'admin') {
			console.log('App.js: Перенаправление на /admin: role is admin');
			return <Navigate to="/admin" replace />;
		} else if (role === 'manager') {
			console.log('App.js: Перенаправление на /manager: role is manager');
			return <Navigate to="/manager" replace />;
		} else if (role !== 'user') {
			console.log('App.js: Перенаправление на /login: role is not user, role:', role);
			return <Navigate to="/login" replace />;
		}
		return <Navigate to="/login" replace />;
	};

	const handleAdminRedirect = () => {
		if (!isAuthenticated) {
			console.log('App.js: Перенаправление на /login: isAuthenticated is false');
			return <Navigate to="/login" replace />;
		} else if (role === 'user') {
			console.log('App.js: Перенаправление на /dashboard: role is user');
			return <Navigate to="/dashboard" replace />;
		} else if (role === 'manager') {
			console.log('App.js: Перенаправление на /manager: role is manager');
			return <Navigate to="/manager" replace />;
		} else if (role !== 'admin') {
			console.log('App.js: Перенаправление на /login: role is not admin, role:', role);
			return <Navigate to="/login" replace />;
		}
		return <Navigate to="/login" replace />;
	};

	const handleManagerRedirect = () => {
		if (!isAuthenticated) {
			console.log('App.js: Перенаправление на /login: isAuthenticated is false');
			return <Navigate to="/login" replace />;
		} else if (role === 'user') {
			console.log('App.js: Перенаправление на /dashboard: role is user');
			return <Navigate to="/dashboard" replace />;
		} else if (role === 'admin') {
			console.log('App.js: Перенаправление на /admin: role is admin');
			return <Navigate to="/admin" replace />;
		} else if (role !== 'manager') {
			console.log('App.js: Перенаправление на /login: role is not manager, role:', role);
			return <Navigate to="/login" replace />;
		}
		return <Navigate to="/login" replace />;
	};

	const handlePublicationRedirect = () => {
		if (!isAuthenticated) {
			console.log('App.js: Перенаправление на /login: isAuthenticated is false');
			return <Navigate to="/login" replace />;
		}
		return null;
	};

	return (
		<Routes>
			<Route path="/" element={<Layout />}>
				<Route index element={<Home />} />
				<Route path="/login" element={<Login />} />
				<Route
					path="/dashboard"
					element={
						isAuthenticated && role === 'user' ? (
							<Dashboard />
						) : (
							handleDashboardRedirect()
						)
					}
				/>
				<Route
					path="/publication/:id"
					element={
						isAuthenticated ? (
							<Publication />
						) : (
							handlePublicationRedirect()
						)
					}
				/>
				<Route
					path="/admin"
					element={
						isAuthenticated && role === 'admin' ? (
							<AdminDashboard />
						) : (
							handleAdminRedirect()
						)
					}
				/>
				<Route
					path="/manager"
					element={
						isAuthenticated && role === 'manager' ? (
							<ManagerDashboard />
						) : (
							handleManagerRedirect()
						)
					}
				/>
				<Route path="*" element={<Navigate to="/" replace />} />
			</Route>
		</Routes>
	);
}

export default App;
-------------------
D:\publication-system\frontend\src\index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import { BrowserRouter as Router } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import theme from './theme';
import App from './App';
import { AuthProvider } from './contexts/AuthContext';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
	<ThemeProvider theme={theme}>
		<AuthProvider>
			<Router>
				<App />
			</Router>
		</AuthProvider>
	</ThemeProvider>
);


